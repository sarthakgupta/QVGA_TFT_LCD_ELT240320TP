   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"can.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	g_usCANBitValues:
  23 0000 0001     		.short	256
  24 0002 0002     		.short	512
  25 0004 4012     		.short	4672
  26 0006 4013     		.short	4928
  27 0008 8023     		.short	9088
  28 000a 8024     		.short	9344
  29 000c C034     		.short	13504
  30 000e C035     		.short	13760
  31 0010 C045     		.short	17856
  32 0012 C046     		.short	18112
  33 0014 C056     		.short	22208
  34 0016 C057     		.short	22464
  35 0018 C067     		.short	26560
  36 001a C068     		.short	26816
  37 001c C078     		.short	30912
  38 001e C079     		.short	31168
  39              		.section	.text.CANIntNumberGet,"ax",%progbits
  40              		.align	2
  41              		.thumb
  42              		.thumb_func
  44              	CANIntNumberGet:
  45              	.LFB0:
  46              		.file 1 "C:/StellarisWare/driverlib/can.c"
   1:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
   2:C:/StellarisWare/driverlib\can.c **** //
   3:C:/StellarisWare/driverlib\can.c **** // can.c - Driver for the CAN module.
   4:C:/StellarisWare/driverlib\can.c **** //
   5:C:/StellarisWare/driverlib\can.c **** // Copyright (c) 2006-2012 Texas Instruments Incorporated.  All rights reserved.
   6:C:/StellarisWare/driverlib\can.c **** // Software License Agreement
   7:C:/StellarisWare/driverlib\can.c **** // 
   8:C:/StellarisWare/driverlib\can.c **** //   Redistribution and use in source and binary forms, with or without
   9:C:/StellarisWare/driverlib\can.c **** //   modification, are permitted provided that the following conditions
  10:C:/StellarisWare/driverlib\can.c **** //   are met:
  11:C:/StellarisWare/driverlib\can.c **** // 
  12:C:/StellarisWare/driverlib\can.c **** //   Redistributions of source code must retain the above copyright
  13:C:/StellarisWare/driverlib\can.c **** //   notice, this list of conditions and the following disclaimer.
  14:C:/StellarisWare/driverlib\can.c **** // 
  15:C:/StellarisWare/driverlib\can.c **** //   Redistributions in binary form must reproduce the above copyright
  16:C:/StellarisWare/driverlib\can.c **** //   notice, this list of conditions and the following disclaimer in the
  17:C:/StellarisWare/driverlib\can.c **** //   documentation and/or other materials provided with the  
  18:C:/StellarisWare/driverlib\can.c **** //   distribution.
  19:C:/StellarisWare/driverlib\can.c **** // 
  20:C:/StellarisWare/driverlib\can.c **** //   Neither the name of Texas Instruments Incorporated nor the names of
  21:C:/StellarisWare/driverlib\can.c **** //   its contributors may be used to endorse or promote products derived
  22:C:/StellarisWare/driverlib\can.c **** //   from this software without specific prior written permission.
  23:C:/StellarisWare/driverlib\can.c **** // 
  24:C:/StellarisWare/driverlib\can.c **** // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  25:C:/StellarisWare/driverlib\can.c **** // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  26:C:/StellarisWare/driverlib\can.c **** // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  27:C:/StellarisWare/driverlib\can.c **** // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  28:C:/StellarisWare/driverlib\can.c **** // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  29:C:/StellarisWare/driverlib\can.c **** // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  30:C:/StellarisWare/driverlib\can.c **** // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  31:C:/StellarisWare/driverlib\can.c **** // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  32:C:/StellarisWare/driverlib\can.c **** // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  33:C:/StellarisWare/driverlib\can.c **** // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  34:C:/StellarisWare/driverlib\can.c **** // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/StellarisWare/driverlib\can.c **** // 
  36:C:/StellarisWare/driverlib\can.c **** // This is part of revision 9107 of the Stellaris Peripheral Driver Library.
  37:C:/StellarisWare/driverlib\can.c **** //
  38:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  39:C:/StellarisWare/driverlib\can.c **** 
  40:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  41:C:/StellarisWare/driverlib\can.c **** //
  42:C:/StellarisWare/driverlib\can.c **** //! \addtogroup can_api
  43:C:/StellarisWare/driverlib\can.c **** //! @{
  44:C:/StellarisWare/driverlib\can.c **** //
  45:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  46:C:/StellarisWare/driverlib\can.c **** 
  47:C:/StellarisWare/driverlib\can.c **** #include "inc/hw_can.h"
  48:C:/StellarisWare/driverlib\can.c **** #include "inc/hw_ints.h"
  49:C:/StellarisWare/driverlib\can.c **** #include "inc/hw_nvic.h"
  50:C:/StellarisWare/driverlib\can.c **** #include "inc/hw_memmap.h"
  51:C:/StellarisWare/driverlib\can.c **** #include "inc/hw_types.h"
  52:C:/StellarisWare/driverlib\can.c **** #include "driverlib/can.h"
  53:C:/StellarisWare/driverlib\can.c **** #include "driverlib/debug.h"
  54:C:/StellarisWare/driverlib\can.c **** #include "driverlib/interrupt.h"
  55:C:/StellarisWare/driverlib\can.c **** 
  56:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  57:C:/StellarisWare/driverlib\can.c **** //
  58:C:/StellarisWare/driverlib\can.c **** // This is the maximum number that can be stored as an 11bit Message
  59:C:/StellarisWare/driverlib\can.c **** // identifier.
  60:C:/StellarisWare/driverlib\can.c **** //
  61:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  62:C:/StellarisWare/driverlib\can.c **** #define CAN_MAX_11BIT_MSG_ID    0x7ff
  63:C:/StellarisWare/driverlib\can.c **** 
  64:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  65:C:/StellarisWare/driverlib\can.c **** //
  66:C:/StellarisWare/driverlib\can.c **** // This is used as the loop delay for accessing the CAN controller registers.
  67:C:/StellarisWare/driverlib\can.c **** //
  68:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  69:C:/StellarisWare/driverlib\can.c **** #define CAN_RW_DELAY            5
  70:C:/StellarisWare/driverlib\can.c **** 
  71:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  72:C:/StellarisWare/driverlib\can.c **** //
  73:C:/StellarisWare/driverlib\can.c **** // The maximum CAN bit timing divisor is 19.
  74:C:/StellarisWare/driverlib\can.c **** //
  75:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  76:C:/StellarisWare/driverlib\can.c **** #define CAN_MAX_BIT_DIVISOR     19
  77:C:/StellarisWare/driverlib\can.c **** 
  78:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  79:C:/StellarisWare/driverlib\can.c **** //
  80:C:/StellarisWare/driverlib\can.c **** // The minimum CAN bit timing divisor is 4.
  81:C:/StellarisWare/driverlib\can.c **** //
  82:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  83:C:/StellarisWare/driverlib\can.c **** #define CAN_MIN_BIT_DIVISOR     4
  84:C:/StellarisWare/driverlib\can.c **** 
  85:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  86:C:/StellarisWare/driverlib\can.c **** //
  87:C:/StellarisWare/driverlib\can.c **** // The maximum CAN pre-divisor is 1024.
  88:C:/StellarisWare/driverlib\can.c **** //
  89:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  90:C:/StellarisWare/driverlib\can.c **** #define CAN_MAX_PRE_DIVISOR     1024
  91:C:/StellarisWare/driverlib\can.c **** 
  92:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  93:C:/StellarisWare/driverlib\can.c **** //
  94:C:/StellarisWare/driverlib\can.c **** // The minimum CAN pre-divisor is 1.
  95:C:/StellarisWare/driverlib\can.c **** //
  96:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
  97:C:/StellarisWare/driverlib\can.c **** #define CAN_MIN_PRE_DIVISOR     1
  98:C:/StellarisWare/driverlib\can.c **** 
  99:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 100:C:/StellarisWare/driverlib\can.c **** //
 101:C:/StellarisWare/driverlib\can.c **** // Converts a set of CAN bit timing values into the value that needs to be
 102:C:/StellarisWare/driverlib\can.c **** // programmed into the CAN_BIT register to achieve those timings.
 103:C:/StellarisWare/driverlib\can.c **** //
 104:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 105:C:/StellarisWare/driverlib\can.c **** #define CAN_BIT_VALUE(seg1, seg2, sjw)                                        \
 106:C:/StellarisWare/driverlib\can.c ****                                 ((((seg1 - 1) << CAN_BIT_TSEG1_S) &           \
 107:C:/StellarisWare/driverlib\can.c ****                                   CAN_BIT_TSEG1_M) |                          \
 108:C:/StellarisWare/driverlib\can.c ****                                  (((seg2 - 1) << CAN_BIT_TSEG2_S) &           \
 109:C:/StellarisWare/driverlib\can.c ****                                   CAN_BIT_TSEG2_M) |                          \
 110:C:/StellarisWare/driverlib\can.c ****                                  (((sjw - 1) << CAN_BIT_SJW_S) &              \
 111:C:/StellarisWare/driverlib\can.c ****                                   CAN_BIT_SJW_M))
 112:C:/StellarisWare/driverlib\can.c **** 
 113:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 114:C:/StellarisWare/driverlib\can.c **** //
 115:C:/StellarisWare/driverlib\can.c **** // This table is used by the CANBitRateSet() API as the register defaults for
 116:C:/StellarisWare/driverlib\can.c **** // the bit timing values.
 117:C:/StellarisWare/driverlib\can.c **** //
 118:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 119:C:/StellarisWare/driverlib\can.c **** static const unsigned short g_usCANBitValues[] =
 120:C:/StellarisWare/driverlib\can.c **** {
 121:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(2, 1, 1),     // 4 clocks/bit
 122:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(3, 1, 1),     // 5 clocks/bit
 123:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(3, 2, 2),     // 6 clocks/bit
 124:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(4, 2, 2),     // 7 clocks/bit
 125:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(4, 3, 3),     // 8 clocks/bit
 126:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(5, 3, 3),     // 9 clocks/bit
 127:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(5, 4, 4),     // 10 clocks/bit
 128:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(6, 4, 4),     // 11 clocks/bit
 129:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(6, 5, 4),     // 12 clocks/bit
 130:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(7, 5, 4),     // 13 clocks/bit
 131:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(7, 6, 4),     // 14 clocks/bit
 132:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(8, 6, 4),     // 15 clocks/bit
 133:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(8, 7, 4),     // 16 clocks/bit
 134:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(9, 7, 4),     // 17 clocks/bit
 135:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(9, 8, 4),     // 18 clocks/bit
 136:C:/StellarisWare/driverlib\can.c ****     CAN_BIT_VALUE(10, 8, 4)     // 19 clocks/bit
 137:C:/StellarisWare/driverlib\can.c **** };
 138:C:/StellarisWare/driverlib\can.c **** 
 139:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 140:C:/StellarisWare/driverlib\can.c **** //
 141:C:/StellarisWare/driverlib\can.c **** //! \internal
 142:C:/StellarisWare/driverlib\can.c **** //! Checks a CAN base address.
 143:C:/StellarisWare/driverlib\can.c **** //!
 144:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 145:C:/StellarisWare/driverlib\can.c **** //!
 146:C:/StellarisWare/driverlib\can.c **** //! This function determines if a CAN controller base address is valid.
 147:C:/StellarisWare/driverlib\can.c **** //!
 148:C:/StellarisWare/driverlib\can.c **** //! \return Returns \b true if the base address is valid and \b false
 149:C:/StellarisWare/driverlib\can.c **** //! otherwise.
 150:C:/StellarisWare/driverlib\can.c **** //
 151:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 152:C:/StellarisWare/driverlib\can.c **** #ifdef DEBUG
 153:C:/StellarisWare/driverlib\can.c **** static tBoolean
 154:C:/StellarisWare/driverlib\can.c **** CANBaseValid(unsigned long ulBase)
 155:C:/StellarisWare/driverlib\can.c **** {
 156:C:/StellarisWare/driverlib\can.c ****     return((ulBase == CAN0_BASE) || (ulBase == CAN1_BASE) ||
 157:C:/StellarisWare/driverlib\can.c ****            (ulBase == CAN2_BASE));
 158:C:/StellarisWare/driverlib\can.c **** }
 159:C:/StellarisWare/driverlib\can.c **** #endif
 160:C:/StellarisWare/driverlib\can.c **** 
 161:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 162:C:/StellarisWare/driverlib\can.c **** //
 163:C:/StellarisWare/driverlib\can.c **** //! \internal
 164:C:/StellarisWare/driverlib\can.c **** //!
 165:C:/StellarisWare/driverlib\can.c **** //! Returns the CAN controller interrupt number.
 166:C:/StellarisWare/driverlib\can.c **** //!
 167:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the selected CAN controller
 168:C:/StellarisWare/driverlib\can.c **** //!
 169:C:/StellarisWare/driverlib\can.c **** //! Given a CAN controller base address, this function returns the
 170:C:/StellarisWare/driverlib\can.c **** //! corresponding interrupt number.
 171:C:/StellarisWare/driverlib\can.c **** //!
 172:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANGetIntNumber() API and performs the
 173:C:/StellarisWare/driverlib\can.c **** //! same actions.  A macro is provided in <tt>can.h</tt> to map the original
 174:C:/StellarisWare/driverlib\can.c **** //! API to this API.
 175:C:/StellarisWare/driverlib\can.c **** //!
 176:C:/StellarisWare/driverlib\can.c **** //! \return Returns a CAN interrupt number, or -1 if \e ulPort is invalid.
 177:C:/StellarisWare/driverlib\can.c **** //
 178:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 179:C:/StellarisWare/driverlib\can.c **** static long
 180:C:/StellarisWare/driverlib\can.c **** CANIntNumberGet(unsigned long ulBase)
 181:C:/StellarisWare/driverlib\can.c **** {
  47              		.loc 1 181 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 16
  50              		@ frame_needed = 1, uses_anonymous_args = 0
  51              		@ link register save eliminated.
  52 0000 80B4     		push	{r7}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 4
  55              		.cfi_offset 7, -4
  56 0002 85B0     		sub	sp, sp, #20
  57              	.LCFI1:
  58              		.cfi_def_cfa_offset 24
  59 0004 00AF     		add	r7, sp, #0
  60              	.LCFI2:
  61              		.cfi_def_cfa_register 7
  62 0006 7860     		str	r0, [r7, #4]
 182:C:/StellarisWare/driverlib\can.c ****     long lIntNumber;
 183:C:/StellarisWare/driverlib\can.c **** 
 184:C:/StellarisWare/driverlib\can.c ****     //
 185:C:/StellarisWare/driverlib\can.c ****     // Return the interrupt number for the given CAN controller.
 186:C:/StellarisWare/driverlib\can.c ****     //
 187:C:/StellarisWare/driverlib\can.c ****     switch(ulBase)
  63              		.loc 1 187 0
  64 0008 7A68     		ldr	r2, [r7, #4]
  65 000a 4FF48053 		mov	r3, #4096
  66 000e C4F20403 		movt	r3, 16388
  67 0012 9A42     		cmp	r2, r3
  68 0014 0FD0     		beq	.L4
  69 0016 4FF40053 		mov	r3, #8192
  70 001a C4F20403 		movt	r3, 16388
  71 001e 9A42     		cmp	r2, r3
  72 0020 0DD0     		beq	.L5
  73 0022 4FF00003 		mov	r3, #0
  74 0026 C4F20403 		movt	r3, 16388
  75 002a 9A42     		cmp	r2, r3
  76 002c 0BD1     		bne	.L7
  77              	.L3:
 188:C:/StellarisWare/driverlib\can.c ****     {
 189:C:/StellarisWare/driverlib\can.c ****         //
 190:C:/StellarisWare/driverlib\can.c ****         // Return the interrupt number for CAN 0
 191:C:/StellarisWare/driverlib\can.c ****         //
 192:C:/StellarisWare/driverlib\can.c ****         case CAN0_BASE:
 193:C:/StellarisWare/driverlib\can.c ****         {
 194:C:/StellarisWare/driverlib\can.c ****             lIntNumber = INT_CAN0;
  78              		.loc 1 194 0
  79 002e 4FF03703 		mov	r3, #55
  80 0032 FB60     		str	r3, [r7, #12]
 195:C:/StellarisWare/driverlib\can.c ****             break;
  81              		.loc 1 195 0
  82 0034 0AE0     		b	.L6
  83              	.L4:
 196:C:/StellarisWare/driverlib\can.c ****         }
 197:C:/StellarisWare/driverlib\can.c **** 
 198:C:/StellarisWare/driverlib\can.c ****         //
 199:C:/StellarisWare/driverlib\can.c ****         // Return the interrupt number for CAN 1
 200:C:/StellarisWare/driverlib\can.c ****         //
 201:C:/StellarisWare/driverlib\can.c ****         case CAN1_BASE:
 202:C:/StellarisWare/driverlib\can.c ****         {
 203:C:/StellarisWare/driverlib\can.c ****             lIntNumber = INT_CAN1;
  84              		.loc 1 203 0
  85 0036 4FF03803 		mov	r3, #56
  86 003a FB60     		str	r3, [r7, #12]
 204:C:/StellarisWare/driverlib\can.c ****             break;
  87              		.loc 1 204 0
  88 003c 06E0     		b	.L6
  89              	.L5:
 205:C:/StellarisWare/driverlib\can.c ****         }
 206:C:/StellarisWare/driverlib\can.c **** 
 207:C:/StellarisWare/driverlib\can.c ****         //
 208:C:/StellarisWare/driverlib\can.c ****         // Return the interrupt number for CAN 2
 209:C:/StellarisWare/driverlib\can.c ****         //
 210:C:/StellarisWare/driverlib\can.c ****         case CAN2_BASE:
 211:C:/StellarisWare/driverlib\can.c ****         {
 212:C:/StellarisWare/driverlib\can.c ****             lIntNumber = INT_CAN2;
  90              		.loc 1 212 0
  91 003e 4FF03903 		mov	r3, #57
  92 0042 FB60     		str	r3, [r7, #12]
 213:C:/StellarisWare/driverlib\can.c ****             break;
  93              		.loc 1 213 0
  94 0044 02E0     		b	.L6
  95              	.L7:
 214:C:/StellarisWare/driverlib\can.c ****         }
 215:C:/StellarisWare/driverlib\can.c **** 
 216:C:/StellarisWare/driverlib\can.c ****         //
 217:C:/StellarisWare/driverlib\can.c ****         // Return -1 to indicate a bad address was passed in.
 218:C:/StellarisWare/driverlib\can.c ****         //
 219:C:/StellarisWare/driverlib\can.c ****         default:
 220:C:/StellarisWare/driverlib\can.c ****         {
 221:C:/StellarisWare/driverlib\can.c ****             lIntNumber = -1;
  96              		.loc 1 221 0
  97 0046 4FF0FF33 		mov	r3, #-1
  98 004a FB60     		str	r3, [r7, #12]
  99              	.L6:
 222:C:/StellarisWare/driverlib\can.c ****         }
 223:C:/StellarisWare/driverlib\can.c ****     }
 224:C:/StellarisWare/driverlib\can.c ****     return(lIntNumber);
 100              		.loc 1 224 0
 101 004c FB68     		ldr	r3, [r7, #12]
 225:C:/StellarisWare/driverlib\can.c **** }
 102              		.loc 1 225 0
 103 004e 1846     		mov	r0, r3
 104 0050 07F11407 		add	r7, r7, #20
 105 0054 BD46     		mov	sp, r7
 106 0056 80BC     		pop	{r7}
 107 0058 7047     		bx	lr
 108              		.cfi_endproc
 109              	.LFE0:
 111 005a 00BF     		.section	.text.CANRegRead,"ax",%progbits
 112              		.align	2
 113              		.thumb
 114              		.thumb_func
 116              	CANRegRead:
 117              	.LFB1:
 226:C:/StellarisWare/driverlib\can.c **** 
 227:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 228:C:/StellarisWare/driverlib\can.c **** //
 229:C:/StellarisWare/driverlib\can.c **** //! \internal
 230:C:/StellarisWare/driverlib\can.c **** //!
 231:C:/StellarisWare/driverlib\can.c **** //! Reads a CAN controller register.
 232:C:/StellarisWare/driverlib\can.c **** //!
 233:C:/StellarisWare/driverlib\can.c **** //! \param ulRegAddress is the full address of the CAN register to be read.
 234:C:/StellarisWare/driverlib\can.c **** //!
 235:C:/StellarisWare/driverlib\can.c **** //! This function performs the necessary synchronization to read from a CAN
 236:C:/StellarisWare/driverlib\can.c **** //! controller register.
 237:C:/StellarisWare/driverlib\can.c **** //!
 238:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANReadReg() API and performs the same
 239:C:/StellarisWare/driverlib\can.c **** //! actions.  A macro is provided in <tt>can.h</tt> to map the original API to
 240:C:/StellarisWare/driverlib\can.c **** //! this API.
 241:C:/StellarisWare/driverlib\can.c **** //!
 242:C:/StellarisWare/driverlib\can.c **** //! \note This function provides the delay required to access CAN registers.
 243:C:/StellarisWare/driverlib\can.c **** //! This delay is required when accessing CAN registers directly.
 244:C:/StellarisWare/driverlib\can.c **** //!
 245:C:/StellarisWare/driverlib\can.c **** //! \return Returns the value read from the register.
 246:C:/StellarisWare/driverlib\can.c **** //
 247:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 248:C:/StellarisWare/driverlib\can.c **** static unsigned long
 249:C:/StellarisWare/driverlib\can.c **** CANRegRead(unsigned long ulRegAddress)
 250:C:/StellarisWare/driverlib\can.c **** {
 118              		.loc 1 250 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 24
 121              		@ frame_needed = 1, uses_anonymous_args = 0
 122 0000 80B5     		push	{r7, lr}
 123              	.LCFI3:
 124              		.cfi_def_cfa_offset 8
 125              		.cfi_offset 14, -4
 126              		.cfi_offset 7, -8
 127 0002 86B0     		sub	sp, sp, #24
 128              	.LCFI4:
 129              		.cfi_def_cfa_offset 32
 130 0004 00AF     		add	r7, sp, #0
 131              	.LCFI5:
 132              		.cfi_def_cfa_register 7
 133 0006 7860     		str	r0, [r7, #4]
 251:C:/StellarisWare/driverlib\can.c ****     volatile unsigned long ulDelay;
 252:C:/StellarisWare/driverlib\can.c ****     unsigned long ulRetVal;
 253:C:/StellarisWare/driverlib\can.c ****     unsigned long ulIntNumber;
 254:C:/StellarisWare/driverlib\can.c ****     unsigned long ulReenableInts;
 255:C:/StellarisWare/driverlib\can.c **** 
 256:C:/StellarisWare/driverlib\can.c ****     //
 257:C:/StellarisWare/driverlib\can.c ****     // Get the CAN interrupt number from the register base address.
 258:C:/StellarisWare/driverlib\can.c ****     //
 259:C:/StellarisWare/driverlib\can.c ****     ulIntNumber = CANIntNumberGet(ulRegAddress & 0xfffff000);
 134              		.loc 1 259 0
 135 0008 7B68     		ldr	r3, [r7, #4]
 136 000a 23F47E63 		bic	r3, r3, #4064
 137 000e 23F01F03 		bic	r3, r3, #31
 138 0012 1846     		mov	r0, r3
 139 0014 FFF7FEFF 		bl	CANIntNumberGet
 140 0018 0346     		mov	r3, r0
 141 001a 7B61     		str	r3, [r7, #20]
 260:C:/StellarisWare/driverlib\can.c **** 
 261:C:/StellarisWare/driverlib\can.c ****     //
 262:C:/StellarisWare/driverlib\can.c ****     // Make sure that the CAN base address was valid.
 263:C:/StellarisWare/driverlib\can.c ****     //
 264:C:/StellarisWare/driverlib\can.c ****     ASSERT(ulIntNumber != (unsigned long)-1);
 265:C:/StellarisWare/driverlib\can.c **** 
 266:C:/StellarisWare/driverlib\can.c ****     //
 267:C:/StellarisWare/driverlib\can.c ****     // Remember current state so that CAN interrupts are only re-enabled if
 268:C:/StellarisWare/driverlib\can.c ****     // they were already enabled.
 269:C:/StellarisWare/driverlib\can.c ****     //
 270:C:/StellarisWare/driverlib\can.c ****     ulReenableInts = HWREG(NVIC_EN1) & (1 << (ulIntNumber - 48));
 142              		.loc 1 270 0
 143 001c 4EF20413 		movw	r3, #57604
 144 0020 CEF20003 		movt	r3, 57344
 145 0024 1A68     		ldr	r2, [r3, #0]
 146 0026 7B69     		ldr	r3, [r7, #20]
 147 0028 A3F13003 		sub	r3, r3, #48
 148 002c 4FF00101 		mov	r1, #1
 149 0030 01FA03F3 		lsl	r3, r1, r3
 150 0034 1340     		ands	r3, r3, r2
 151 0036 3B61     		str	r3, [r7, #16]
 271:C:/StellarisWare/driverlib\can.c **** 
 272:C:/StellarisWare/driverlib\can.c ****     //
 273:C:/StellarisWare/driverlib\can.c ****     // If the CAN interrupt was enabled then disable it.
 274:C:/StellarisWare/driverlib\can.c ****     //
 275:C:/StellarisWare/driverlib\can.c ****     if(ulReenableInts)
 152              		.loc 1 275 0
 153 0038 3B69     		ldr	r3, [r7, #16]
 154 003a 002B     		cmp	r3, #0
 155 003c 02D0     		beq	.L9
 276:C:/StellarisWare/driverlib\can.c ****     {
 277:C:/StellarisWare/driverlib\can.c ****         IntDisable(ulIntNumber);
 156              		.loc 1 277 0
 157 003e 7869     		ldr	r0, [r7, #20]
 158 0040 FFF7FEFF 		bl	IntDisable
 159              	.L9:
 278:C:/StellarisWare/driverlib\can.c ****     }
 279:C:/StellarisWare/driverlib\can.c **** 
 280:C:/StellarisWare/driverlib\can.c ****     //
 281:C:/StellarisWare/driverlib\can.c ****     // Trigger the initial read to the CAN controller.  The value returned at
 282:C:/StellarisWare/driverlib\can.c ****     // this point is not valid.
 283:C:/StellarisWare/driverlib\can.c ****     //
 284:C:/StellarisWare/driverlib\can.c ****     HWREG(ulRegAddress);
 160              		.loc 1 284 0
 161 0044 7B68     		ldr	r3, [r7, #4]
 162 0046 1B68     		ldr	r3, [r3, #0]
 285:C:/StellarisWare/driverlib\can.c **** 
 286:C:/StellarisWare/driverlib\can.c ****     //
 287:C:/StellarisWare/driverlib\can.c ****     // This delay is necessary for the CAN have the correct data on the bus.
 288:C:/StellarisWare/driverlib\can.c ****     //
 289:C:/StellarisWare/driverlib\can.c ****     for(ulDelay = 0; ulDelay < CAN_RW_DELAY; ulDelay++)
 163              		.loc 1 289 0
 164 0048 4FF00003 		mov	r3, #0
 165 004c BB60     		str	r3, [r7, #8]
 166 004e 03E0     		b	.L10
 167              	.L11:
 168              		.loc 1 289 0 is_stmt 0 discriminator 2
 169 0050 BB68     		ldr	r3, [r7, #8]
 170 0052 03F10103 		add	r3, r3, #1
 171 0056 BB60     		str	r3, [r7, #8]
 172              	.L10:
 173              		.loc 1 289 0 discriminator 1
 174 0058 BB68     		ldr	r3, [r7, #8]
 175 005a 042B     		cmp	r3, #4
 176 005c F8D9     		bls	.L11
 290:C:/StellarisWare/driverlib\can.c ****     {
 291:C:/StellarisWare/driverlib\can.c ****     }
 292:C:/StellarisWare/driverlib\can.c **** 
 293:C:/StellarisWare/driverlib\can.c ****     //
 294:C:/StellarisWare/driverlib\can.c ****     // Do the final read that has the valid value of the register.
 295:C:/StellarisWare/driverlib\can.c ****     //
 296:C:/StellarisWare/driverlib\can.c ****     ulRetVal = HWREG(ulRegAddress);
 177              		.loc 1 296 0 is_stmt 1
 178 005e 7B68     		ldr	r3, [r7, #4]
 179 0060 1B68     		ldr	r3, [r3, #0]
 180 0062 FB60     		str	r3, [r7, #12]
 297:C:/StellarisWare/driverlib\can.c **** 
 298:C:/StellarisWare/driverlib\can.c ****     //
 299:C:/StellarisWare/driverlib\can.c ****     // Enable CAN interrupts if they were enabled before this call.
 300:C:/StellarisWare/driverlib\can.c ****     //
 301:C:/StellarisWare/driverlib\can.c ****     if(ulReenableInts)
 181              		.loc 1 301 0
 182 0064 3B69     		ldr	r3, [r7, #16]
 183 0066 002B     		cmp	r3, #0
 184 0068 02D0     		beq	.L12
 302:C:/StellarisWare/driverlib\can.c ****     {
 303:C:/StellarisWare/driverlib\can.c ****         IntEnable(ulIntNumber);
 185              		.loc 1 303 0
 186 006a 7869     		ldr	r0, [r7, #20]
 187 006c FFF7FEFF 		bl	IntEnable
 188              	.L12:
 304:C:/StellarisWare/driverlib\can.c ****     }
 305:C:/StellarisWare/driverlib\can.c **** 
 306:C:/StellarisWare/driverlib\can.c ****     return(ulRetVal);
 189              		.loc 1 306 0
 190 0070 FB68     		ldr	r3, [r7, #12]
 307:C:/StellarisWare/driverlib\can.c **** }
 191              		.loc 1 307 0
 192 0072 1846     		mov	r0, r3
 193 0074 07F11807 		add	r7, r7, #24
 194 0078 BD46     		mov	sp, r7
 195 007a 80BD     		pop	{r7, pc}
 196              		.cfi_endproc
 197              	.LFE1:
 199              		.section	.text.CANRegWrite,"ax",%progbits
 200              		.align	2
 201              		.thumb
 202              		.thumb_func
 204              	CANRegWrite:
 205              	.LFB2:
 308:C:/StellarisWare/driverlib\can.c **** 
 309:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 310:C:/StellarisWare/driverlib\can.c **** //
 311:C:/StellarisWare/driverlib\can.c **** //! \internal
 312:C:/StellarisWare/driverlib\can.c **** //!
 313:C:/StellarisWare/driverlib\can.c **** //! Writes a CAN controller register.
 314:C:/StellarisWare/driverlib\can.c **** //!
 315:C:/StellarisWare/driverlib\can.c **** //! \param ulRegAddress is the full address of the CAN register to be written.
 316:C:/StellarisWare/driverlib\can.c **** //! \param ulRegValue is the value to write into the register specified by
 317:C:/StellarisWare/driverlib\can.c **** //! \e ulRegAddress.
 318:C:/StellarisWare/driverlib\can.c **** //!
 319:C:/StellarisWare/driverlib\can.c **** //! This function takes care of the synchronization necessary to write to a
 320:C:/StellarisWare/driverlib\can.c **** //! CAN controller register.
 321:C:/StellarisWare/driverlib\can.c **** //!
 322:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANWriteReg() API and performs the same
 323:C:/StellarisWare/driverlib\can.c **** //! actions.  A macro is provided in <tt>can.h</tt> to map the original API to
 324:C:/StellarisWare/driverlib\can.c **** //! this API.
 325:C:/StellarisWare/driverlib\can.c **** //!
 326:C:/StellarisWare/driverlib\can.c **** //! \note The delays in this function are required when accessing CAN registers
 327:C:/StellarisWare/driverlib\can.c **** //! directly.
 328:C:/StellarisWare/driverlib\can.c **** //!
 329:C:/StellarisWare/driverlib\can.c **** //! \return None.
 330:C:/StellarisWare/driverlib\can.c **** //
 331:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 332:C:/StellarisWare/driverlib\can.c **** static void
 333:C:/StellarisWare/driverlib\can.c **** CANRegWrite(unsigned long ulRegAddress, unsigned long ulRegValue)
 334:C:/StellarisWare/driverlib\can.c **** {
 206              		.loc 1 334 0
 207              		.cfi_startproc
 208              		@ args = 0, pretend = 0, frame = 16
 209              		@ frame_needed = 1, uses_anonymous_args = 0
 210              		@ link register save eliminated.
 211 0000 80B4     		push	{r7}
 212              	.LCFI6:
 213              		.cfi_def_cfa_offset 4
 214              		.cfi_offset 7, -4
 215 0002 85B0     		sub	sp, sp, #20
 216              	.LCFI7:
 217              		.cfi_def_cfa_offset 24
 218 0004 00AF     		add	r7, sp, #0
 219              	.LCFI8:
 220              		.cfi_def_cfa_register 7
 221 0006 7860     		str	r0, [r7, #4]
 222 0008 3960     		str	r1, [r7, #0]
 335:C:/StellarisWare/driverlib\can.c ****     volatile unsigned long ulDelay;
 336:C:/StellarisWare/driverlib\can.c **** 
 337:C:/StellarisWare/driverlib\can.c ****     //
 338:C:/StellarisWare/driverlib\can.c ****     // Trigger the initial write to the CAN controller.  The value will not make
 339:C:/StellarisWare/driverlib\can.c ****     // it out to the CAN controller for CAN_RW_DELAY cycles.
 340:C:/StellarisWare/driverlib\can.c ****     //
 341:C:/StellarisWare/driverlib\can.c ****     HWREG(ulRegAddress) = ulRegValue;
 223              		.loc 1 341 0
 224 000a 7B68     		ldr	r3, [r7, #4]
 225 000c 3A68     		ldr	r2, [r7, #0]
 226 000e 1A60     		str	r2, [r3, #0]
 342:C:/StellarisWare/driverlib\can.c **** 
 343:C:/StellarisWare/driverlib\can.c ****     //
 344:C:/StellarisWare/driverlib\can.c ****     // Delay to allow the CAN controller to receive the new data.
 345:C:/StellarisWare/driverlib\can.c ****     //
 346:C:/StellarisWare/driverlib\can.c ****     for(ulDelay = 0; ulDelay < CAN_RW_DELAY; ulDelay++)
 227              		.loc 1 346 0
 228 0010 4FF00003 		mov	r3, #0
 229 0014 FB60     		str	r3, [r7, #12]
 230 0016 03E0     		b	.L14
 231              	.L15:
 232              		.loc 1 346 0 is_stmt 0 discriminator 2
 233 0018 FB68     		ldr	r3, [r7, #12]
 234 001a 03F10103 		add	r3, r3, #1
 235 001e FB60     		str	r3, [r7, #12]
 236              	.L14:
 237              		.loc 1 346 0 discriminator 1
 238 0020 FB68     		ldr	r3, [r7, #12]
 239 0022 042B     		cmp	r3, #4
 240 0024 F8D9     		bls	.L15
 347:C:/StellarisWare/driverlib\can.c ****     {
 348:C:/StellarisWare/driverlib\can.c ****     }
 349:C:/StellarisWare/driverlib\can.c **** }
 241              		.loc 1 349 0 is_stmt 1
 242 0026 07F11407 		add	r7, r7, #20
 243 002a BD46     		mov	sp, r7
 244 002c 80BC     		pop	{r7}
 245 002e 7047     		bx	lr
 246              		.cfi_endproc
 247              	.LFE2:
 249              		.section	.text.CANDataRegWrite,"ax",%progbits
 250              		.align	2
 251              		.thumb
 252              		.thumb_func
 254              	CANDataRegWrite:
 255              	.LFB3:
 350:C:/StellarisWare/driverlib\can.c **** 
 351:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 352:C:/StellarisWare/driverlib\can.c **** //
 353:C:/StellarisWare/driverlib\can.c **** //! \internal
 354:C:/StellarisWare/driverlib\can.c **** //!
 355:C:/StellarisWare/driverlib\can.c **** //! Copies data from a buffer to the CAN Data registers.
 356:C:/StellarisWare/driverlib\can.c **** //!
 357:C:/StellarisWare/driverlib\can.c **** //! \param pucData is a pointer to the data to be written out to the CAN
 358:C:/StellarisWare/driverlib\can.c **** //! controller's data registers.
 359:C:/StellarisWare/driverlib\can.c **** //! \param pulRegister is an unsigned long pointer to the first register of the
 360:C:/StellarisWare/driverlib\can.c **** //! CAN controller's data registers.  For example, in order to use the IF1
 361:C:/StellarisWare/driverlib\can.c **** //! register set on CAN controller 0, the value would be: \b CAN0_BASE \b +
 362:C:/StellarisWare/driverlib\can.c **** //! \b CAN_O_IF1DA1.
 363:C:/StellarisWare/driverlib\can.c **** //! \param iSize is the number of bytes to copy into the CAN controller.
 364:C:/StellarisWare/driverlib\can.c **** //!
 365:C:/StellarisWare/driverlib\can.c **** //! This function takes the steps necessary to copy data from a contiguous
 366:C:/StellarisWare/driverlib\can.c **** //! buffer in memory into the non-contiguous data registers used by the CAN
 367:C:/StellarisWare/driverlib\can.c **** //! controller.  This function is rarely used outside of the CANMessageSet()
 368:C:/StellarisWare/driverlib\can.c **** //! function.
 369:C:/StellarisWare/driverlib\can.c **** //!
 370:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANWriteDataReg() API and performs the
 371:C:/StellarisWare/driverlib\can.c **** //! same actions.  A macro is provided in <tt>can.h</tt> to map the original
 372:C:/StellarisWare/driverlib\can.c **** //! API to this API.
 373:C:/StellarisWare/driverlib\can.c **** //!
 374:C:/StellarisWare/driverlib\can.c **** //! \return None.
 375:C:/StellarisWare/driverlib\can.c **** //
 376:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 377:C:/StellarisWare/driverlib\can.c **** static void
 378:C:/StellarisWare/driverlib\can.c **** CANDataRegWrite(unsigned char *pucData, unsigned long *pulRegister,
 379:C:/StellarisWare/driverlib\can.c ****                 unsigned long ulSize)
 380:C:/StellarisWare/driverlib\can.c **** {
 256              		.loc 1 380 0
 257              		.cfi_startproc
 258              		@ args = 0, pretend = 0, frame = 24
 259              		@ frame_needed = 1, uses_anonymous_args = 0
 260 0000 80B5     		push	{r7, lr}
 261              	.LCFI9:
 262              		.cfi_def_cfa_offset 8
 263              		.cfi_offset 14, -4
 264              		.cfi_offset 7, -8
 265 0002 86B0     		sub	sp, sp, #24
 266              	.LCFI10:
 267              		.cfi_def_cfa_offset 32
 268 0004 00AF     		add	r7, sp, #0
 269              	.LCFI11:
 270              		.cfi_def_cfa_register 7
 271 0006 F860     		str	r0, [r7, #12]
 272 0008 B960     		str	r1, [r7, #8]
 273 000a 7A60     		str	r2, [r7, #4]
 381:C:/StellarisWare/driverlib\can.c ****     unsigned long ulIdx, ulValue;
 382:C:/StellarisWare/driverlib\can.c **** 
 383:C:/StellarisWare/driverlib\can.c ****     //
 384:C:/StellarisWare/driverlib\can.c ****     // Loop always copies 1 or 2 bytes per iteration.
 385:C:/StellarisWare/driverlib\can.c ****     //
 386:C:/StellarisWare/driverlib\can.c ****     for(ulIdx = 0; ulIdx < ulSize; )
 274              		.loc 1 386 0
 275 000c 4FF00003 		mov	r3, #0
 276 0010 7B61     		str	r3, [r7, #20]
 277 0012 22E0     		b	.L17
 278              	.L19:
 387:C:/StellarisWare/driverlib\can.c ****     {
 388:C:/StellarisWare/driverlib\can.c **** 
 389:C:/StellarisWare/driverlib\can.c ****         //
 390:C:/StellarisWare/driverlib\can.c ****         // Write out the data 16 bits at a time since this is how the registers
 391:C:/StellarisWare/driverlib\can.c ****         // are aligned in memory.
 392:C:/StellarisWare/driverlib\can.c ****         //
 393:C:/StellarisWare/driverlib\can.c ****         ulValue = pucData[ulIdx++];
 279              		.loc 1 393 0
 280 0014 FA68     		ldr	r2, [r7, #12]
 281 0016 7B69     		ldr	r3, [r7, #20]
 282 0018 D318     		adds	r3, r2, r3
 283 001a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 284 001c 3B61     		str	r3, [r7, #16]
 285 001e 7B69     		ldr	r3, [r7, #20]
 286 0020 03F10103 		add	r3, r3, #1
 287 0024 7B61     		str	r3, [r7, #20]
 394:C:/StellarisWare/driverlib\can.c **** 
 395:C:/StellarisWare/driverlib\can.c ****         //
 396:C:/StellarisWare/driverlib\can.c ****         // Only write the second byte if needed otherwise it will be zero.
 397:C:/StellarisWare/driverlib\can.c ****         //
 398:C:/StellarisWare/driverlib\can.c ****         if(ulIdx < ulSize)
 288              		.loc 1 398 0
 289 0026 7A69     		ldr	r2, [r7, #20]
 290 0028 7B68     		ldr	r3, [r7, #4]
 291 002a 9A42     		cmp	r2, r3
 292 002c 0CD2     		bcs	.L18
 399:C:/StellarisWare/driverlib\can.c ****         {
 400:C:/StellarisWare/driverlib\can.c ****             ulValue |= (pucData[ulIdx++] << 8);
 293              		.loc 1 400 0
 294 002e FA68     		ldr	r2, [r7, #12]
 295 0030 7B69     		ldr	r3, [r7, #20]
 296 0032 D318     		adds	r3, r2, r3
 297 0034 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 298 0036 4FEA0323 		lsl	r3, r3, #8
 299 003a 3A69     		ldr	r2, [r7, #16]
 300 003c 1343     		orrs	r3, r3, r2
 301 003e 3B61     		str	r3, [r7, #16]
 302 0040 7B69     		ldr	r3, [r7, #20]
 303 0042 03F10103 		add	r3, r3, #1
 304 0046 7B61     		str	r3, [r7, #20]
 305              	.L18:
 401:C:/StellarisWare/driverlib\can.c ****         }
 402:C:/StellarisWare/driverlib\can.c ****         CANRegWrite((unsigned long)(pulRegister++), ulValue);
 306              		.loc 1 402 0
 307 0048 BB68     		ldr	r3, [r7, #8]
 308 004a BA68     		ldr	r2, [r7, #8]
 309 004c 02F10402 		add	r2, r2, #4
 310 0050 BA60     		str	r2, [r7, #8]
 311 0052 1846     		mov	r0, r3
 312 0054 3969     		ldr	r1, [r7, #16]
 313 0056 FFF7FEFF 		bl	CANRegWrite
 314              	.L17:
 386:C:/StellarisWare/driverlib\can.c ****     for(ulIdx = 0; ulIdx < ulSize; )
 315              		.loc 1 386 0 discriminator 1
 316 005a 7A69     		ldr	r2, [r7, #20]
 317 005c 7B68     		ldr	r3, [r7, #4]
 318 005e 9A42     		cmp	r2, r3
 319 0060 D8D3     		bcc	.L19
 403:C:/StellarisWare/driverlib\can.c ****     }
 404:C:/StellarisWare/driverlib\can.c **** }
 320              		.loc 1 404 0
 321 0062 07F11807 		add	r7, r7, #24
 322 0066 BD46     		mov	sp, r7
 323 0068 80BD     		pop	{r7, pc}
 324              		.cfi_endproc
 325              	.LFE3:
 327 006a 00BF     		.section	.text.CANDataRegRead,"ax",%progbits
 328              		.align	2
 329              		.thumb
 330              		.thumb_func
 332              	CANDataRegRead:
 333              	.LFB4:
 405:C:/StellarisWare/driverlib\can.c **** 
 406:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 407:C:/StellarisWare/driverlib\can.c **** //
 408:C:/StellarisWare/driverlib\can.c **** //! \internal
 409:C:/StellarisWare/driverlib\can.c **** //!
 410:C:/StellarisWare/driverlib\can.c **** //! Copies data from a buffer to the CAN Data registers.
 411:C:/StellarisWare/driverlib\can.c **** //!
 412:C:/StellarisWare/driverlib\can.c **** //! \param pucData is a pointer to the location to store the data read from the
 413:C:/StellarisWare/driverlib\can.c **** //! CAN controller's data registers.
 414:C:/StellarisWare/driverlib\can.c **** //! \param pulRegister is an unsigned long pointer to the first register of the
 415:C:/StellarisWare/driverlib\can.c **** //! CAN controller's data registers.  For example, in order to use the IF1
 416:C:/StellarisWare/driverlib\can.c **** //! register set on CAN controller 1, the value would be: \b CAN0_BASE \b +
 417:C:/StellarisWare/driverlib\can.c **** //! \b CAN_O_IF1DA1.
 418:C:/StellarisWare/driverlib\can.c **** //! \param iSize is the number of bytes to copy from the CAN controller.
 419:C:/StellarisWare/driverlib\can.c **** //!
 420:C:/StellarisWare/driverlib\can.c **** //! This function takes the steps necessary to copy data to a contiguous buffer
 421:C:/StellarisWare/driverlib\can.c **** //! in memory from the non-contiguous data registers used by the CAN
 422:C:/StellarisWare/driverlib\can.c **** //! controller.  This function is rarely used outside of the CANMessageGet()
 423:C:/StellarisWare/driverlib\can.c **** //! function.
 424:C:/StellarisWare/driverlib\can.c **** //!
 425:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANReadDataReg() API and performs the
 426:C:/StellarisWare/driverlib\can.c **** //! same actions.  A macro is provided in <tt>can.h</tt> to map the original
 427:C:/StellarisWare/driverlib\can.c **** //! API to this API.
 428:C:/StellarisWare/driverlib\can.c **** //!
 429:C:/StellarisWare/driverlib\can.c **** //! \return None.
 430:C:/StellarisWare/driverlib\can.c **** //
 431:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 432:C:/StellarisWare/driverlib\can.c **** static void
 433:C:/StellarisWare/driverlib\can.c **** CANDataRegRead(unsigned char *pucData, unsigned long *pulRegister,
 434:C:/StellarisWare/driverlib\can.c ****                unsigned long ulSize)
 435:C:/StellarisWare/driverlib\can.c **** {
 334              		.loc 1 435 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 24
 337              		@ frame_needed = 1, uses_anonymous_args = 0
 338 0000 80B5     		push	{r7, lr}
 339              	.LCFI12:
 340              		.cfi_def_cfa_offset 8
 341              		.cfi_offset 14, -4
 342              		.cfi_offset 7, -8
 343 0002 86B0     		sub	sp, sp, #24
 344              	.LCFI13:
 345              		.cfi_def_cfa_offset 32
 346 0004 00AF     		add	r7, sp, #0
 347              	.LCFI14:
 348              		.cfi_def_cfa_register 7
 349 0006 F860     		str	r0, [r7, #12]
 350 0008 B960     		str	r1, [r7, #8]
 351 000a 7A60     		str	r2, [r7, #4]
 436:C:/StellarisWare/driverlib\can.c ****     unsigned long ulIdx, ulValue;
 437:C:/StellarisWare/driverlib\can.c **** 
 438:C:/StellarisWare/driverlib\can.c ****     //
 439:C:/StellarisWare/driverlib\can.c ****     // Loop always copies 1 or 2 bytes per iteration.
 440:C:/StellarisWare/driverlib\can.c ****     //
 441:C:/StellarisWare/driverlib\can.c ****     for(ulIdx = 0; ulIdx < ulSize; )
 352              		.loc 1 441 0
 353 000c 4FF00003 		mov	r3, #0
 354 0010 7B61     		str	r3, [r7, #20]
 355 0012 22E0     		b	.L21
 356              	.L22:
 442:C:/StellarisWare/driverlib\can.c ****     {
 443:C:/StellarisWare/driverlib\can.c ****         //
 444:C:/StellarisWare/driverlib\can.c ****         // Read out the data 16 bits at a time since this is how the registers
 445:C:/StellarisWare/driverlib\can.c ****         // are aligned in memory.
 446:C:/StellarisWare/driverlib\can.c ****         //
 447:C:/StellarisWare/driverlib\can.c ****         ulValue = CANRegRead((unsigned long)(pulRegister++));
 357              		.loc 1 447 0
 358 0014 BB68     		ldr	r3, [r7, #8]
 359 0016 BA68     		ldr	r2, [r7, #8]
 360 0018 02F10402 		add	r2, r2, #4
 361 001c BA60     		str	r2, [r7, #8]
 362 001e 1846     		mov	r0, r3
 363 0020 FFF7FEFF 		bl	CANRegRead
 364 0024 3861     		str	r0, [r7, #16]
 448:C:/StellarisWare/driverlib\can.c **** 
 449:C:/StellarisWare/driverlib\can.c ****         //
 450:C:/StellarisWare/driverlib\can.c ****         // Store the first byte.
 451:C:/StellarisWare/driverlib\can.c ****         //
 452:C:/StellarisWare/driverlib\can.c ****         pucData[ulIdx++] = (unsigned char)ulValue;
 365              		.loc 1 452 0
 366 0026 FA68     		ldr	r2, [r7, #12]
 367 0028 7B69     		ldr	r3, [r7, #20]
 368 002a D318     		adds	r3, r2, r3
 369 002c 3A69     		ldr	r2, [r7, #16]
 370 002e D2B2     		uxtb	r2, r2
 371 0030 1A70     		strb	r2, [r3, #0]
 372 0032 7B69     		ldr	r3, [r7, #20]
 373 0034 03F10103 		add	r3, r3, #1
 374 0038 7B61     		str	r3, [r7, #20]
 453:C:/StellarisWare/driverlib\can.c **** 
 454:C:/StellarisWare/driverlib\can.c ****         //
 455:C:/StellarisWare/driverlib\can.c ****         // Only read the second byte if needed.
 456:C:/StellarisWare/driverlib\can.c ****         //
 457:C:/StellarisWare/driverlib\can.c ****         if(ulIdx < ulSize)
 375              		.loc 1 457 0
 376 003a 7A69     		ldr	r2, [r7, #20]
 377 003c 7B68     		ldr	r3, [r7, #4]
 378 003e 9A42     		cmp	r2, r3
 379 0040 0BD2     		bcs	.L21
 458:C:/StellarisWare/driverlib\can.c ****         {
 459:C:/StellarisWare/driverlib\can.c ****             pucData[ulIdx++] = (unsigned char)(ulValue >> 8);
 380              		.loc 1 459 0
 381 0042 FA68     		ldr	r2, [r7, #12]
 382 0044 7B69     		ldr	r3, [r7, #20]
 383 0046 D318     		adds	r3, r2, r3
 384 0048 3A69     		ldr	r2, [r7, #16]
 385 004a 4FEA1222 		lsr	r2, r2, #8
 386 004e D2B2     		uxtb	r2, r2
 387 0050 1A70     		strb	r2, [r3, #0]
 388 0052 7B69     		ldr	r3, [r7, #20]
 389 0054 03F10103 		add	r3, r3, #1
 390 0058 7B61     		str	r3, [r7, #20]
 391              	.L21:
 441:C:/StellarisWare/driverlib\can.c ****     for(ulIdx = 0; ulIdx < ulSize; )
 392              		.loc 1 441 0 discriminator 1
 393 005a 7A69     		ldr	r2, [r7, #20]
 394 005c 7B68     		ldr	r3, [r7, #4]
 395 005e 9A42     		cmp	r2, r3
 396 0060 D8D3     		bcc	.L22
 460:C:/StellarisWare/driverlib\can.c ****         }
 461:C:/StellarisWare/driverlib\can.c ****     }
 462:C:/StellarisWare/driverlib\can.c **** }
 397              		.loc 1 462 0
 398 0062 07F11807 		add	r7, r7, #24
 399 0066 BD46     		mov	sp, r7
 400 0068 80BD     		pop	{r7, pc}
 401              		.cfi_endproc
 402              	.LFE4:
 404 006a 00BF     		.section	.text.CANInit,"ax",%progbits
 405              		.align	2
 406              		.global	CANInit
 407              		.thumb
 408              		.thumb_func
 410              	CANInit:
 411              	.LFB5:
 463:C:/StellarisWare/driverlib\can.c **** 
 464:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 465:C:/StellarisWare/driverlib\can.c **** //
 466:C:/StellarisWare/driverlib\can.c **** //! Initializes the CAN controller after reset.
 467:C:/StellarisWare/driverlib\can.c **** //!
 468:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 469:C:/StellarisWare/driverlib\can.c **** //!
 470:C:/StellarisWare/driverlib\can.c **** //! After reset, the CAN controller is left in the disabled state.  However,
 471:C:/StellarisWare/driverlib\can.c **** //! the memory used for message objects contains undefined values and must be
 472:C:/StellarisWare/driverlib\can.c **** //! cleared prior to enabling the CAN controller the first time.  This prevents
 473:C:/StellarisWare/driverlib\can.c **** //! unwanted transmission or reception of data before the message objects are
 474:C:/StellarisWare/driverlib\can.c **** //! configured.  This function must be called before enabling the controller
 475:C:/StellarisWare/driverlib\can.c **** //! the first time.
 476:C:/StellarisWare/driverlib\can.c **** //!
 477:C:/StellarisWare/driverlib\can.c **** //! \return None.
 478:C:/StellarisWare/driverlib\can.c **** //
 479:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 480:C:/StellarisWare/driverlib\can.c **** void
 481:C:/StellarisWare/driverlib\can.c **** CANInit(unsigned long ulBase)
 482:C:/StellarisWare/driverlib\can.c **** {
 412              		.loc 1 482 0
 413              		.cfi_startproc
 414              		@ args = 0, pretend = 0, frame = 16
 415              		@ frame_needed = 1, uses_anonymous_args = 0
 416 0000 80B5     		push	{r7, lr}
 417              	.LCFI15:
 418              		.cfi_def_cfa_offset 8
 419              		.cfi_offset 14, -4
 420              		.cfi_offset 7, -8
 421 0002 84B0     		sub	sp, sp, #16
 422              	.LCFI16:
 423              		.cfi_def_cfa_offset 24
 424 0004 00AF     		add	r7, sp, #0
 425              	.LCFI17:
 426              		.cfi_def_cfa_register 7
 427 0006 7860     		str	r0, [r7, #4]
 483:C:/StellarisWare/driverlib\can.c ****     unsigned long ulMsg;
 484:C:/StellarisWare/driverlib\can.c **** 
 485:C:/StellarisWare/driverlib\can.c ****     //
 486:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 487:C:/StellarisWare/driverlib\can.c ****     //
 488:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 489:C:/StellarisWare/driverlib\can.c **** 
 490:C:/StellarisWare/driverlib\can.c ****     //
 491:C:/StellarisWare/driverlib\can.c ****     // Place CAN controller in init state, regardless of previous state.  This
 492:C:/StellarisWare/driverlib\can.c ****     // will put controller in idle, and allow the message object RAM to be
 493:C:/StellarisWare/driverlib\can.c ****     // programmed.
 494:C:/StellarisWare/driverlib\can.c ****     //
 495:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL, CAN_CTL_INIT);
 428              		.loc 1 495 0
 429 0008 7868     		ldr	r0, [r7, #4]
 430 000a 4FF00101 		mov	r1, #1
 431 000e FFF7FEFF 		bl	CANRegWrite
 496:C:/StellarisWare/driverlib\can.c **** 
 497:C:/StellarisWare/driverlib\can.c ****     //
 498:C:/StellarisWare/driverlib\can.c ****     // Wait for busy bit to clear
 499:C:/StellarisWare/driverlib\can.c ****     //
 500:C:/StellarisWare/driverlib\can.c ****     while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 432              		.loc 1 500 0
 433 0012 00BF     		nop
 434              	.L24:
 435              		.loc 1 500 0 is_stmt 0 discriminator 1
 436 0014 7B68     		ldr	r3, [r7, #4]
 437 0016 03F12003 		add	r3, r3, #32
 438 001a 1846     		mov	r0, r3
 439 001c FFF7FEFF 		bl	CANRegRead
 440 0020 0346     		mov	r3, r0
 441 0022 03F40043 		and	r3, r3, #32768
 442 0026 002B     		cmp	r3, #0
 443 0028 F4D1     		bne	.L24
 501:C:/StellarisWare/driverlib\can.c ****     {
 502:C:/StellarisWare/driverlib\can.c ****     }
 503:C:/StellarisWare/driverlib\can.c **** 
 504:C:/StellarisWare/driverlib\can.c ****     //
 505:C:/StellarisWare/driverlib\can.c ****     // Clear the message value bit in the arbitration register.  This indicates
 506:C:/StellarisWare/driverlib\can.c ****     // the message is not valid and is a "safe" condition to leave the message
 507:C:/StellarisWare/driverlib\can.c ****     // object.  The same arb reg is used to program all the message objects.
 508:C:/StellarisWare/driverlib\can.c ****     //
 509:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_ARB |
 444              		.loc 1 509 0 is_stmt 1
 445 002a 7B68     		ldr	r3, [r7, #4]
 446 002c 03F12403 		add	r3, r3, #36
 447 0030 1846     		mov	r0, r3
 448 0032 4FF0B001 		mov	r1, #176
 449 0036 FFF7FEFF 		bl	CANRegWrite
 510:C:/StellarisWare/driverlib\can.c ****                 CAN_IF1CMSK_CONTROL);
 511:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1ARB2, 0);
 450              		.loc 1 511 0
 451 003a 7B68     		ldr	r3, [r7, #4]
 452 003c 03F13403 		add	r3, r3, #52
 453 0040 1846     		mov	r0, r3
 454 0042 4FF00001 		mov	r1, #0
 455 0046 FFF7FEFF 		bl	CANRegWrite
 512:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1MCTL, 0);
 456              		.loc 1 512 0
 457 004a 7B68     		ldr	r3, [r7, #4]
 458 004c 03F13803 		add	r3, r3, #56
 459 0050 1846     		mov	r0, r3
 460 0052 4FF00001 		mov	r1, #0
 461 0056 FFF7FEFF 		bl	CANRegWrite
 513:C:/StellarisWare/driverlib\can.c **** 
 514:C:/StellarisWare/driverlib\can.c ****     //
 515:C:/StellarisWare/driverlib\can.c ****     // Loop through to program all 32 message objects
 516:C:/StellarisWare/driverlib\can.c ****     //
 517:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 462              		.loc 1 517 0
 463 005a 4FF00103 		mov	r3, #1
 464 005e FB60     		str	r3, [r7, #12]
 465 0060 16E0     		b	.L25
 466              	.L31:
 518:C:/StellarisWare/driverlib\can.c ****     {
 519:C:/StellarisWare/driverlib\can.c ****         //
 520:C:/StellarisWare/driverlib\can.c ****         // Wait for busy bit to clear
 521:C:/StellarisWare/driverlib\can.c ****         //
 522:C:/StellarisWare/driverlib\can.c ****         while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 467              		.loc 1 522 0
 468 0062 00BF     		nop
 469              	.L26:
 470              		.loc 1 522 0 is_stmt 0 discriminator 1
 471 0064 7B68     		ldr	r3, [r7, #4]
 472 0066 03F12003 		add	r3, r3, #32
 473 006a 1846     		mov	r0, r3
 474 006c FFF7FEFF 		bl	CANRegRead
 475 0070 0346     		mov	r3, r0
 476 0072 03F40043 		and	r3, r3, #32768
 477 0076 002B     		cmp	r3, #0
 478 0078 F4D1     		bne	.L26
 523:C:/StellarisWare/driverlib\can.c ****         {
 524:C:/StellarisWare/driverlib\can.c ****         }
 525:C:/StellarisWare/driverlib\can.c **** 
 526:C:/StellarisWare/driverlib\can.c ****         //
 527:C:/StellarisWare/driverlib\can.c ****         // Initiate programming the message object
 528:C:/StellarisWare/driverlib\can.c ****         //
 529:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF1CRQ, ulMsg);
 479              		.loc 1 529 0 is_stmt 1
 480 007a 7B68     		ldr	r3, [r7, #4]
 481 007c 03F12003 		add	r3, r3, #32
 482 0080 1846     		mov	r0, r3
 483 0082 F968     		ldr	r1, [r7, #12]
 484 0084 FFF7FEFF 		bl	CANRegWrite
 517:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 485              		.loc 1 517 0
 486 0088 FB68     		ldr	r3, [r7, #12]
 487 008a 03F10103 		add	r3, r3, #1
 488 008e FB60     		str	r3, [r7, #12]
 489              	.L25:
 517:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 490              		.loc 1 517 0 is_stmt 0 discriminator 1
 491 0090 FB68     		ldr	r3, [r7, #12]
 492 0092 202B     		cmp	r3, #32
 493 0094 E5D9     		bls	.L31
 530:C:/StellarisWare/driverlib\can.c ****     }
 531:C:/StellarisWare/driverlib\can.c **** 
 532:C:/StellarisWare/driverlib\can.c ****     //
 533:C:/StellarisWare/driverlib\can.c ****     // Make sure that the interrupt and new data flags are updated for the
 534:C:/StellarisWare/driverlib\can.c ****     // message objects.
 535:C:/StellarisWare/driverlib\can.c ****     //
 536:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_NEWDAT |
 494              		.loc 1 536 0 is_stmt 1
 495 0096 7B68     		ldr	r3, [r7, #4]
 496 0098 03F12403 		add	r3, r3, #36
 497 009c 1846     		mov	r0, r3
 498 009e 4FF00C01 		mov	r1, #12
 499 00a2 FFF7FEFF 		bl	CANRegWrite
 537:C:/StellarisWare/driverlib\can.c ****                 CAN_IF1CMSK_CLRINTPND);
 538:C:/StellarisWare/driverlib\can.c **** 
 539:C:/StellarisWare/driverlib\can.c ****     //
 540:C:/StellarisWare/driverlib\can.c ****     // Loop through to program all 32 message objects
 541:C:/StellarisWare/driverlib\can.c ****     //
 542:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 500              		.loc 1 542 0
 501 00a6 4FF00103 		mov	r3, #1
 502 00aa FB60     		str	r3, [r7, #12]
 503 00ac 16E0     		b	.L28
 504              	.L32:
 543:C:/StellarisWare/driverlib\can.c ****     {
 544:C:/StellarisWare/driverlib\can.c ****         //
 545:C:/StellarisWare/driverlib\can.c ****         // Wait for busy bit to clear.
 546:C:/StellarisWare/driverlib\can.c ****         //
 547:C:/StellarisWare/driverlib\can.c ****         while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 505              		.loc 1 547 0
 506 00ae 00BF     		nop
 507              	.L29:
 508              		.loc 1 547 0 is_stmt 0 discriminator 1
 509 00b0 7B68     		ldr	r3, [r7, #4]
 510 00b2 03F12003 		add	r3, r3, #32
 511 00b6 1846     		mov	r0, r3
 512 00b8 FFF7FEFF 		bl	CANRegRead
 513 00bc 0346     		mov	r3, r0
 514 00be 03F40043 		and	r3, r3, #32768
 515 00c2 002B     		cmp	r3, #0
 516 00c4 F4D1     		bne	.L29
 548:C:/StellarisWare/driverlib\can.c ****         {
 549:C:/StellarisWare/driverlib\can.c ****         }
 550:C:/StellarisWare/driverlib\can.c **** 
 551:C:/StellarisWare/driverlib\can.c ****         //
 552:C:/StellarisWare/driverlib\can.c ****         // Initiate programming the message object
 553:C:/StellarisWare/driverlib\can.c ****         //
 554:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF1CRQ, ulMsg);
 517              		.loc 1 554 0 is_stmt 1
 518 00c6 7B68     		ldr	r3, [r7, #4]
 519 00c8 03F12003 		add	r3, r3, #32
 520 00cc 1846     		mov	r0, r3
 521 00ce F968     		ldr	r1, [r7, #12]
 522 00d0 FFF7FEFF 		bl	CANRegWrite
 542:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 523              		.loc 1 542 0
 524 00d4 FB68     		ldr	r3, [r7, #12]
 525 00d6 03F10103 		add	r3, r3, #1
 526 00da FB60     		str	r3, [r7, #12]
 527              	.L28:
 542:C:/StellarisWare/driverlib\can.c ****     for(ulMsg = 1; ulMsg <= 32; ulMsg++)
 528              		.loc 1 542 0 is_stmt 0 discriminator 1
 529 00dc FB68     		ldr	r3, [r7, #12]
 530 00de 202B     		cmp	r3, #32
 531 00e0 E5D9     		bls	.L32
 555:C:/StellarisWare/driverlib\can.c ****     }
 556:C:/StellarisWare/driverlib\can.c **** 
 557:C:/StellarisWare/driverlib\can.c ****     //
 558:C:/StellarisWare/driverlib\can.c ****     // Acknowledge any pending status interrupts.
 559:C:/StellarisWare/driverlib\can.c ****     //
 560:C:/StellarisWare/driverlib\can.c ****     CANRegRead(ulBase + CAN_O_STS);
 532              		.loc 1 560 0 is_stmt 1
 533 00e2 7B68     		ldr	r3, [r7, #4]
 534 00e4 03F10403 		add	r3, r3, #4
 535 00e8 1846     		mov	r0, r3
 536 00ea FFF7FEFF 		bl	CANRegRead
 561:C:/StellarisWare/driverlib\can.c **** }
 537              		.loc 1 561 0
 538 00ee 07F11007 		add	r7, r7, #16
 539 00f2 BD46     		mov	sp, r7
 540 00f4 80BD     		pop	{r7, pc}
 541              		.cfi_endproc
 542              	.LFE5:
 544 00f6 00BF     		.section	.text.CANEnable,"ax",%progbits
 545              		.align	2
 546              		.global	CANEnable
 547              		.thumb
 548              		.thumb_func
 550              	CANEnable:
 551              	.LFB6:
 562:C:/StellarisWare/driverlib\can.c **** 
 563:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 564:C:/StellarisWare/driverlib\can.c **** //
 565:C:/StellarisWare/driverlib\can.c **** //! Enables the CAN controller.
 566:C:/StellarisWare/driverlib\can.c **** //!
 567:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller to enable.
 568:C:/StellarisWare/driverlib\can.c **** //!
 569:C:/StellarisWare/driverlib\can.c **** //! Enables the CAN controller for message processing.  Once enabled, the
 570:C:/StellarisWare/driverlib\can.c **** //! controller automatically transmits any pending frames, and processes any
 571:C:/StellarisWare/driverlib\can.c **** //! received frames.  The controller can be stopped by calling CANDisable().
 572:C:/StellarisWare/driverlib\can.c **** //! Prior to calling CANEnable(), CANInit() should have been called to
 573:C:/StellarisWare/driverlib\can.c **** //! initialize the controller and the CAN bus clock should be configured by
 574:C:/StellarisWare/driverlib\can.c **** //! calling CANBitTimingSet().
 575:C:/StellarisWare/driverlib\can.c **** //!
 576:C:/StellarisWare/driverlib\can.c **** //! \return None.
 577:C:/StellarisWare/driverlib\can.c **** //
 578:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 579:C:/StellarisWare/driverlib\can.c **** void
 580:C:/StellarisWare/driverlib\can.c **** CANEnable(unsigned long ulBase)
 581:C:/StellarisWare/driverlib\can.c **** {
 552              		.loc 1 581 0
 553              		.cfi_startproc
 554              		@ args = 0, pretend = 0, frame = 8
 555              		@ frame_needed = 1, uses_anonymous_args = 0
 556 0000 80B5     		push	{r7, lr}
 557              	.LCFI18:
 558              		.cfi_def_cfa_offset 8
 559              		.cfi_offset 14, -4
 560              		.cfi_offset 7, -8
 561 0002 82B0     		sub	sp, sp, #8
 562              	.LCFI19:
 563              		.cfi_def_cfa_offset 16
 564 0004 00AF     		add	r7, sp, #0
 565              	.LCFI20:
 566              		.cfi_def_cfa_register 7
 567 0006 7860     		str	r0, [r7, #4]
 582:C:/StellarisWare/driverlib\can.c ****     //
 583:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 584:C:/StellarisWare/driverlib\can.c ****     //
 585:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 586:C:/StellarisWare/driverlib\can.c **** 
 587:C:/StellarisWare/driverlib\can.c ****     //
 588:C:/StellarisWare/driverlib\can.c ****     // Clear the init bit in the control register.
 589:C:/StellarisWare/driverlib\can.c ****     //
 590:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 591:C:/StellarisWare/driverlib\can.c ****                 CANRegRead(ulBase + CAN_O_CTL) & ~CAN_CTL_INIT);
 568              		.loc 1 591 0
 569 0008 7868     		ldr	r0, [r7, #4]
 570 000a FFF7FEFF 		bl	CANRegRead
 571 000e 0346     		mov	r3, r0
 590:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 572              		.loc 1 590 0
 573 0010 23F00103 		bic	r3, r3, #1
 574 0014 7868     		ldr	r0, [r7, #4]
 575 0016 1946     		mov	r1, r3
 576 0018 FFF7FEFF 		bl	CANRegWrite
 592:C:/StellarisWare/driverlib\can.c **** }
 577              		.loc 1 592 0
 578 001c 07F10807 		add	r7, r7, #8
 579 0020 BD46     		mov	sp, r7
 580 0022 80BD     		pop	{r7, pc}
 581              		.cfi_endproc
 582              	.LFE6:
 584              		.section	.text.CANDisable,"ax",%progbits
 585              		.align	2
 586              		.global	CANDisable
 587              		.thumb
 588              		.thumb_func
 590              	CANDisable:
 591              	.LFB7:
 593:C:/StellarisWare/driverlib\can.c **** 
 594:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 595:C:/StellarisWare/driverlib\can.c **** //
 596:C:/StellarisWare/driverlib\can.c **** //! Disables the CAN controller.
 597:C:/StellarisWare/driverlib\can.c **** //!
 598:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller to disable.
 599:C:/StellarisWare/driverlib\can.c **** //!
 600:C:/StellarisWare/driverlib\can.c **** //! Disables the CAN controller for message processing.  When disabled, the
 601:C:/StellarisWare/driverlib\can.c **** //! controller no longer automatically processes data on the CAN bus.  The
 602:C:/StellarisWare/driverlib\can.c **** //! controller can be restarted by calling CANEnable().  The state of the CAN
 603:C:/StellarisWare/driverlib\can.c **** //! controller and the message objects in the controller are left as they were
 604:C:/StellarisWare/driverlib\can.c **** //! before this call was made.
 605:C:/StellarisWare/driverlib\can.c **** //!
 606:C:/StellarisWare/driverlib\can.c **** //! \return None.
 607:C:/StellarisWare/driverlib\can.c **** //
 608:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 609:C:/StellarisWare/driverlib\can.c **** void
 610:C:/StellarisWare/driverlib\can.c **** CANDisable(unsigned long ulBase)
 611:C:/StellarisWare/driverlib\can.c **** {
 592              		.loc 1 611 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 8
 595              		@ frame_needed = 1, uses_anonymous_args = 0
 596 0000 80B5     		push	{r7, lr}
 597              	.LCFI21:
 598              		.cfi_def_cfa_offset 8
 599              		.cfi_offset 14, -4
 600              		.cfi_offset 7, -8
 601 0002 82B0     		sub	sp, sp, #8
 602              	.LCFI22:
 603              		.cfi_def_cfa_offset 16
 604 0004 00AF     		add	r7, sp, #0
 605              	.LCFI23:
 606              		.cfi_def_cfa_register 7
 607 0006 7860     		str	r0, [r7, #4]
 612:C:/StellarisWare/driverlib\can.c ****     //
 613:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 614:C:/StellarisWare/driverlib\can.c ****     //
 615:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 616:C:/StellarisWare/driverlib\can.c **** 
 617:C:/StellarisWare/driverlib\can.c ****     //
 618:C:/StellarisWare/driverlib\can.c ****     // Set the init bit in the control register.
 619:C:/StellarisWare/driverlib\can.c ****     //
 620:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 621:C:/StellarisWare/driverlib\can.c ****                 CANRegRead(ulBase + CAN_O_CTL) | CAN_CTL_INIT);
 608              		.loc 1 621 0
 609 0008 7868     		ldr	r0, [r7, #4]
 610 000a FFF7FEFF 		bl	CANRegRead
 611 000e 0346     		mov	r3, r0
 620:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 612              		.loc 1 620 0
 613 0010 43F00103 		orr	r3, r3, #1
 614 0014 7868     		ldr	r0, [r7, #4]
 615 0016 1946     		mov	r1, r3
 616 0018 FFF7FEFF 		bl	CANRegWrite
 622:C:/StellarisWare/driverlib\can.c **** }
 617              		.loc 1 622 0
 618 001c 07F10807 		add	r7, r7, #8
 619 0020 BD46     		mov	sp, r7
 620 0022 80BD     		pop	{r7, pc}
 621              		.cfi_endproc
 622              	.LFE7:
 624              		.section	.text.CANBitTimingGet,"ax",%progbits
 625              		.align	2
 626              		.global	CANBitTimingGet
 627              		.thumb
 628              		.thumb_func
 630              	CANBitTimingGet:
 631              	.LFB8:
 623:C:/StellarisWare/driverlib\can.c **** 
 624:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 625:C:/StellarisWare/driverlib\can.c **** //
 626:C:/StellarisWare/driverlib\can.c **** //! Reads the current settings for the CAN controller bit timing.
 627:C:/StellarisWare/driverlib\can.c **** //!
 628:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 629:C:/StellarisWare/driverlib\can.c **** //! \param pClkParms is a pointer to a structure to hold the timing parameters.
 630:C:/StellarisWare/driverlib\can.c **** //!
 631:C:/StellarisWare/driverlib\can.c **** //! This function reads the current configuration of the CAN controller bit
 632:C:/StellarisWare/driverlib\can.c **** //! clock timing and stores the resulting information in the structure
 633:C:/StellarisWare/driverlib\can.c **** //! supplied by the caller.  Refer to CANBitTimingSet() for the meaning of the
 634:C:/StellarisWare/driverlib\can.c **** //! values that are returned in the structure pointed to by \e pClkParms.
 635:C:/StellarisWare/driverlib\can.c **** //!
 636:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANGetBitTiming() API and performs the
 637:C:/StellarisWare/driverlib\can.c **** //! same actions.  A macro is provided in <tt>can.h</tt> to map the original
 638:C:/StellarisWare/driverlib\can.c **** //! API to this API.
 639:C:/StellarisWare/driverlib\can.c **** //!
 640:C:/StellarisWare/driverlib\can.c **** //! \return None.
 641:C:/StellarisWare/driverlib\can.c **** //
 642:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 643:C:/StellarisWare/driverlib\can.c **** void
 644:C:/StellarisWare/driverlib\can.c **** CANBitTimingGet(unsigned long ulBase, tCANBitClkParms *pClkParms)
 645:C:/StellarisWare/driverlib\can.c **** {
 632              		.loc 1 645 0
 633              		.cfi_startproc
 634              		@ args = 0, pretend = 0, frame = 16
 635              		@ frame_needed = 1, uses_anonymous_args = 0
 636 0000 90B5     		push	{r4, r7, lr}
 637              	.LCFI24:
 638              		.cfi_def_cfa_offset 12
 639              		.cfi_offset 14, -4
 640              		.cfi_offset 7, -8
 641              		.cfi_offset 4, -12
 642 0002 85B0     		sub	sp, sp, #20
 643              	.LCFI25:
 644              		.cfi_def_cfa_offset 32
 645 0004 00AF     		add	r7, sp, #0
 646              	.LCFI26:
 647              		.cfi_def_cfa_register 7
 648 0006 7860     		str	r0, [r7, #4]
 649 0008 3960     		str	r1, [r7, #0]
 646:C:/StellarisWare/driverlib\can.c ****     unsigned long ulBitReg;
 647:C:/StellarisWare/driverlib\can.c **** 
 648:C:/StellarisWare/driverlib\can.c ****     //
 649:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 650:C:/StellarisWare/driverlib\can.c ****     //
 651:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 652:C:/StellarisWare/driverlib\can.c ****     ASSERT(pClkParms != 0);
 653:C:/StellarisWare/driverlib\can.c **** 
 654:C:/StellarisWare/driverlib\can.c ****     //
 655:C:/StellarisWare/driverlib\can.c ****     // Read out all the bit timing values from the CAN controller registers.
 656:C:/StellarisWare/driverlib\can.c ****     //
 657:C:/StellarisWare/driverlib\can.c ****     ulBitReg = CANRegRead(ulBase + CAN_O_BIT);
 650              		.loc 1 657 0
 651 000a 7B68     		ldr	r3, [r7, #4]
 652 000c 03F10C03 		add	r3, r3, #12
 653 0010 1846     		mov	r0, r3
 654 0012 FFF7FEFF 		bl	CANRegRead
 655 0016 F860     		str	r0, [r7, #12]
 658:C:/StellarisWare/driverlib\can.c **** 
 659:C:/StellarisWare/driverlib\can.c ****     //
 660:C:/StellarisWare/driverlib\can.c ****     // Set the phase 2 segment.
 661:C:/StellarisWare/driverlib\can.c ****     //
 662:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulPhase2Seg =
 663:C:/StellarisWare/driverlib\can.c ****         ((ulBitReg & CAN_BIT_TSEG2_M) >> CAN_BIT_TSEG2_S) + 1;
 656              		.loc 1 663 0
 657 0018 FB68     		ldr	r3, [r7, #12]
 658 001a 03F4E043 		and	r3, r3, #28672
 659 001e 4FEA1333 		lsr	r3, r3, #12
 660 0022 03F10102 		add	r2, r3, #1
 662:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulPhase2Seg =
 661              		.loc 1 662 0
 662 0026 3B68     		ldr	r3, [r7, #0]
 663 0028 5A60     		str	r2, [r3, #4]
 664:C:/StellarisWare/driverlib\can.c **** 
 665:C:/StellarisWare/driverlib\can.c ****     //
 666:C:/StellarisWare/driverlib\can.c ****     // Set the phase 1 segment.
 667:C:/StellarisWare/driverlib\can.c ****     //
 668:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulSyncPropPhase1Seg =
 669:C:/StellarisWare/driverlib\can.c ****         ((ulBitReg & CAN_BIT_TSEG1_M) >> CAN_BIT_TSEG1_S) + 1;
 664              		.loc 1 669 0
 665 002a FB68     		ldr	r3, [r7, #12]
 666 002c 03F47063 		and	r3, r3, #3840
 667 0030 4FEA1323 		lsr	r3, r3, #8
 668 0034 03F10102 		add	r2, r3, #1
 668:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulSyncPropPhase1Seg =
 669              		.loc 1 668 0
 670 0038 3B68     		ldr	r3, [r7, #0]
 671 003a 1A60     		str	r2, [r3, #0]
 670:C:/StellarisWare/driverlib\can.c **** 
 671:C:/StellarisWare/driverlib\can.c ****     //
 672:C:/StellarisWare/driverlib\can.c ****     // Set the synchronous jump width.
 673:C:/StellarisWare/driverlib\can.c ****     //
 674:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulSJW = ((ulBitReg & CAN_BIT_SJW_M) >> CAN_BIT_SJW_S) + 1;
 672              		.loc 1 674 0
 673 003c FB68     		ldr	r3, [r7, #12]
 674 003e 03F0C003 		and	r3, r3, #192
 675 0042 4FEA9313 		lsr	r3, r3, #6
 676 0046 03F10102 		add	r2, r3, #1
 677 004a 3B68     		ldr	r3, [r7, #0]
 678 004c 9A60     		str	r2, [r3, #8]
 675:C:/StellarisWare/driverlib\can.c **** 
 676:C:/StellarisWare/driverlib\can.c ****     //
 677:C:/StellarisWare/driverlib\can.c ****     // Set the pre-divider for the CAN bus bit clock.
 678:C:/StellarisWare/driverlib\can.c ****     //
 679:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulQuantumPrescaler =
 680:C:/StellarisWare/driverlib\can.c ****         ((ulBitReg & CAN_BIT_BRP_M) |
 679              		.loc 1 680 0
 680 004e FB68     		ldr	r3, [r7, #12]
 681 0050 03F03F04 		and	r4, r3, #63
 681:C:/StellarisWare/driverlib\can.c ****          ((CANRegRead(ulBase + CAN_O_BRPE) & CAN_BRPE_BRPE_M) << 6)) + 1;
 682              		.loc 1 681 0
 683 0054 7B68     		ldr	r3, [r7, #4]
 684 0056 03F11803 		add	r3, r3, #24
 685 005a 1846     		mov	r0, r3
 686 005c FFF7FEFF 		bl	CANRegRead
 687 0060 0346     		mov	r3, r0
 688 0062 03F00F03 		and	r3, r3, #15
 689 0066 4FEA8313 		lsl	r3, r3, #6
 680:C:/StellarisWare/driverlib\can.c ****         ((ulBitReg & CAN_BIT_BRP_M) |
 690              		.loc 1 680 0
 691 006a 2343     		orrs	r3, r3, r4
 692              		.loc 1 681 0
 693 006c 03F10102 		add	r2, r3, #1
 679:C:/StellarisWare/driverlib\can.c ****     pClkParms->ulQuantumPrescaler =
 694              		.loc 1 679 0
 695 0070 3B68     		ldr	r3, [r7, #0]
 696 0072 DA60     		str	r2, [r3, #12]
 682:C:/StellarisWare/driverlib\can.c **** }
 697              		.loc 1 682 0
 698 0074 07F11407 		add	r7, r7, #20
 699 0078 BD46     		mov	sp, r7
 700 007a 90BD     		pop	{r4, r7, pc}
 701              		.cfi_endproc
 702              	.LFE8:
 704              		.section	.text.CANBitRateSet,"ax",%progbits
 705              		.align	2
 706              		.global	CANBitRateSet
 707              		.thumb
 708              		.thumb_func
 710              	CANBitRateSet:
 711              	.LFB9:
 683:C:/StellarisWare/driverlib\can.c **** 
 684:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 685:C:/StellarisWare/driverlib\can.c **** //
 686:C:/StellarisWare/driverlib\can.c **** //! Sets the CAN bit timing values to a nominal setting based on a desired
 687:C:/StellarisWare/driverlib\can.c **** //! bit rate.
 688:C:/StellarisWare/driverlib\can.c **** //!
 689:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 690:C:/StellarisWare/driverlib\can.c **** //! \param ulSourceClock is the system clock for the device in Hz.
 691:C:/StellarisWare/driverlib\can.c **** //! \param ulBitRate is the desired bit rate.
 692:C:/StellarisWare/driverlib\can.c **** //!
 693:C:/StellarisWare/driverlib\can.c **** //! This function sets the CAN bit timing for the bit rate passed in the
 694:C:/StellarisWare/driverlib\can.c **** //! \e ulBitRate parameter based on the \e ulSourceClock parameter.  Because the
 695:C:/StellarisWare/driverlib\can.c **** //! CAN clock is based off of the system clock, the calling function should pass
 696:C:/StellarisWare/driverlib\can.c **** //! in the source clock rate either by retrieving it from SysCtlClockGet() or
 697:C:/StellarisWare/driverlib\can.c **** //! using a specific value in Hz.  The CAN bit timing is calculated assuming a
 698:C:/StellarisWare/driverlib\can.c **** //! minimal amount of propagation delay, which works for most cases where
 699:C:/StellarisWare/driverlib\can.c **** //! the network length is short.  If tighter timing requirements or longer
 700:C:/StellarisWare/driverlib\can.c **** //! network lengths are needed, then the CANBitTimingSet() function is
 701:C:/StellarisWare/driverlib\can.c **** //! available for full customization of all of the CAN bit timing values.
 702:C:/StellarisWare/driverlib\can.c **** //! Because not all bit rates can be matched exactly, the bit rate is set to
 703:C:/StellarisWare/driverlib\can.c **** //! the value closest to the desired bit rate without being higher than the
 704:C:/StellarisWare/driverlib\can.c **** //! \e ulBitRate value.
 705:C:/StellarisWare/driverlib\can.c **** //!
 706:C:/StellarisWare/driverlib\can.c **** //! \note On some devices the source clock is fixed at 8MHz so the
 707:C:/StellarisWare/driverlib\can.c **** //! \e ulSourceClock should be set to 8000000.
 708:C:/StellarisWare/driverlib\can.c **** //!
 709:C:/StellarisWare/driverlib\can.c **** //! \return This function returns the bit rate that the CAN controller was
 710:C:/StellarisWare/driverlib\can.c **** //! configured to use or it returns 0 to indicate that the bit rate was not
 711:C:/StellarisWare/driverlib\can.c **** //! changed because the requested bit rate was not valid.
 712:C:/StellarisWare/driverlib\can.c **** //!
 713:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 714:C:/StellarisWare/driverlib\can.c **** unsigned long
 715:C:/StellarisWare/driverlib\can.c **** CANBitRateSet(unsigned long ulBase, unsigned long ulSourceClock,
 716:C:/StellarisWare/driverlib\can.c ****               unsigned long ulBitRate)
 717:C:/StellarisWare/driverlib\can.c **** {
 712              		.loc 1 717 0
 713              		.cfi_startproc
 714              		@ args = 0, pretend = 0, frame = 40
 715              		@ frame_needed = 1, uses_anonymous_args = 0
 716 0000 80B5     		push	{r7, lr}
 717              	.LCFI27:
 718              		.cfi_def_cfa_offset 8
 719              		.cfi_offset 14, -4
 720              		.cfi_offset 7, -8
 721 0002 8AB0     		sub	sp, sp, #40
 722              	.LCFI28:
 723              		.cfi_def_cfa_offset 48
 724 0004 00AF     		add	r7, sp, #0
 725              	.LCFI29:
 726              		.cfi_def_cfa_register 7
 727 0006 F860     		str	r0, [r7, #12]
 728 0008 B960     		str	r1, [r7, #8]
 729 000a 7A60     		str	r2, [r7, #4]
 718:C:/StellarisWare/driverlib\can.c ****     unsigned long ulDesiredRatio;
 719:C:/StellarisWare/driverlib\can.c ****     unsigned long ulCANBits;
 720:C:/StellarisWare/driverlib\can.c ****     unsigned long ulPreDivide;
 721:C:/StellarisWare/driverlib\can.c ****     unsigned long ulRegValue;
 722:C:/StellarisWare/driverlib\can.c ****     unsigned short usCANCTL;
 723:C:/StellarisWare/driverlib\can.c **** 
 724:C:/StellarisWare/driverlib\can.c ****     //
 725:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 726:C:/StellarisWare/driverlib\can.c ****     //
 727:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 728:C:/StellarisWare/driverlib\can.c ****     ASSERT(ulSourceClock != 0);
 729:C:/StellarisWare/driverlib\can.c ****     ASSERT(ulBitRate != 0);
 730:C:/StellarisWare/driverlib\can.c **** 
 731:C:/StellarisWare/driverlib\can.c ****     //
 732:C:/StellarisWare/driverlib\can.c ****     // Calculate the desired clock rate.
 733:C:/StellarisWare/driverlib\can.c ****     //
 734:C:/StellarisWare/driverlib\can.c ****     ulDesiredRatio = ulSourceClock / ulBitRate;
 730              		.loc 1 734 0
 731 000c BA68     		ldr	r2, [r7, #8]
 732 000e 7B68     		ldr	r3, [r7, #4]
 733 0010 B2FBF3F3 		udiv	r3, r2, r3
 734 0014 7B62     		str	r3, [r7, #36]
 735:C:/StellarisWare/driverlib\can.c **** 
 736:C:/StellarisWare/driverlib\can.c ****     //
 737:C:/StellarisWare/driverlib\can.c ****     // Make sure that the ratio of CAN bit rate to processor clock is not too
 738:C:/StellarisWare/driverlib\can.c ****     // small or too large.
 739:C:/StellarisWare/driverlib\can.c ****     //
 740:C:/StellarisWare/driverlib\can.c ****     ASSERT(ulDesiredRatio <= (CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR));
 741:C:/StellarisWare/driverlib\can.c ****     ASSERT(ulDesiredRatio >= (CAN_MIN_PRE_DIVISOR * CAN_MIN_BIT_DIVISOR));
 742:C:/StellarisWare/driverlib\can.c **** 
 743:C:/StellarisWare/driverlib\can.c ****     //
 744:C:/StellarisWare/driverlib\can.c ****     // Make sure that the Desired Ratio is not too large.  This enforces the
 745:C:/StellarisWare/driverlib\can.c ****     // requirement that the bit rate is larger than requested.
 746:C:/StellarisWare/driverlib\can.c ****     //
 747:C:/StellarisWare/driverlib\can.c ****     if((ulSourceClock / ulDesiredRatio) > ulBitRate)
 735              		.loc 1 747 0
 736 0016 BA68     		ldr	r2, [r7, #8]
 737 0018 7B6A     		ldr	r3, [r7, #36]
 738 001a B2FBF3F2 		udiv	r2, r2, r3
 739 001e 7B68     		ldr	r3, [r7, #4]
 740 0020 9A42     		cmp	r2, r3
 741 0022 60D9     		bls	.L38
 748:C:/StellarisWare/driverlib\can.c ****     {
 749:C:/StellarisWare/driverlib\can.c ****         ulDesiredRatio += 1;
 742              		.loc 1 749 0
 743 0024 7B6A     		ldr	r3, [r7, #36]
 744 0026 03F10103 		add	r3, r3, #1
 745 002a 7B62     		str	r3, [r7, #36]
 750:C:/StellarisWare/driverlib\can.c ****     }
 751:C:/StellarisWare/driverlib\can.c **** 
 752:C:/StellarisWare/driverlib\can.c ****     //
 753:C:/StellarisWare/driverlib\can.c ****     // Check all possible values to find a matching value.
 754:C:/StellarisWare/driverlib\can.c ****     //
 755:C:/StellarisWare/driverlib\can.c ****     while(ulDesiredRatio <= (CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR))
 746              		.loc 1 755 0
 747 002c 5BE0     		b	.L38
 748              	.L43:
 756:C:/StellarisWare/driverlib\can.c ****     {
 757:C:/StellarisWare/driverlib\can.c ****         //
 758:C:/StellarisWare/driverlib\can.c ****         // Loop through all possible CAN bit divisors.
 759:C:/StellarisWare/driverlib\can.c ****         //
 760:C:/StellarisWare/driverlib\can.c ****         for(ulCANBits = CAN_MAX_BIT_DIVISOR; ulCANBits >= CAN_MIN_BIT_DIVISOR;
 749              		.loc 1 760 0
 750 002e 4FF01303 		mov	r3, #19
 751 0032 3B62     		str	r3, [r7, #32]
 752 0034 50E0     		b	.L39
 753              	.L42:
 761:C:/StellarisWare/driverlib\can.c ****             ulCANBits--)
 762:C:/StellarisWare/driverlib\can.c ****         {
 763:C:/StellarisWare/driverlib\can.c ****             //
 764:C:/StellarisWare/driverlib\can.c ****             // For a given CAN bit divisor save the pre divisor.
 765:C:/StellarisWare/driverlib\can.c ****             //
 766:C:/StellarisWare/driverlib\can.c ****             ulPreDivide = ulDesiredRatio / ulCANBits;
 754              		.loc 1 766 0
 755 0036 7A6A     		ldr	r2, [r7, #36]
 756 0038 3B6A     		ldr	r3, [r7, #32]
 757 003a B2FBF3F3 		udiv	r3, r2, r3
 758 003e FB61     		str	r3, [r7, #28]
 767:C:/StellarisWare/driverlib\can.c **** 
 768:C:/StellarisWare/driverlib\can.c ****             //
 769:C:/StellarisWare/driverlib\can.c ****             // If the calculated divisors match the desired clock ratio then
 770:C:/StellarisWare/driverlib\can.c ****             // return these bit rate and set the CAN bit timing.
 771:C:/StellarisWare/driverlib\can.c ****             //
 772:C:/StellarisWare/driverlib\can.c ****             if((ulPreDivide * ulCANBits) == ulDesiredRatio)
 759              		.loc 1 772 0
 760 0040 FB69     		ldr	r3, [r7, #28]
 761 0042 3A6A     		ldr	r2, [r7, #32]
 762 0044 02FB03F2 		mul	r2, r2, r3
 763 0048 7B6A     		ldr	r3, [r7, #36]
 764 004a 9A42     		cmp	r2, r3
 765 004c 40D1     		bne	.L40
 773:C:/StellarisWare/driverlib\can.c ****             {
 774:C:/StellarisWare/driverlib\can.c ****                 //
 775:C:/StellarisWare/driverlib\can.c ****                 // Start building the bit timing value by adding the bit timing
 776:C:/StellarisWare/driverlib\can.c ****                 // in time quanta.
 777:C:/StellarisWare/driverlib\can.c ****                 //
 778:C:/StellarisWare/driverlib\can.c ****                 ulRegValue = g_usCANBitValues[ulCANBits - CAN_MIN_BIT_DIVISOR];
 766              		.loc 1 778 0
 767 004e 3B6A     		ldr	r3, [r7, #32]
 768 0050 A3F10402 		sub	r2, r3, #4
 769 0054 40F20003 		movw	r3, #:lower16:g_usCANBitValues
 770 0058 C0F20003 		movt	r3, #:upper16:g_usCANBitValues
 771 005c 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 772 0060 BB61     		str	r3, [r7, #24]
 779:C:/StellarisWare/driverlib\can.c **** 
 780:C:/StellarisWare/driverlib\can.c ****                 //
 781:C:/StellarisWare/driverlib\can.c ****                 // To set the bit timing register, the controller must be placed
 782:C:/StellarisWare/driverlib\can.c ****                 // in init mode (if not already), and also configuration change
 783:C:/StellarisWare/driverlib\can.c ****                 // bit enabled.  The state of the register should be saved
 784:C:/StellarisWare/driverlib\can.c ****                 // so it can be restored.
 785:C:/StellarisWare/driverlib\can.c ****                 //
 786:C:/StellarisWare/driverlib\can.c ****                 usCANCTL = CANRegRead(ulBase + CAN_O_CTL);
 773              		.loc 1 786 0
 774 0062 F868     		ldr	r0, [r7, #12]
 775 0064 FFF7FEFF 		bl	CANRegRead
 776 0068 0346     		mov	r3, r0
 777 006a FB82     		strh	r3, [r7, #22]	@ movhi
 787:C:/StellarisWare/driverlib\can.c ****                 CANRegWrite(ulBase + CAN_O_CTL,
 778              		.loc 1 787 0
 779 006c FB8A     		ldrh	r3, [r7, #22]	@ movhi
 780 006e 43F04103 		orr	r3, r3, #65
 781 0072 9BB2     		uxth	r3, r3
 782 0074 F868     		ldr	r0, [r7, #12]
 783 0076 1946     		mov	r1, r3
 784 0078 FFF7FEFF 		bl	CANRegWrite
 788:C:/StellarisWare/driverlib\can.c ****                             usCANCTL | CAN_CTL_INIT | CAN_CTL_CCE);
 789:C:/StellarisWare/driverlib\can.c **** 
 790:C:/StellarisWare/driverlib\can.c ****                 //
 791:C:/StellarisWare/driverlib\can.c ****                 // Now add in the pre-scalar on the bit rate.
 792:C:/StellarisWare/driverlib\can.c ****                 //
 793:C:/StellarisWare/driverlib\can.c ****                 ulRegValue |= ((ulPreDivide - 1) & CAN_BIT_BRP_M);
 785              		.loc 1 793 0
 786 007c FB69     		ldr	r3, [r7, #28]
 787 007e 03F1FF33 		add	r3, r3, #-1
 788 0082 03F03F03 		and	r3, r3, #63
 789 0086 BA69     		ldr	r2, [r7, #24]
 790 0088 1343     		orrs	r3, r3, r2
 791 008a BB61     		str	r3, [r7, #24]
 794:C:/StellarisWare/driverlib\can.c **** 
 795:C:/StellarisWare/driverlib\can.c ****                 //
 796:C:/StellarisWare/driverlib\can.c ****                 // Set the clock bits in the and the lower bits of the
 797:C:/StellarisWare/driverlib\can.c ****                 // pre-scalar.
 798:C:/StellarisWare/driverlib\can.c ****                 //
 799:C:/StellarisWare/driverlib\can.c ****                 CANRegWrite(ulBase + CAN_O_BIT, ulRegValue);
 792              		.loc 1 799 0
 793 008c FB68     		ldr	r3, [r7, #12]
 794 008e 03F10C03 		add	r3, r3, #12
 795 0092 1846     		mov	r0, r3
 796 0094 B969     		ldr	r1, [r7, #24]
 797 0096 FFF7FEFF 		bl	CANRegWrite
 800:C:/StellarisWare/driverlib\can.c **** 
 801:C:/StellarisWare/driverlib\can.c ****                 //
 802:C:/StellarisWare/driverlib\can.c ****                 // Set the divider upper bits in the extension register.
 803:C:/StellarisWare/driverlib\can.c ****                 //
 804:C:/StellarisWare/driverlib\can.c ****                 CANRegWrite(ulBase + CAN_O_BRPE,
 798              		.loc 1 804 0
 799 009a FB68     		ldr	r3, [r7, #12]
 800 009c 03F11802 		add	r2, r3, #24
 805:C:/StellarisWare/driverlib\can.c ****                             ((ulPreDivide - 1) >> 6) & CAN_BRPE_BRPE_M);
 801              		.loc 1 805 0
 802 00a0 FB69     		ldr	r3, [r7, #28]
 803 00a2 03F1FF33 		add	r3, r3, #-1
 804 00a6 4FEA9313 		lsr	r3, r3, #6
 804:C:/StellarisWare/driverlib\can.c ****                 CANRegWrite(ulBase + CAN_O_BRPE,
 805              		.loc 1 804 0
 806 00aa 03F00F03 		and	r3, r3, #15
 807 00ae 1046     		mov	r0, r2
 808 00b0 1946     		mov	r1, r3
 809 00b2 FFF7FEFF 		bl	CANRegWrite
 806:C:/StellarisWare/driverlib\can.c **** 
 807:C:/StellarisWare/driverlib\can.c ****                 //
 808:C:/StellarisWare/driverlib\can.c ****                 // Restore the saved CAN Control register.
 809:C:/StellarisWare/driverlib\can.c ****                 //
 810:C:/StellarisWare/driverlib\can.c ****                 CANRegWrite(ulBase + CAN_O_CTL, usCANCTL);
 810              		.loc 1 810 0
 811 00b6 FB8A     		ldrh	r3, [r7, #22]
 812 00b8 F868     		ldr	r0, [r7, #12]
 813 00ba 1946     		mov	r1, r3
 814 00bc FFF7FEFF 		bl	CANRegWrite
 811:C:/StellarisWare/driverlib\can.c **** 
 812:C:/StellarisWare/driverlib\can.c ****                 //
 813:C:/StellarisWare/driverlib\can.c ****                 // Return the computed bit rate.
 814:C:/StellarisWare/driverlib\can.c ****                 //
 815:C:/StellarisWare/driverlib\can.c ****                 return(ulSourceClock / ( ulPreDivide * ulCANBits));
 815              		.loc 1 815 0
 816 00c0 FB69     		ldr	r3, [r7, #28]
 817 00c2 3A6A     		ldr	r2, [r7, #32]
 818 00c4 02FB03F3 		mul	r3, r2, r3
 819 00c8 BA68     		ldr	r2, [r7, #8]
 820 00ca B2FBF3F3 		udiv	r3, r2, r3
 821 00ce 10E0     		b	.L41
 822              	.L40:
 761:C:/StellarisWare/driverlib\can.c ****             ulCANBits--)
 823              		.loc 1 761 0
 824 00d0 3B6A     		ldr	r3, [r7, #32]
 825 00d2 03F1FF33 		add	r3, r3, #-1
 826 00d6 3B62     		str	r3, [r7, #32]
 827              	.L39:
 760:C:/StellarisWare/driverlib\can.c ****         for(ulCANBits = CAN_MAX_BIT_DIVISOR; ulCANBits >= CAN_MIN_BIT_DIVISOR;
 828              		.loc 1 760 0 discriminator 1
 829 00d8 3B6A     		ldr	r3, [r7, #32]
 830 00da 032B     		cmp	r3, #3
 831 00dc ABD8     		bhi	.L42
 816:C:/StellarisWare/driverlib\can.c ****             }
 817:C:/StellarisWare/driverlib\can.c ****         }
 818:C:/StellarisWare/driverlib\can.c **** 
 819:C:/StellarisWare/driverlib\can.c ****         //
 820:C:/StellarisWare/driverlib\can.c ****         // Move the divisor up one and look again.  Only in rare cases are
 821:C:/StellarisWare/driverlib\can.c ****         // more than 2 loops required to find the value.
 822:C:/StellarisWare/driverlib\can.c ****         //
 823:C:/StellarisWare/driverlib\can.c ****         ulDesiredRatio++;
 832              		.loc 1 823 0
 833 00de 7B6A     		ldr	r3, [r7, #36]
 834 00e0 03F10103 		add	r3, r3, #1
 835 00e4 7B62     		str	r3, [r7, #36]
 836              	.L38:
 755:C:/StellarisWare/driverlib\can.c ****     while(ulDesiredRatio <= (CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR))
 837              		.loc 1 755 0 discriminator 1
 838 00e6 7B6A     		ldr	r3, [r7, #36]
 839 00e8 B3F5984F 		cmp	r3, #19456
 840 00ec 9FD9     		bls	.L43
 824:C:/StellarisWare/driverlib\can.c ****     }
 825:C:/StellarisWare/driverlib\can.c **** 
 826:C:/StellarisWare/driverlib\can.c ****     //
 827:C:/StellarisWare/driverlib\can.c ****     // A valid combination could not be found, so return 0 to indicate that the
 828:C:/StellarisWare/driverlib\can.c ****     // bit rate was not changed.
 829:C:/StellarisWare/driverlib\can.c ****     //
 830:C:/StellarisWare/driverlib\can.c ****     return(0);
 841              		.loc 1 830 0
 842 00ee 4FF00003 		mov	r3, #0
 843              	.L41:
 831:C:/StellarisWare/driverlib\can.c **** }
 844              		.loc 1 831 0
 845 00f2 1846     		mov	r0, r3
 846 00f4 07F12807 		add	r7, r7, #40
 847 00f8 BD46     		mov	sp, r7
 848 00fa 80BD     		pop	{r7, pc}
 849              		.cfi_endproc
 850              	.LFE9:
 852              		.section	.text.CANBitTimingSet,"ax",%progbits
 853              		.align	2
 854              		.global	CANBitTimingSet
 855              		.thumb
 856              		.thumb_func
 858              	CANBitTimingSet:
 859              	.LFB10:
 832:C:/StellarisWare/driverlib\can.c **** 
 833:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 834:C:/StellarisWare/driverlib\can.c **** //
 835:C:/StellarisWare/driverlib\can.c **** //! Configures the CAN controller bit timing.
 836:C:/StellarisWare/driverlib\can.c **** //!
 837:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 838:C:/StellarisWare/driverlib\can.c **** //! \param pClkParms points to the structure with the clock parameters.
 839:C:/StellarisWare/driverlib\can.c **** //!
 840:C:/StellarisWare/driverlib\can.c **** //! Configures the various timing parameters for the CAN bus bit timing:
 841:C:/StellarisWare/driverlib\can.c **** //! Propagation segment, Phase Buffer 1 segment, Phase Buffer 2 segment, and
 842:C:/StellarisWare/driverlib\can.c **** //! the Synchronization Jump Width.  The values for Propagation and Phase
 843:C:/StellarisWare/driverlib\can.c **** //! Buffer 1 segments are derived from the combination
 844:C:/StellarisWare/driverlib\can.c **** //! \e pClkParms->ulSyncPropPhase1Seg parameter.  Phase Buffer 2 is determined
 845:C:/StellarisWare/driverlib\can.c **** //! from the \e pClkParms->ulPhase2Seg parameter.  These two parameters, along
 846:C:/StellarisWare/driverlib\can.c **** //! with \e pClkParms->ulSJW are based in units of bit time quanta.  The actual
 847:C:/StellarisWare/driverlib\can.c **** //! quantum time is determined by the \e pClkParms->ulQuantumPrescaler value,
 848:C:/StellarisWare/driverlib\can.c **** //! which specifies the divisor for the CAN module clock.
 849:C:/StellarisWare/driverlib\can.c **** //!
 850:C:/StellarisWare/driverlib\can.c **** //! The total bit time, in quanta, is the sum of the two Seg parameters,
 851:C:/StellarisWare/driverlib\can.c **** //! as follows:
 852:C:/StellarisWare/driverlib\can.c **** //!
 853:C:/StellarisWare/driverlib\can.c **** //! bit_time_q = ulSyncPropPhase1Seg + ulPhase2Seg + 1
 854:C:/StellarisWare/driverlib\can.c **** //!
 855:C:/StellarisWare/driverlib\can.c **** //! Note that the Sync_Seg is always one quantum in duration, and is added
 856:C:/StellarisWare/driverlib\can.c **** //! to derive the correct duration of Prop_Seg and Phase1_Seg.
 857:C:/StellarisWare/driverlib\can.c **** //!
 858:C:/StellarisWare/driverlib\can.c **** //! The equation to determine the actual bit rate is as follows:
 859:C:/StellarisWare/driverlib\can.c **** //!
 860:C:/StellarisWare/driverlib\can.c **** //! CAN Clock /
 861:C:/StellarisWare/driverlib\can.c **** //! ((\e ulSyncPropPhase1Seg + \e ulPhase2Seg + 1) * (\e ulQuantumPrescaler))
 862:C:/StellarisWare/driverlib\can.c **** //!
 863:C:/StellarisWare/driverlib\can.c **** //! Thus with \e ulSyncPropPhase1Seg = 4, \e ulPhase2Seg = 1,
 864:C:/StellarisWare/driverlib\can.c **** //! \e ulQuantumPrescaler = 2 and an 8 MHz CAN clock, the bit rate is
 865:C:/StellarisWare/driverlib\can.c **** //! (8 MHz) / ((5 + 2 + 1) * 2) or 500 Kbit/sec.
 866:C:/StellarisWare/driverlib\can.c **** //!
 867:C:/StellarisWare/driverlib\can.c **** //! This function replaces the original CANSetBitTiming() API and performs the
 868:C:/StellarisWare/driverlib\can.c **** //! same actions.  A macro is provided in <tt>can.h</tt> to map the original
 869:C:/StellarisWare/driverlib\can.c **** //! API to this API.
 870:C:/StellarisWare/driverlib\can.c **** //!
 871:C:/StellarisWare/driverlib\can.c **** //! \return None.
 872:C:/StellarisWare/driverlib\can.c **** //
 873:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 874:C:/StellarisWare/driverlib\can.c **** void
 875:C:/StellarisWare/driverlib\can.c **** CANBitTimingSet(unsigned long ulBase, tCANBitClkParms *pClkParms)
 876:C:/StellarisWare/driverlib\can.c **** {
 860              		.loc 1 876 0
 861              		.cfi_startproc
 862              		@ args = 0, pretend = 0, frame = 16
 863              		@ frame_needed = 1, uses_anonymous_args = 0
 864 0000 80B5     		push	{r7, lr}
 865              	.LCFI30:
 866              		.cfi_def_cfa_offset 8
 867              		.cfi_offset 14, -4
 868              		.cfi_offset 7, -8
 869 0002 84B0     		sub	sp, sp, #16
 870              	.LCFI31:
 871              		.cfi_def_cfa_offset 24
 872 0004 00AF     		add	r7, sp, #0
 873              	.LCFI32:
 874              		.cfi_def_cfa_register 7
 875 0006 7860     		str	r0, [r7, #4]
 876 0008 3960     		str	r1, [r7, #0]
 877:C:/StellarisWare/driverlib\can.c ****     unsigned long ulBitReg, ulSavedInit;
 878:C:/StellarisWare/driverlib\can.c **** 
 879:C:/StellarisWare/driverlib\can.c ****     //
 880:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 881:C:/StellarisWare/driverlib\can.c ****     //
 882:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 883:C:/StellarisWare/driverlib\can.c ****     ASSERT(pClkParms != 0);
 884:C:/StellarisWare/driverlib\can.c **** 
 885:C:/StellarisWare/driverlib\can.c ****     //
 886:C:/StellarisWare/driverlib\can.c ****     // The phase 1 segment must be in the range from 2 to 16.
 887:C:/StellarisWare/driverlib\can.c ****     //
 888:C:/StellarisWare/driverlib\can.c ****     ASSERT((pClkParms->ulSyncPropPhase1Seg >= 2) &&
 889:C:/StellarisWare/driverlib\can.c ****            (pClkParms->ulSyncPropPhase1Seg <= 16));
 890:C:/StellarisWare/driverlib\can.c **** 
 891:C:/StellarisWare/driverlib\can.c ****     //
 892:C:/StellarisWare/driverlib\can.c ****     // The phase 2 segment must be in the range from 1 to 8.
 893:C:/StellarisWare/driverlib\can.c ****     //
 894:C:/StellarisWare/driverlib\can.c ****     ASSERT((pClkParms->ulPhase2Seg >= 1) && (pClkParms->ulPhase2Seg <= 8));
 895:C:/StellarisWare/driverlib\can.c **** 
 896:C:/StellarisWare/driverlib\can.c ****     //
 897:C:/StellarisWare/driverlib\can.c ****     // The synchronous jump windows must be in the range from 1 to 4.
 898:C:/StellarisWare/driverlib\can.c ****     //
 899:C:/StellarisWare/driverlib\can.c ****     ASSERT((pClkParms->ulSJW >= 1) && (pClkParms->ulSJW <= 4));
 900:C:/StellarisWare/driverlib\can.c **** 
 901:C:/StellarisWare/driverlib\can.c ****     //
 902:C:/StellarisWare/driverlib\can.c ****     // The CAN clock pre-divider must be in the range from 1 to 1024.
 903:C:/StellarisWare/driverlib\can.c ****     //
 904:C:/StellarisWare/driverlib\can.c ****     ASSERT((pClkParms->ulQuantumPrescaler <= 1024) &&
 905:C:/StellarisWare/driverlib\can.c ****            (pClkParms->ulQuantumPrescaler >= 1));
 906:C:/StellarisWare/driverlib\can.c **** 
 907:C:/StellarisWare/driverlib\can.c ****     //
 908:C:/StellarisWare/driverlib\can.c ****     // To set the bit timing register, the controller must be placed in init
 909:C:/StellarisWare/driverlib\can.c ****     // mode (if not already), and also configuration change bit enabled.  State
 910:C:/StellarisWare/driverlib\can.c ****     // of the init bit should be saved so it can be restored at the end.
 911:C:/StellarisWare/driverlib\can.c ****     //
 912:C:/StellarisWare/driverlib\can.c ****     ulSavedInit = CANRegRead(ulBase + CAN_O_CTL);
 877              		.loc 1 912 0
 878 000a 7868     		ldr	r0, [r7, #4]
 879 000c FFF7FEFF 		bl	CANRegRead
 880 0010 F860     		str	r0, [r7, #12]
 913:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL, ulSavedInit | CAN_CTL_INIT | CAN_CTL_CCE);
 881              		.loc 1 913 0
 882 0012 FB68     		ldr	r3, [r7, #12]
 883 0014 43F04103 		orr	r3, r3, #65
 884 0018 7868     		ldr	r0, [r7, #4]
 885 001a 1946     		mov	r1, r3
 886 001c FFF7FEFF 		bl	CANRegWrite
 914:C:/StellarisWare/driverlib\can.c **** 
 915:C:/StellarisWare/driverlib\can.c ****     //
 916:C:/StellarisWare/driverlib\can.c ****     // Set the bit fields of the bit timing register according to the parms.
 917:C:/StellarisWare/driverlib\can.c ****     //
 918:C:/StellarisWare/driverlib\can.c ****     ulBitReg = (((pClkParms->ulPhase2Seg - 1) << CAN_BIT_TSEG2_S) &
 887              		.loc 1 918 0
 888 0020 3B68     		ldr	r3, [r7, #0]
 889 0022 5B68     		ldr	r3, [r3, #4]
 890 0024 03F1FF33 		add	r3, r3, #-1
 891 0028 4FEA0333 		lsl	r3, r3, #12
 892 002c 03F4E043 		and	r3, r3, #28672
 893 0030 BB60     		str	r3, [r7, #8]
 919:C:/StellarisWare/driverlib\can.c ****                 CAN_BIT_TSEG2_M);
 920:C:/StellarisWare/driverlib\can.c ****     ulBitReg |= (((pClkParms->ulSyncPropPhase1Seg - 1) << CAN_BIT_TSEG1_S) &
 894              		.loc 1 920 0
 895 0032 3B68     		ldr	r3, [r7, #0]
 896 0034 1B68     		ldr	r3, [r3, #0]
 897 0036 03F1FF33 		add	r3, r3, #-1
 898 003a 4FEA0323 		lsl	r3, r3, #8
 899 003e 03F47063 		and	r3, r3, #3840
 900 0042 BA68     		ldr	r2, [r7, #8]
 901 0044 1343     		orrs	r3, r3, r2
 902 0046 BB60     		str	r3, [r7, #8]
 921:C:/StellarisWare/driverlib\can.c ****                  CAN_BIT_TSEG1_M);
 922:C:/StellarisWare/driverlib\can.c ****     ulBitReg |= ((pClkParms->ulSJW - 1) << CAN_BIT_SJW_S) & CAN_BIT_SJW_M;
 903              		.loc 1 922 0
 904 0048 3B68     		ldr	r3, [r7, #0]
 905 004a 9B68     		ldr	r3, [r3, #8]
 906 004c 03F1FF33 		add	r3, r3, #-1
 907 0050 4FEA8313 		lsl	r3, r3, #6
 908 0054 DBB2     		uxtb	r3, r3
 909 0056 BA68     		ldr	r2, [r7, #8]
 910 0058 1343     		orrs	r3, r3, r2
 911 005a BB60     		str	r3, [r7, #8]
 923:C:/StellarisWare/driverlib\can.c ****     ulBitReg |= (pClkParms->ulQuantumPrescaler - 1) & CAN_BIT_BRP_M;
 912              		.loc 1 923 0
 913 005c 3B68     		ldr	r3, [r7, #0]
 914 005e DB68     		ldr	r3, [r3, #12]
 915 0060 03F1FF33 		add	r3, r3, #-1
 916 0064 03F03F03 		and	r3, r3, #63
 917 0068 BA68     		ldr	r2, [r7, #8]
 918 006a 1343     		orrs	r3, r3, r2
 919 006c BB60     		str	r3, [r7, #8]
 924:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_BIT, ulBitReg);
 920              		.loc 1 924 0
 921 006e 7B68     		ldr	r3, [r7, #4]
 922 0070 03F10C03 		add	r3, r3, #12
 923 0074 1846     		mov	r0, r3
 924 0076 B968     		ldr	r1, [r7, #8]
 925 0078 FFF7FEFF 		bl	CANRegWrite
 925:C:/StellarisWare/driverlib\can.c **** 
 926:C:/StellarisWare/driverlib\can.c ****     //
 927:C:/StellarisWare/driverlib\can.c ****     // Set the divider upper bits in the extension register.
 928:C:/StellarisWare/driverlib\can.c ****     //
 929:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_BRPE,
 926              		.loc 1 929 0
 927 007c 7B68     		ldr	r3, [r7, #4]
 928 007e 03F11802 		add	r2, r3, #24
 930:C:/StellarisWare/driverlib\can.c ****                 ((pClkParms->ulQuantumPrescaler - 1) >> 6) & CAN_BRPE_BRPE_M);
 929              		.loc 1 930 0
 930 0082 3B68     		ldr	r3, [r7, #0]
 931 0084 DB68     		ldr	r3, [r3, #12]
 932 0086 03F1FF33 		add	r3, r3, #-1
 933 008a 4FEA9313 		lsr	r3, r3, #6
 929:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_BRPE,
 934              		.loc 1 929 0
 935 008e 03F00F03 		and	r3, r3, #15
 936 0092 1046     		mov	r0, r2
 937 0094 1946     		mov	r1, r3
 938 0096 FFF7FEFF 		bl	CANRegWrite
 931:C:/StellarisWare/driverlib\can.c **** 
 932:C:/StellarisWare/driverlib\can.c ****     //
 933:C:/StellarisWare/driverlib\can.c ****     // Clear the config change bit, and restore the init bit.
 934:C:/StellarisWare/driverlib\can.c ****     //
 935:C:/StellarisWare/driverlib\can.c ****     ulSavedInit &= ~CAN_CTL_CCE;
 939              		.loc 1 935 0
 940 009a FB68     		ldr	r3, [r7, #12]
 941 009c 23F04003 		bic	r3, r3, #64
 942 00a0 FB60     		str	r3, [r7, #12]
 936:C:/StellarisWare/driverlib\can.c **** 
 937:C:/StellarisWare/driverlib\can.c ****     //
 938:C:/StellarisWare/driverlib\can.c ****     // If Init was not set before, then clear it.
 939:C:/StellarisWare/driverlib\can.c ****     //
 940:C:/StellarisWare/driverlib\can.c ****     if(ulSavedInit & CAN_CTL_INIT)
 943              		.loc 1 940 0
 944 00a2 FB68     		ldr	r3, [r7, #12]
 945 00a4 03F00103 		and	r3, r3, #1
 946 00a8 DBB2     		uxtb	r3, r3
 947 00aa 002B     		cmp	r3, #0
 948 00ac 03D0     		beq	.L45
 941:C:/StellarisWare/driverlib\can.c ****     {
 942:C:/StellarisWare/driverlib\can.c ****         ulSavedInit &= ~CAN_CTL_INIT;
 949              		.loc 1 942 0
 950 00ae FB68     		ldr	r3, [r7, #12]
 951 00b0 23F00103 		bic	r3, r3, #1
 952 00b4 FB60     		str	r3, [r7, #12]
 953              	.L45:
 943:C:/StellarisWare/driverlib\can.c ****     }
 944:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL, ulSavedInit);
 954              		.loc 1 944 0
 955 00b6 7868     		ldr	r0, [r7, #4]
 956 00b8 F968     		ldr	r1, [r7, #12]
 957 00ba FFF7FEFF 		bl	CANRegWrite
 945:C:/StellarisWare/driverlib\can.c **** }
 958              		.loc 1 945 0
 959 00be 07F11007 		add	r7, r7, #16
 960 00c2 BD46     		mov	sp, r7
 961 00c4 80BD     		pop	{r7, pc}
 962              		.cfi_endproc
 963              	.LFE10:
 965 00c6 00BF     		.section	.text.CANIntRegister,"ax",%progbits
 966              		.align	2
 967              		.global	CANIntRegister
 968              		.thumb
 969              		.thumb_func
 971              	CANIntRegister:
 972              	.LFB11:
 946:C:/StellarisWare/driverlib\can.c **** 
 947:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 948:C:/StellarisWare/driverlib\can.c **** //
 949:C:/StellarisWare/driverlib\can.c **** //! Registers an interrupt handler for the CAN controller.
 950:C:/StellarisWare/driverlib\can.c **** //!
 951:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
 952:C:/StellarisWare/driverlib\can.c **** //! \param pfnHandler is a pointer to the function to be called when the
 953:C:/StellarisWare/driverlib\can.c **** //! enabled CAN interrupts occur.
 954:C:/StellarisWare/driverlib\can.c **** //!
 955:C:/StellarisWare/driverlib\can.c **** //! This function registers the interrupt handler in the interrupt vector
 956:C:/StellarisWare/driverlib\can.c **** //! table, and enables CAN interrupts on the interrupt controller; specific CAN
 957:C:/StellarisWare/driverlib\can.c **** //! interrupt sources must be enabled using CANIntEnable().  The interrupt
 958:C:/StellarisWare/driverlib\can.c **** //! handler being registered must clear the source of the interrupt using
 959:C:/StellarisWare/driverlib\can.c **** //! CANIntClear().
 960:C:/StellarisWare/driverlib\can.c **** //!
 961:C:/StellarisWare/driverlib\can.c **** //! If the application is using a static interrupt vector table stored in
 962:C:/StellarisWare/driverlib\can.c **** //! flash, then it is not necessary to register the interrupt handler this way.
 963:C:/StellarisWare/driverlib\can.c **** //! Instead, IntEnable() should be used to enable CAN interrupts on the
 964:C:/StellarisWare/driverlib\can.c **** //! interrupt controller.
 965:C:/StellarisWare/driverlib\can.c **** //!
 966:C:/StellarisWare/driverlib\can.c **** //! \sa IntRegister() for important information about registering interrupt
 967:C:/StellarisWare/driverlib\can.c **** //! handlers.
 968:C:/StellarisWare/driverlib\can.c **** //!
 969:C:/StellarisWare/driverlib\can.c **** //! \return None.
 970:C:/StellarisWare/driverlib\can.c **** //
 971:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 972:C:/StellarisWare/driverlib\can.c **** void
 973:C:/StellarisWare/driverlib\can.c **** CANIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
 974:C:/StellarisWare/driverlib\can.c **** {
 973              		.loc 1 974 0
 974              		.cfi_startproc
 975              		@ args = 0, pretend = 0, frame = 16
 976              		@ frame_needed = 1, uses_anonymous_args = 0
 977 0000 80B5     		push	{r7, lr}
 978              	.LCFI33:
 979              		.cfi_def_cfa_offset 8
 980              		.cfi_offset 14, -4
 981              		.cfi_offset 7, -8
 982 0002 84B0     		sub	sp, sp, #16
 983              	.LCFI34:
 984              		.cfi_def_cfa_offset 24
 985 0004 00AF     		add	r7, sp, #0
 986              	.LCFI35:
 987              		.cfi_def_cfa_register 7
 988 0006 7860     		str	r0, [r7, #4]
 989 0008 3960     		str	r1, [r7, #0]
 975:C:/StellarisWare/driverlib\can.c ****     unsigned long ulIntNumber;
 976:C:/StellarisWare/driverlib\can.c **** 
 977:C:/StellarisWare/driverlib\can.c ****     //
 978:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
 979:C:/StellarisWare/driverlib\can.c ****     //
 980:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
 981:C:/StellarisWare/driverlib\can.c **** 
 982:C:/StellarisWare/driverlib\can.c ****     //
 983:C:/StellarisWare/driverlib\can.c ****     // Get the actual interrupt number for this CAN controller.
 984:C:/StellarisWare/driverlib\can.c ****     //
 985:C:/StellarisWare/driverlib\can.c ****     ulIntNumber = CANIntNumberGet(ulBase);
 990              		.loc 1 985 0
 991 000a 7868     		ldr	r0, [r7, #4]
 992 000c FFF7FEFF 		bl	CANIntNumberGet
 993 0010 0346     		mov	r3, r0
 994 0012 FB60     		str	r3, [r7, #12]
 986:C:/StellarisWare/driverlib\can.c **** 
 987:C:/StellarisWare/driverlib\can.c ****     //
 988:C:/StellarisWare/driverlib\can.c ****     // Register the interrupt handler.
 989:C:/StellarisWare/driverlib\can.c ****     //
 990:C:/StellarisWare/driverlib\can.c ****     IntRegister(ulIntNumber, pfnHandler);
 995              		.loc 1 990 0
 996 0014 F868     		ldr	r0, [r7, #12]
 997 0016 3968     		ldr	r1, [r7, #0]
 998 0018 FFF7FEFF 		bl	IntRegister
 991:C:/StellarisWare/driverlib\can.c **** 
 992:C:/StellarisWare/driverlib\can.c ****     //
 993:C:/StellarisWare/driverlib\can.c ****     // Enable the Ethernet interrupt.
 994:C:/StellarisWare/driverlib\can.c ****     //
 995:C:/StellarisWare/driverlib\can.c ****     IntEnable(ulIntNumber);
 999              		.loc 1 995 0
 1000 001c F868     		ldr	r0, [r7, #12]
 1001 001e FFF7FEFF 		bl	IntEnable
 996:C:/StellarisWare/driverlib\can.c **** }
 1002              		.loc 1 996 0
 1003 0022 07F11007 		add	r7, r7, #16
 1004 0026 BD46     		mov	sp, r7
 1005 0028 80BD     		pop	{r7, pc}
 1006              		.cfi_endproc
 1007              	.LFE11:
 1009 002a 00BF     		.section	.text.CANIntUnregister,"ax",%progbits
 1010              		.align	2
 1011              		.global	CANIntUnregister
 1012              		.thumb
 1013              		.thumb_func
 1015              	CANIntUnregister:
 1016              	.LFB12:
 997:C:/StellarisWare/driverlib\can.c **** 
 998:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
 999:C:/StellarisWare/driverlib\can.c **** //
1000:C:/StellarisWare/driverlib\can.c **** //! Unregisters an interrupt handler for the CAN controller.
1001:C:/StellarisWare/driverlib\can.c **** //!
1002:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the controller.
1003:C:/StellarisWare/driverlib\can.c **** //!
1004:C:/StellarisWare/driverlib\can.c **** //! This function unregisters the previously registered interrupt handler and
1005:C:/StellarisWare/driverlib\can.c **** //! disables the interrupt in the interrupt controller.
1006:C:/StellarisWare/driverlib\can.c **** //!
1007:C:/StellarisWare/driverlib\can.c **** //! \sa IntRegister() for important information about registering interrupt
1008:C:/StellarisWare/driverlib\can.c **** //! handlers.
1009:C:/StellarisWare/driverlib\can.c **** //!
1010:C:/StellarisWare/driverlib\can.c **** //! \return None.
1011:C:/StellarisWare/driverlib\can.c **** //
1012:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1013:C:/StellarisWare/driverlib\can.c **** void
1014:C:/StellarisWare/driverlib\can.c **** CANIntUnregister(unsigned long ulBase)
1015:C:/StellarisWare/driverlib\can.c **** {
 1017              		.loc 1 1015 0
 1018              		.cfi_startproc
 1019              		@ args = 0, pretend = 0, frame = 16
 1020              		@ frame_needed = 1, uses_anonymous_args = 0
 1021 0000 80B5     		push	{r7, lr}
 1022              	.LCFI36:
 1023              		.cfi_def_cfa_offset 8
 1024              		.cfi_offset 14, -4
 1025              		.cfi_offset 7, -8
 1026 0002 84B0     		sub	sp, sp, #16
 1027              	.LCFI37:
 1028              		.cfi_def_cfa_offset 24
 1029 0004 00AF     		add	r7, sp, #0
 1030              	.LCFI38:
 1031              		.cfi_def_cfa_register 7
 1032 0006 7860     		str	r0, [r7, #4]
1016:C:/StellarisWare/driverlib\can.c ****     unsigned long ulIntNumber;
1017:C:/StellarisWare/driverlib\can.c **** 
1018:C:/StellarisWare/driverlib\can.c ****     //
1019:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1020:C:/StellarisWare/driverlib\can.c ****     //
1021:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1022:C:/StellarisWare/driverlib\can.c **** 
1023:C:/StellarisWare/driverlib\can.c ****     //
1024:C:/StellarisWare/driverlib\can.c ****     // Get the actual interrupt number for this CAN controller.
1025:C:/StellarisWare/driverlib\can.c ****     //
1026:C:/StellarisWare/driverlib\can.c ****     ulIntNumber = CANIntNumberGet(ulBase);
 1033              		.loc 1 1026 0
 1034 0008 7868     		ldr	r0, [r7, #4]
 1035 000a FFF7FEFF 		bl	CANIntNumberGet
 1036 000e 0346     		mov	r3, r0
 1037 0010 FB60     		str	r3, [r7, #12]
1027:C:/StellarisWare/driverlib\can.c **** 
1028:C:/StellarisWare/driverlib\can.c ****     //
1029:C:/StellarisWare/driverlib\can.c ****     // Disable the CAN interrupt.
1030:C:/StellarisWare/driverlib\can.c ****     //
1031:C:/StellarisWare/driverlib\can.c ****     IntDisable(ulIntNumber);
 1038              		.loc 1 1031 0
 1039 0012 F868     		ldr	r0, [r7, #12]
 1040 0014 FFF7FEFF 		bl	IntDisable
1032:C:/StellarisWare/driverlib\can.c **** 
1033:C:/StellarisWare/driverlib\can.c ****     //
1034:C:/StellarisWare/driverlib\can.c ****     // Register the interrupt handler.
1035:C:/StellarisWare/driverlib\can.c ****     //
1036:C:/StellarisWare/driverlib\can.c ****     IntUnregister(ulIntNumber);
 1041              		.loc 1 1036 0
 1042 0018 F868     		ldr	r0, [r7, #12]
 1043 001a FFF7FEFF 		bl	IntUnregister
1037:C:/StellarisWare/driverlib\can.c **** }
 1044              		.loc 1 1037 0
 1045 001e 07F11007 		add	r7, r7, #16
 1046 0022 BD46     		mov	sp, r7
 1047 0024 80BD     		pop	{r7, pc}
 1048              		.cfi_endproc
 1049              	.LFE12:
 1051 0026 00BF     		.section	.text.CANIntEnable,"ax",%progbits
 1052              		.align	2
 1053              		.global	CANIntEnable
 1054              		.thumb
 1055              		.thumb_func
 1057              	CANIntEnable:
 1058              	.LFB13:
1038:C:/StellarisWare/driverlib\can.c **** 
1039:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1040:C:/StellarisWare/driverlib\can.c **** //
1041:C:/StellarisWare/driverlib\can.c **** //! Enables individual CAN controller interrupt sources.
1042:C:/StellarisWare/driverlib\can.c **** //!
1043:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1044:C:/StellarisWare/driverlib\can.c **** //! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
1045:C:/StellarisWare/driverlib\can.c **** //!
1046:C:/StellarisWare/driverlib\can.c **** //! This function enables specific interrupt sources of the CAN controller.
1047:C:/StellarisWare/driverlib\can.c **** //! Only enabled sources cause a processor interrupt.
1048:C:/StellarisWare/driverlib\can.c **** //!
1049:C:/StellarisWare/driverlib\can.c **** //! The \e ulIntFlags parameter is the logical OR of any of the following:
1050:C:/StellarisWare/driverlib\can.c **** //!
1051:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_ERROR - a controller error condition has occurred
1052:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_STATUS - a message transfer has completed, or a bus error has
1053:C:/StellarisWare/driverlib\can.c **** //! been detected
1054:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_MASTER - allow CAN controller to generate interrupts
1055:C:/StellarisWare/driverlib\can.c **** //!
1056:C:/StellarisWare/driverlib\can.c **** //! In order to generate any interrupts, \b CAN_INT_MASTER must be enabled.
1057:C:/StellarisWare/driverlib\can.c **** //! Further, for any particular transaction from a message object to generate
1058:C:/StellarisWare/driverlib\can.c **** //! an interrupt, that message object must have interrupts enabled (see
1059:C:/StellarisWare/driverlib\can.c **** //! CANMessageSet()).  \b CAN_INT_ERROR will generate an interrupt if the
1060:C:/StellarisWare/driverlib\can.c **** //! controller enters the ``bus off'' condition, or if the error counters reach
1061:C:/StellarisWare/driverlib\can.c **** //! a limit.  \b CAN_INT_STATUS generates an interrupt under quite a few
1062:C:/StellarisWare/driverlib\can.c **** //! status conditions and may provide more interrupts than the application
1063:C:/StellarisWare/driverlib\can.c **** //! needs to handle.  When an interrupt occurs, use CANIntStatus() to determine
1064:C:/StellarisWare/driverlib\can.c **** //! the cause.
1065:C:/StellarisWare/driverlib\can.c **** //!
1066:C:/StellarisWare/driverlib\can.c **** //! \return None.
1067:C:/StellarisWare/driverlib\can.c **** //
1068:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1069:C:/StellarisWare/driverlib\can.c **** void
1070:C:/StellarisWare/driverlib\can.c **** CANIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
1071:C:/StellarisWare/driverlib\can.c **** {
 1059              		.loc 1 1071 0
 1060              		.cfi_startproc
 1061              		@ args = 0, pretend = 0, frame = 8
 1062              		@ frame_needed = 1, uses_anonymous_args = 0
 1063 0000 80B5     		push	{r7, lr}
 1064              	.LCFI39:
 1065              		.cfi_def_cfa_offset 8
 1066              		.cfi_offset 14, -4
 1067              		.cfi_offset 7, -8
 1068 0002 82B0     		sub	sp, sp, #8
 1069              	.LCFI40:
 1070              		.cfi_def_cfa_offset 16
 1071 0004 00AF     		add	r7, sp, #0
 1072              	.LCFI41:
 1073              		.cfi_def_cfa_register 7
 1074 0006 7860     		str	r0, [r7, #4]
 1075 0008 3960     		str	r1, [r7, #0]
1072:C:/StellarisWare/driverlib\can.c ****     //
1073:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1074:C:/StellarisWare/driverlib\can.c ****     //
1075:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1076:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulIntFlags & ~(CAN_CTL_EIE | CAN_CTL_SIE | CAN_CTL_IE)) == 0);
1077:C:/StellarisWare/driverlib\can.c **** 
1078:C:/StellarisWare/driverlib\can.c ****     //
1079:C:/StellarisWare/driverlib\can.c ****     // Enable the specified interrupts.
1080:C:/StellarisWare/driverlib\can.c ****     //
1081:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
1082:C:/StellarisWare/driverlib\can.c ****                 CANRegRead(ulBase + CAN_O_CTL) | ulIntFlags);
 1076              		.loc 1 1082 0
 1077 000a 7868     		ldr	r0, [r7, #4]
 1078 000c FFF7FEFF 		bl	CANRegRead
 1079 0010 0246     		mov	r2, r0
1081:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 1080              		.loc 1 1081 0
 1081 0012 3B68     		ldr	r3, [r7, #0]
 1082 0014 1343     		orrs	r3, r3, r2
 1083 0016 7868     		ldr	r0, [r7, #4]
 1084 0018 1946     		mov	r1, r3
 1085 001a FFF7FEFF 		bl	CANRegWrite
1083:C:/StellarisWare/driverlib\can.c **** }
 1086              		.loc 1 1083 0
 1087 001e 07F10807 		add	r7, r7, #8
 1088 0022 BD46     		mov	sp, r7
 1089 0024 80BD     		pop	{r7, pc}
 1090              		.cfi_endproc
 1091              	.LFE13:
 1093 0026 00BF     		.section	.text.CANIntDisable,"ax",%progbits
 1094              		.align	2
 1095              		.global	CANIntDisable
 1096              		.thumb
 1097              		.thumb_func
 1099              	CANIntDisable:
 1100              	.LFB14:
1084:C:/StellarisWare/driverlib\can.c **** 
1085:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1086:C:/StellarisWare/driverlib\can.c **** //
1087:C:/StellarisWare/driverlib\can.c **** //! Disables individual CAN controller interrupt sources.
1088:C:/StellarisWare/driverlib\can.c **** //!
1089:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1090:C:/StellarisWare/driverlib\can.c **** //! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
1091:C:/StellarisWare/driverlib\can.c **** //!
1092:C:/StellarisWare/driverlib\can.c **** //! Disables the specified CAN controller interrupt sources.  Only enabled
1093:C:/StellarisWare/driverlib\can.c **** //! interrupt sources can cause a processor interrupt.
1094:C:/StellarisWare/driverlib\can.c **** //!
1095:C:/StellarisWare/driverlib\can.c **** //! The \e ulIntFlags parameter has the same definition as in the
1096:C:/StellarisWare/driverlib\can.c **** //! CANIntEnable() function.
1097:C:/StellarisWare/driverlib\can.c **** //!
1098:C:/StellarisWare/driverlib\can.c **** //! \return None.
1099:C:/StellarisWare/driverlib\can.c **** //
1100:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1101:C:/StellarisWare/driverlib\can.c **** void
1102:C:/StellarisWare/driverlib\can.c **** CANIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
1103:C:/StellarisWare/driverlib\can.c **** {
 1101              		.loc 1 1103 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 8
 1104              		@ frame_needed = 1, uses_anonymous_args = 0
 1105 0000 80B5     		push	{r7, lr}
 1106              	.LCFI42:
 1107              		.cfi_def_cfa_offset 8
 1108              		.cfi_offset 14, -4
 1109              		.cfi_offset 7, -8
 1110 0002 82B0     		sub	sp, sp, #8
 1111              	.LCFI43:
 1112              		.cfi_def_cfa_offset 16
 1113 0004 00AF     		add	r7, sp, #0
 1114              	.LCFI44:
 1115              		.cfi_def_cfa_register 7
 1116 0006 7860     		str	r0, [r7, #4]
 1117 0008 3960     		str	r1, [r7, #0]
1104:C:/StellarisWare/driverlib\can.c ****     //
1105:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1106:C:/StellarisWare/driverlib\can.c ****     //
1107:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1108:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulIntFlags & ~(CAN_CTL_EIE | CAN_CTL_SIE | CAN_CTL_IE)) == 0);
1109:C:/StellarisWare/driverlib\can.c **** 
1110:C:/StellarisWare/driverlib\can.c ****     //
1111:C:/StellarisWare/driverlib\can.c ****     // Disable the specified interrupts.
1112:C:/StellarisWare/driverlib\can.c ****     //
1113:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
1114:C:/StellarisWare/driverlib\can.c ****                 CANRegRead(ulBase + CAN_O_CTL) & ~(ulIntFlags));
 1118              		.loc 1 1114 0
 1119 000a 7868     		ldr	r0, [r7, #4]
 1120 000c FFF7FEFF 		bl	CANRegRead
 1121 0010 0246     		mov	r2, r0
 1122 0012 3B68     		ldr	r3, [r7, #0]
 1123 0014 6FEA0303 		mvn	r3, r3
1113:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL,
 1124              		.loc 1 1113 0
 1125 0018 1340     		ands	r3, r3, r2
 1126 001a 7868     		ldr	r0, [r7, #4]
 1127 001c 1946     		mov	r1, r3
 1128 001e FFF7FEFF 		bl	CANRegWrite
1115:C:/StellarisWare/driverlib\can.c **** }
 1129              		.loc 1 1115 0
 1130 0022 07F10807 		add	r7, r7, #8
 1131 0026 BD46     		mov	sp, r7
 1132 0028 80BD     		pop	{r7, pc}
 1133              		.cfi_endproc
 1134              	.LFE14:
 1136 002a 00BF     		.section	.text.CANIntStatus,"ax",%progbits
 1137              		.align	2
 1138              		.global	CANIntStatus
 1139              		.thumb
 1140              		.thumb_func
 1142              	CANIntStatus:
 1143              	.LFB15:
1116:C:/StellarisWare/driverlib\can.c **** 
1117:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1118:C:/StellarisWare/driverlib\can.c **** //
1119:C:/StellarisWare/driverlib\can.c **** //! Returns the current CAN controller interrupt status.
1120:C:/StellarisWare/driverlib\can.c **** //!
1121:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1122:C:/StellarisWare/driverlib\can.c **** //! \param eIntStsReg indicates which interrupt status register to read
1123:C:/StellarisWare/driverlib\can.c **** //!
1124:C:/StellarisWare/driverlib\can.c **** //! This function returns the value of one of two interrupt status registers.
1125:C:/StellarisWare/driverlib\can.c **** //! The interrupt status register read is determined by the \e eIntStsReg
1126:C:/StellarisWare/driverlib\can.c **** //! parameter, which can have one of the following values:
1127:C:/StellarisWare/driverlib\can.c **** //!
1128:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_STS_CAUSE - indicates the cause of the interrupt
1129:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_STS_OBJECT - indicates pending interrupts of all message
1130:C:/StellarisWare/driverlib\can.c **** //! objects
1131:C:/StellarisWare/driverlib\can.c **** //!
1132:C:/StellarisWare/driverlib\can.c **** //! \b CAN_INT_STS_CAUSE returns the value of the controller interrupt register
1133:C:/StellarisWare/driverlib\can.c **** //! and indicates the cause of the interrupt. The value returned is
1134:C:/StellarisWare/driverlib\can.c **** //! \b CAN_INT_INTID_STATUS if the cause is a status interrupt.  In this case,
1135:C:/StellarisWare/driverlib\can.c **** //! the status register should be read with the CANStatusGet() function.
1136:C:/StellarisWare/driverlib\can.c **** //! Calling this function to read the status also clears the status
1137:C:/StellarisWare/driverlib\can.c **** //! interrupt.  If the value of the interrupt register is in the range 1-32,
1138:C:/StellarisWare/driverlib\can.c **** //! then this indicates the number of the highest priority message object that
1139:C:/StellarisWare/driverlib\can.c **** //! has an interrupt pending.  The message object interrupt can be cleared by
1140:C:/StellarisWare/driverlib\can.c **** //! using the CANIntClear() function, or by reading the message using
1141:C:/StellarisWare/driverlib\can.c **** //! CANMessageGet() in the case of a received message.  The interrupt handler
1142:C:/StellarisWare/driverlib\can.c **** //! can read the interrupt status again to make sure all pending interrupts are
1143:C:/StellarisWare/driverlib\can.c **** //! cleared before returning from the interrupt.
1144:C:/StellarisWare/driverlib\can.c **** //!
1145:C:/StellarisWare/driverlib\can.c **** //! \b CAN_INT_STS_OBJECT returns a bit mask indicating which message objects
1146:C:/StellarisWare/driverlib\can.c **** //! have pending interrupts.  This value can be used to discover all of the
1147:C:/StellarisWare/driverlib\can.c **** //! pending interrupts at once, as opposed to repeatedly reading the interrupt
1148:C:/StellarisWare/driverlib\can.c **** //! register by using \b CAN_INT_STS_CAUSE.
1149:C:/StellarisWare/driverlib\can.c **** //!
1150:C:/StellarisWare/driverlib\can.c **** //! \return Returns the value of one of the interrupt status registers.
1151:C:/StellarisWare/driverlib\can.c **** //
1152:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1153:C:/StellarisWare/driverlib\can.c **** unsigned long
1154:C:/StellarisWare/driverlib\can.c **** CANIntStatus(unsigned long ulBase, tCANIntStsReg eIntStsReg)
1155:C:/StellarisWare/driverlib\can.c **** {
 1144              		.loc 1 1155 0
 1145              		.cfi_startproc
 1146              		@ args = 0, pretend = 0, frame = 16
 1147              		@ frame_needed = 1, uses_anonymous_args = 0
 1148 0000 80B5     		push	{r7, lr}
 1149              	.LCFI45:
 1150              		.cfi_def_cfa_offset 8
 1151              		.cfi_offset 14, -4
 1152              		.cfi_offset 7, -8
 1153 0002 84B0     		sub	sp, sp, #16
 1154              	.LCFI46:
 1155              		.cfi_def_cfa_offset 24
 1156 0004 00AF     		add	r7, sp, #0
 1157              	.LCFI47:
 1158              		.cfi_def_cfa_register 7
 1159 0006 7860     		str	r0, [r7, #4]
 1160 0008 0B46     		mov	r3, r1
 1161 000a FB70     		strb	r3, [r7, #3]
1156:C:/StellarisWare/driverlib\can.c ****     unsigned long ulStatus;
1157:C:/StellarisWare/driverlib\can.c **** 
1158:C:/StellarisWare/driverlib\can.c ****     //
1159:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1160:C:/StellarisWare/driverlib\can.c ****     //
1161:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1162:C:/StellarisWare/driverlib\can.c **** 
1163:C:/StellarisWare/driverlib\can.c ****     //
1164:C:/StellarisWare/driverlib\can.c ****     // See which status the caller is looking for.
1165:C:/StellarisWare/driverlib\can.c ****     //
1166:C:/StellarisWare/driverlib\can.c ****     switch(eIntStsReg)
 1162              		.loc 1 1166 0
 1163 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1164 000e 002B     		cmp	r3, #0
 1165 0010 02D0     		beq	.L52
 1166 0012 012B     		cmp	r3, #1
 1167 0014 08D0     		beq	.L53
 1168 0016 20E0     		b	.L55
 1169              	.L52:
1167:C:/StellarisWare/driverlib\can.c ****     {
1168:C:/StellarisWare/driverlib\can.c ****         //
1169:C:/StellarisWare/driverlib\can.c ****         // The caller wants the global interrupt status for the CAN controller
1170:C:/StellarisWare/driverlib\can.c ****         // specified by ulBase.
1171:C:/StellarisWare/driverlib\can.c ****         //
1172:C:/StellarisWare/driverlib\can.c ****         case CAN_INT_STS_CAUSE:
1173:C:/StellarisWare/driverlib\can.c ****         {
1174:C:/StellarisWare/driverlib\can.c ****             ulStatus = CANRegRead(ulBase + CAN_O_INT);
 1170              		.loc 1 1174 0
 1171 0018 7B68     		ldr	r3, [r7, #4]
 1172 001a 03F11003 		add	r3, r3, #16
 1173 001e 1846     		mov	r0, r3
 1174 0020 FFF7FEFF 		bl	CANRegRead
 1175 0024 F860     		str	r0, [r7, #12]
1175:C:/StellarisWare/driverlib\can.c ****             break;
 1176              		.loc 1 1175 0
 1177 0026 1CE0     		b	.L54
 1178              	.L53:
1176:C:/StellarisWare/driverlib\can.c ****         }
1177:C:/StellarisWare/driverlib\can.c **** 
1178:C:/StellarisWare/driverlib\can.c ****         //
1179:C:/StellarisWare/driverlib\can.c ****         // The caller wants the current message status interrupt for all
1180:C:/StellarisWare/driverlib\can.c ****         // messages.
1181:C:/StellarisWare/driverlib\can.c ****         //
1182:C:/StellarisWare/driverlib\can.c ****         case CAN_INT_STS_OBJECT:
1183:C:/StellarisWare/driverlib\can.c ****         {
1184:C:/StellarisWare/driverlib\can.c ****             //
1185:C:/StellarisWare/driverlib\can.c ****             // Read and combine both 16 bit values into one 32bit status.
1186:C:/StellarisWare/driverlib\can.c ****             //
1187:C:/StellarisWare/driverlib\can.c ****             ulStatus = (CANRegRead(ulBase + CAN_O_MSG1INT) &
 1179              		.loc 1 1187 0
 1180 0028 7B68     		ldr	r3, [r7, #4]
 1181 002a 03F5A073 		add	r3, r3, #320
 1182 002e 1846     		mov	r0, r3
 1183 0030 FFF7FEFF 		bl	CANRegRead
 1184 0034 0346     		mov	r3, r0
 1185 0036 4FEA0343 		lsl	r3, r3, #16
 1186 003a 4FEA1343 		lsr	r3, r3, #16
 1187 003e FB60     		str	r3, [r7, #12]
1188:C:/StellarisWare/driverlib\can.c ****                         CAN_MSG1INT_INTPND_M);
1189:C:/StellarisWare/driverlib\can.c ****             ulStatus |= (CANRegRead(ulBase + CAN_O_MSG2INT) << 16);
 1188              		.loc 1 1189 0
 1189 0040 7B68     		ldr	r3, [r7, #4]
 1190 0042 03F5A273 		add	r3, r3, #324
 1191 0046 1846     		mov	r0, r3
 1192 0048 FFF7FEFF 		bl	CANRegRead
 1193 004c 0346     		mov	r3, r0
 1194 004e 4FEA0343 		lsl	r3, r3, #16
 1195 0052 FA68     		ldr	r2, [r7, #12]
 1196 0054 1343     		orrs	r3, r3, r2
 1197 0056 FB60     		str	r3, [r7, #12]
1190:C:/StellarisWare/driverlib\can.c ****             break;
 1198              		.loc 1 1190 0
 1199 0058 03E0     		b	.L54
 1200              	.L55:
1191:C:/StellarisWare/driverlib\can.c ****         }
1192:C:/StellarisWare/driverlib\can.c **** 
1193:C:/StellarisWare/driverlib\can.c ****         //
1194:C:/StellarisWare/driverlib\can.c ****         // Request was for unknown status so just return 0.
1195:C:/StellarisWare/driverlib\can.c ****         //
1196:C:/StellarisWare/driverlib\can.c ****         default:
1197:C:/StellarisWare/driverlib\can.c ****         {
1198:C:/StellarisWare/driverlib\can.c ****             ulStatus = 0;
 1201              		.loc 1 1198 0
 1202 005a 4FF00003 		mov	r3, #0
 1203 005e FB60     		str	r3, [r7, #12]
1199:C:/StellarisWare/driverlib\can.c ****             break;
 1204              		.loc 1 1199 0
 1205 0060 00BF     		nop
 1206              	.L54:
1200:C:/StellarisWare/driverlib\can.c ****         }
1201:C:/StellarisWare/driverlib\can.c ****     }
1202:C:/StellarisWare/driverlib\can.c **** 
1203:C:/StellarisWare/driverlib\can.c ****     //
1204:C:/StellarisWare/driverlib\can.c ****     // Return the interrupt status value
1205:C:/StellarisWare/driverlib\can.c ****     //
1206:C:/StellarisWare/driverlib\can.c ****     return(ulStatus);
 1207              		.loc 1 1206 0
 1208 0062 FB68     		ldr	r3, [r7, #12]
1207:C:/StellarisWare/driverlib\can.c **** }
 1209              		.loc 1 1207 0
 1210 0064 1846     		mov	r0, r3
 1211 0066 07F11007 		add	r7, r7, #16
 1212 006a BD46     		mov	sp, r7
 1213 006c 80BD     		pop	{r7, pc}
 1214              		.cfi_endproc
 1215              	.LFE15:
 1217 006e 00BF     		.section	.text.CANIntClear,"ax",%progbits
 1218              		.align	2
 1219              		.global	CANIntClear
 1220              		.thumb
 1221              		.thumb_func
 1223              	CANIntClear:
 1224              	.LFB16:
1208:C:/StellarisWare/driverlib\can.c **** 
1209:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1210:C:/StellarisWare/driverlib\can.c **** //
1211:C:/StellarisWare/driverlib\can.c **** //! Clears a CAN interrupt source.
1212:C:/StellarisWare/driverlib\can.c **** //!
1213:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1214:C:/StellarisWare/driverlib\can.c **** //! \param ulIntClr is a value indicating which interrupt source to clear.
1215:C:/StellarisWare/driverlib\can.c **** //!
1216:C:/StellarisWare/driverlib\can.c **** //! This function can be used to clear a specific interrupt source.  The
1217:C:/StellarisWare/driverlib\can.c **** //! \e ulIntClr parameter should be one of the following values:
1218:C:/StellarisWare/driverlib\can.c **** //!
1219:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_INT_INTID_STATUS - Clears a status interrupt.
1220:C:/StellarisWare/driverlib\can.c **** //! - 1-32 - Clears the specified message object interrupt
1221:C:/StellarisWare/driverlib\can.c **** //!
1222:C:/StellarisWare/driverlib\can.c **** //! It is not necessary to use this function to clear an interrupt.  This
1223:C:/StellarisWare/driverlib\can.c **** //! function should only be used if the application wants to clear an interrupt
1224:C:/StellarisWare/driverlib\can.c **** //! source without taking the normal interrupt action.
1225:C:/StellarisWare/driverlib\can.c **** //!
1226:C:/StellarisWare/driverlib\can.c **** //! Normally, the status interrupt is cleared by reading the controller status
1227:C:/StellarisWare/driverlib\can.c **** //! using CANStatusGet().  A specific message object interrupt is normally
1228:C:/StellarisWare/driverlib\can.c **** //! cleared by reading the message object using CANMessageGet().
1229:C:/StellarisWare/driverlib\can.c **** //!
1230:C:/StellarisWare/driverlib\can.c **** //! \note Because there is a write buffer in the Cortex-M processor, it may
1231:C:/StellarisWare/driverlib\can.c **** //! take several clock cycles before the interrupt source is actually cleared.
1232:C:/StellarisWare/driverlib\can.c **** //! Therefore, it is recommended that the interrupt source be cleared early in
1233:C:/StellarisWare/driverlib\can.c **** //! the interrupt handler (as opposed to the very last action) to avoid
1234:C:/StellarisWare/driverlib\can.c **** //! returning from the interrupt handler before the interrupt source is
1235:C:/StellarisWare/driverlib\can.c **** //! actually cleared.  Failure to do so may result in the interrupt handler
1236:C:/StellarisWare/driverlib\can.c **** //! being immediately reentered (because the interrupt controller still sees
1237:C:/StellarisWare/driverlib\can.c **** //! the interrupt source asserted).
1238:C:/StellarisWare/driverlib\can.c **** //!
1239:C:/StellarisWare/driverlib\can.c **** //! \return None.
1240:C:/StellarisWare/driverlib\can.c **** //
1241:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1242:C:/StellarisWare/driverlib\can.c **** void
1243:C:/StellarisWare/driverlib\can.c **** CANIntClear(unsigned long ulBase, unsigned long ulIntClr)
1244:C:/StellarisWare/driverlib\can.c **** {
 1225              		.loc 1 1244 0
 1226              		.cfi_startproc
 1227              		@ args = 0, pretend = 0, frame = 8
 1228              		@ frame_needed = 1, uses_anonymous_args = 0
 1229 0000 80B5     		push	{r7, lr}
 1230              	.LCFI48:
 1231              		.cfi_def_cfa_offset 8
 1232              		.cfi_offset 14, -4
 1233              		.cfi_offset 7, -8
 1234 0002 82B0     		sub	sp, sp, #8
 1235              	.LCFI49:
 1236              		.cfi_def_cfa_offset 16
 1237 0004 00AF     		add	r7, sp, #0
 1238              	.LCFI50:
 1239              		.cfi_def_cfa_register 7
 1240 0006 7860     		str	r0, [r7, #4]
 1241 0008 3960     		str	r1, [r7, #0]
1245:C:/StellarisWare/driverlib\can.c ****     //
1246:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1247:C:/StellarisWare/driverlib\can.c ****     //
1248:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1249:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulIntClr == CAN_INT_INTID_STATUS) ||
1250:C:/StellarisWare/driverlib\can.c ****            ((ulIntClr>=1) && (ulIntClr <=32)));
1251:C:/StellarisWare/driverlib\can.c **** 
1252:C:/StellarisWare/driverlib\can.c ****     if(ulIntClr == CAN_INT_INTID_STATUS)
 1242              		.loc 1 1252 0
 1243 000a 3B68     		ldr	r3, [r7, #0]
 1244 000c B3F5004F 		cmp	r3, #32768
 1245 0010 06D1     		bne	.L61
1253:C:/StellarisWare/driverlib\can.c ****     {
1254:C:/StellarisWare/driverlib\can.c ****         //
1255:C:/StellarisWare/driverlib\can.c ****         // Simply read and discard the status to clear the interrupt.
1256:C:/StellarisWare/driverlib\can.c ****         //
1257:C:/StellarisWare/driverlib\can.c ****         CANRegRead(ulBase + CAN_O_STS);
 1246              		.loc 1 1257 0
 1247 0012 7B68     		ldr	r3, [r7, #4]
 1248 0014 03F10403 		add	r3, r3, #4
 1249 0018 1846     		mov	r0, r3
 1250 001a FFF7FEFF 		bl	CANRegRead
 1251 001e 29E0     		b	.L56
 1252              	.L61:
1258:C:/StellarisWare/driverlib\can.c ****     }
1259:C:/StellarisWare/driverlib\can.c ****     else
1260:C:/StellarisWare/driverlib\can.c ****     {
1261:C:/StellarisWare/driverlib\can.c ****         //
1262:C:/StellarisWare/driverlib\can.c ****         // Wait to be sure that this interface is not busy.
1263:C:/StellarisWare/driverlib\can.c ****         //
1264:C:/StellarisWare/driverlib\can.c ****         while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 1253              		.loc 1 1264 0
 1254 0020 00BF     		nop
 1255              	.L59:
 1256              		.loc 1 1264 0 is_stmt 0 discriminator 1
 1257 0022 7B68     		ldr	r3, [r7, #4]
 1258 0024 03F12003 		add	r3, r3, #32
 1259 0028 1846     		mov	r0, r3
 1260 002a FFF7FEFF 		bl	CANRegRead
 1261 002e 0346     		mov	r3, r0
 1262 0030 03F40043 		and	r3, r3, #32768
 1263 0034 002B     		cmp	r3, #0
 1264 0036 F4D1     		bne	.L59
1265:C:/StellarisWare/driverlib\can.c ****         {
1266:C:/StellarisWare/driverlib\can.c ****         }
1267:C:/StellarisWare/driverlib\can.c **** 
1268:C:/StellarisWare/driverlib\can.c ****         //
1269:C:/StellarisWare/driverlib\can.c ****         // Only change the interrupt pending state by setting only the
1270:C:/StellarisWare/driverlib\can.c ****         // CAN_IF1CMSK_CLRINTPND bit.
1271:C:/StellarisWare/driverlib\can.c ****         //
1272:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_CLRINTPND);
 1265              		.loc 1 1272 0 is_stmt 1
 1266 0038 7B68     		ldr	r3, [r7, #4]
 1267 003a 03F12403 		add	r3, r3, #36
 1268 003e 1846     		mov	r0, r3
 1269 0040 4FF00801 		mov	r1, #8
 1270 0044 FFF7FEFF 		bl	CANRegWrite
1273:C:/StellarisWare/driverlib\can.c **** 
1274:C:/StellarisWare/driverlib\can.c ****         //
1275:C:/StellarisWare/driverlib\can.c ****         // Send the clear pending interrupt command to the CAN controller.
1276:C:/StellarisWare/driverlib\can.c ****         //
1277:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF1CRQ, ulIntClr & CAN_IF1CRQ_MNUM_M);
 1271              		.loc 1 1277 0
 1272 0048 7B68     		ldr	r3, [r7, #4]
 1273 004a 03F12002 		add	r2, r3, #32
 1274 004e 3B68     		ldr	r3, [r7, #0]
 1275 0050 03F03F03 		and	r3, r3, #63
 1276 0054 1046     		mov	r0, r2
 1277 0056 1946     		mov	r1, r3
 1278 0058 FFF7FEFF 		bl	CANRegWrite
1278:C:/StellarisWare/driverlib\can.c **** 
1279:C:/StellarisWare/driverlib\can.c ****         //
1280:C:/StellarisWare/driverlib\can.c ****         // Wait to be sure that this interface is not busy.
1281:C:/StellarisWare/driverlib\can.c ****         //
1282:C:/StellarisWare/driverlib\can.c ****         while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 1279              		.loc 1 1282 0
 1280 005c 00BF     		nop
 1281              	.L60:
 1282              		.loc 1 1282 0 is_stmt 0 discriminator 1
 1283 005e 7B68     		ldr	r3, [r7, #4]
 1284 0060 03F12003 		add	r3, r3, #32
 1285 0064 1846     		mov	r0, r3
 1286 0066 FFF7FEFF 		bl	CANRegRead
 1287 006a 0346     		mov	r3, r0
 1288 006c 03F40043 		and	r3, r3, #32768
 1289 0070 002B     		cmp	r3, #0
 1290 0072 F4D1     		bne	.L60
 1291              	.L56:
1283:C:/StellarisWare/driverlib\can.c ****         {
1284:C:/StellarisWare/driverlib\can.c ****         }
1285:C:/StellarisWare/driverlib\can.c ****     }
1286:C:/StellarisWare/driverlib\can.c **** }
 1292              		.loc 1 1286 0 is_stmt 1
 1293 0074 07F10807 		add	r7, r7, #8
 1294 0078 BD46     		mov	sp, r7
 1295 007a 80BD     		pop	{r7, pc}
 1296              		.cfi_endproc
 1297              	.LFE16:
 1299              		.section	.text.CANRetrySet,"ax",%progbits
 1300              		.align	2
 1301              		.global	CANRetrySet
 1302              		.thumb
 1303              		.thumb_func
 1305              	CANRetrySet:
 1306              	.LFB17:
1287:C:/StellarisWare/driverlib\can.c **** 
1288:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1289:C:/StellarisWare/driverlib\can.c **** //
1290:C:/StellarisWare/driverlib\can.c **** //! Sets the CAN controller automatic retransmission behavior.
1291:C:/StellarisWare/driverlib\can.c **** //!
1292:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1293:C:/StellarisWare/driverlib\can.c **** //! \param bAutoRetry enables automatic retransmission.
1294:C:/StellarisWare/driverlib\can.c **** //!
1295:C:/StellarisWare/driverlib\can.c **** //! This function enables or disables automatic retransmission of messages with
1296:C:/StellarisWare/driverlib\can.c **** //! detected errors.  If \e bAutoRetry is \b true, then automatic
1297:C:/StellarisWare/driverlib\can.c **** //! retransmission is enabled, otherwise it is disabled.
1298:C:/StellarisWare/driverlib\can.c **** //!
1299:C:/StellarisWare/driverlib\can.c **** //! \return None.
1300:C:/StellarisWare/driverlib\can.c **** //
1301:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1302:C:/StellarisWare/driverlib\can.c **** void
1303:C:/StellarisWare/driverlib\can.c **** CANRetrySet(unsigned long ulBase, tBoolean bAutoRetry)
1304:C:/StellarisWare/driverlib\can.c **** {
 1307              		.loc 1 1304 0
 1308              		.cfi_startproc
 1309              		@ args = 0, pretend = 0, frame = 16
 1310              		@ frame_needed = 1, uses_anonymous_args = 0
 1311 0000 80B5     		push	{r7, lr}
 1312              	.LCFI51:
 1313              		.cfi_def_cfa_offset 8
 1314              		.cfi_offset 14, -4
 1315              		.cfi_offset 7, -8
 1316 0002 84B0     		sub	sp, sp, #16
 1317              	.LCFI52:
 1318              		.cfi_def_cfa_offset 24
 1319 0004 00AF     		add	r7, sp, #0
 1320              	.LCFI53:
 1321              		.cfi_def_cfa_register 7
 1322 0006 7860     		str	r0, [r7, #4]
 1323 0008 0B46     		mov	r3, r1
 1324 000a FB70     		strb	r3, [r7, #3]
1305:C:/StellarisWare/driverlib\can.c ****     unsigned long ulCtlReg;
1306:C:/StellarisWare/driverlib\can.c **** 
1307:C:/StellarisWare/driverlib\can.c ****     //
1308:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1309:C:/StellarisWare/driverlib\can.c ****     //
1310:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1311:C:/StellarisWare/driverlib\can.c **** 
1312:C:/StellarisWare/driverlib\can.c ****     ulCtlReg = CANRegRead(ulBase + CAN_O_CTL);
 1325              		.loc 1 1312 0
 1326 000c 7868     		ldr	r0, [r7, #4]
 1327 000e FFF7FEFF 		bl	CANRegRead
 1328 0012 F860     		str	r0, [r7, #12]
1313:C:/StellarisWare/driverlib\can.c **** 
1314:C:/StellarisWare/driverlib\can.c ****     //
1315:C:/StellarisWare/driverlib\can.c ****     // Conditionally set the DAR bit to enable/disable auto-retry.
1316:C:/StellarisWare/driverlib\can.c ****     //
1317:C:/StellarisWare/driverlib\can.c ****     if(bAutoRetry)
 1329              		.loc 1 1317 0
 1330 0014 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1331 0016 002B     		cmp	r3, #0
 1332 0018 04D0     		beq	.L63
1318:C:/StellarisWare/driverlib\can.c ****     {
1319:C:/StellarisWare/driverlib\can.c ****         //
1320:C:/StellarisWare/driverlib\can.c ****         // Clearing the DAR bit tells the controller to not disable the
1321:C:/StellarisWare/driverlib\can.c ****         // auto-retry of messages which were not transmitted or received
1322:C:/StellarisWare/driverlib\can.c ****         // correctly.
1323:C:/StellarisWare/driverlib\can.c ****         //
1324:C:/StellarisWare/driverlib\can.c ****         ulCtlReg &= ~CAN_CTL_DAR;
 1333              		.loc 1 1324 0
 1334 001a FB68     		ldr	r3, [r7, #12]
 1335 001c 23F02003 		bic	r3, r3, #32
 1336 0020 FB60     		str	r3, [r7, #12]
 1337 0022 03E0     		b	.L64
 1338              	.L63:
1325:C:/StellarisWare/driverlib\can.c ****     }
1326:C:/StellarisWare/driverlib\can.c ****     else
1327:C:/StellarisWare/driverlib\can.c ****     {
1328:C:/StellarisWare/driverlib\can.c ****         //
1329:C:/StellarisWare/driverlib\can.c ****         // Setting the DAR bit tells the controller to disable the auto-retry
1330:C:/StellarisWare/driverlib\can.c ****         // of messages which were not transmitted or received correctly.
1331:C:/StellarisWare/driverlib\can.c ****         //
1332:C:/StellarisWare/driverlib\can.c ****         ulCtlReg |= CAN_CTL_DAR;
 1339              		.loc 1 1332 0
 1340 0024 FB68     		ldr	r3, [r7, #12]
 1341 0026 43F02003 		orr	r3, r3, #32
 1342 002a FB60     		str	r3, [r7, #12]
 1343              	.L64:
1333:C:/StellarisWare/driverlib\can.c ****     }
1334:C:/StellarisWare/driverlib\can.c **** 
1335:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_CTL, ulCtlReg);
 1344              		.loc 1 1335 0
 1345 002c 7868     		ldr	r0, [r7, #4]
 1346 002e F968     		ldr	r1, [r7, #12]
 1347 0030 FFF7FEFF 		bl	CANRegWrite
1336:C:/StellarisWare/driverlib\can.c **** }
 1348              		.loc 1 1336 0
 1349 0034 07F11007 		add	r7, r7, #16
 1350 0038 BD46     		mov	sp, r7
 1351 003a 80BD     		pop	{r7, pc}
 1352              		.cfi_endproc
 1353              	.LFE17:
 1355              		.section	.text.CANRetryGet,"ax",%progbits
 1356              		.align	2
 1357              		.global	CANRetryGet
 1358              		.thumb
 1359              		.thumb_func
 1361              	CANRetryGet:
 1362              	.LFB18:
1337:C:/StellarisWare/driverlib\can.c **** 
1338:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1339:C:/StellarisWare/driverlib\can.c **** //
1340:C:/StellarisWare/driverlib\can.c **** //! Returns the current setting for automatic retransmission.
1341:C:/StellarisWare/driverlib\can.c **** //!
1342:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1343:C:/StellarisWare/driverlib\can.c **** //!
1344:C:/StellarisWare/driverlib\can.c **** //! This function reads the current setting for automatic retransmission in the CAN
1345:C:/StellarisWare/driverlib\can.c **** //! controller and returns it to the caller.
1346:C:/StellarisWare/driverlib\can.c **** //!
1347:C:/StellarisWare/driverlib\can.c **** //! \return Returns \b true if automatic retransmission is enabled, \b false
1348:C:/StellarisWare/driverlib\can.c **** //! otherwise.
1349:C:/StellarisWare/driverlib\can.c **** //
1350:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1351:C:/StellarisWare/driverlib\can.c **** tBoolean
1352:C:/StellarisWare/driverlib\can.c **** CANRetryGet(unsigned long ulBase)
1353:C:/StellarisWare/driverlib\can.c **** {
 1363              		.loc 1 1353 0
 1364              		.cfi_startproc
 1365              		@ args = 0, pretend = 0, frame = 8
 1366              		@ frame_needed = 1, uses_anonymous_args = 0
 1367 0000 80B5     		push	{r7, lr}
 1368              	.LCFI54:
 1369              		.cfi_def_cfa_offset 8
 1370              		.cfi_offset 14, -4
 1371              		.cfi_offset 7, -8
 1372 0002 82B0     		sub	sp, sp, #8
 1373              	.LCFI55:
 1374              		.cfi_def_cfa_offset 16
 1375 0004 00AF     		add	r7, sp, #0
 1376              	.LCFI56:
 1377              		.cfi_def_cfa_register 7
 1378 0006 7860     		str	r0, [r7, #4]
1354:C:/StellarisWare/driverlib\can.c ****     //
1355:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1356:C:/StellarisWare/driverlib\can.c ****     //
1357:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1358:C:/StellarisWare/driverlib\can.c **** 
1359:C:/StellarisWare/driverlib\can.c ****     //
1360:C:/StellarisWare/driverlib\can.c ****     // Read the disable automatic retry setting from the CAN controller.
1361:C:/StellarisWare/driverlib\can.c ****     //
1362:C:/StellarisWare/driverlib\can.c ****     if(CANRegRead(ulBase + CAN_O_CTL) & CAN_CTL_DAR)
 1379              		.loc 1 1362 0
 1380 0008 7868     		ldr	r0, [r7, #4]
 1381 000a FFF7FEFF 		bl	CANRegRead
 1382 000e 0346     		mov	r3, r0
 1383 0010 03F02003 		and	r3, r3, #32
 1384 0014 002B     		cmp	r3, #0
 1385 0016 02D0     		beq	.L66
1363:C:/StellarisWare/driverlib\can.c ****     {
1364:C:/StellarisWare/driverlib\can.c ****         //
1365:C:/StellarisWare/driverlib\can.c ****         // Automatic data retransmission is not enabled.
1366:C:/StellarisWare/driverlib\can.c ****         //
1367:C:/StellarisWare/driverlib\can.c ****         return(false);
 1386              		.loc 1 1367 0
 1387 0018 4FF00003 		mov	r3, #0
 1388 001c 01E0     		b	.L67
 1389              	.L66:
1368:C:/StellarisWare/driverlib\can.c ****     }
1369:C:/StellarisWare/driverlib\can.c **** 
1370:C:/StellarisWare/driverlib\can.c ****     //
1371:C:/StellarisWare/driverlib\can.c ****     // Automatic data retransmission is enabled.
1372:C:/StellarisWare/driverlib\can.c ****     //
1373:C:/StellarisWare/driverlib\can.c ****     return(true);
 1390              		.loc 1 1373 0
 1391 001e 4FF00103 		mov	r3, #1
 1392              	.L67:
1374:C:/StellarisWare/driverlib\can.c **** }
 1393              		.loc 1 1374 0
 1394 0022 1846     		mov	r0, r3
 1395 0024 07F10807 		add	r7, r7, #8
 1396 0028 BD46     		mov	sp, r7
 1397 002a 80BD     		pop	{r7, pc}
 1398              		.cfi_endproc
 1399              	.LFE18:
 1401              		.section	.text.CANStatusGet,"ax",%progbits
 1402              		.align	2
 1403              		.global	CANStatusGet
 1404              		.thumb
 1405              		.thumb_func
 1407              	CANStatusGet:
 1408              	.LFB19:
1375:C:/StellarisWare/driverlib\can.c **** 
1376:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1377:C:/StellarisWare/driverlib\can.c **** //
1378:C:/StellarisWare/driverlib\can.c **** //! Reads one of the controller status registers.
1379:C:/StellarisWare/driverlib\can.c **** //!
1380:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1381:C:/StellarisWare/driverlib\can.c **** //! \param eStatusReg is the status register to read.
1382:C:/StellarisWare/driverlib\can.c **** //!
1383:C:/StellarisWare/driverlib\can.c **** //! This function reads a status register of the CAN controller and returns it
1384:C:/StellarisWare/driverlib\can.c **** //! to the caller.
1385:C:/StellarisWare/driverlib\can.c **** //! The different status registers are:
1386:C:/StellarisWare/driverlib\can.c **** //!
1387:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_CONTROL - the main controller status
1388:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_TXREQUEST - bit mask of objects pending transmission
1389:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_NEWDAT - bit mask of objects with new data
1390:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_MSGVAL - bit mask of objects with valid configuration
1391:C:/StellarisWare/driverlib\can.c **** //!
1392:C:/StellarisWare/driverlib\can.c **** //! When reading the main controller status register, a pending status
1393:C:/StellarisWare/driverlib\can.c **** //! interrupt is cleared.  This parameter should be used in the interrupt
1394:C:/StellarisWare/driverlib\can.c **** //! handler for the CAN controller if the cause is a status interrupt.  The
1395:C:/StellarisWare/driverlib\can.c **** //! controller status register fields are as follows:
1396:C:/StellarisWare/driverlib\can.c **** //!
1397:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_BUS_OFF - controller is in bus-off condition
1398:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_EWARN - an error counter has reached a limit of at least 96
1399:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_EPASS - CAN controller is in the error passive state
1400:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_RXOK - a message was received successfully (independent of
1401:C:/StellarisWare/driverlib\can.c **** //! any message filtering).
1402:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_TXOK - a message was successfully transmitted
1403:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_MSK - mask of last error code bits (3 bits)
1404:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_NONE - no error
1405:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_STUFF - stuffing error detected
1406:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_FORM - a format error occurred in the fixed format part
1407:C:/StellarisWare/driverlib\can.c **** //! of a message
1408:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_ACK - a transmitted message was not acknowledged
1409:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_BIT1 - dominant level detected when trying to send in
1410:C:/StellarisWare/driverlib\can.c **** //! recessive mode
1411:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_BIT0 - recessive level detected when trying to send in
1412:C:/StellarisWare/driverlib\can.c **** //! dominant mode
1413:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STATUS_LEC_CRC - CRC error in received message
1414:C:/StellarisWare/driverlib\can.c **** //!
1415:C:/StellarisWare/driverlib\can.c **** //! The remaining status registers consist of 32-bit-wide bit maps to the
1416:C:/StellarisWare/driverlib\can.c **** //! message objects. They can be used to quickly obtain information about the
1417:C:/StellarisWare/driverlib\can.c **** //! status of all the message objects without needing to query each one.  They
1418:C:/StellarisWare/driverlib\can.c **** //! contain the following information:
1419:C:/StellarisWare/driverlib\can.c **** //!
1420:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_TXREQUEST - if a message object's TXRQST bit is set, a
1421:C:/StellarisWare/driverlib\can.c **** //! transmission is pending on that object.  The application can use this
1422:C:/StellarisWare/driverlib\can.c **** //! information to determine which objects are still waiting to send a
1423:C:/StellarisWare/driverlib\can.c **** //! message.
1424:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_NEWDAT - if a message object's NEWDAT bit is set, a new
1425:C:/StellarisWare/driverlib\can.c **** //! message has been received in that object, and has not yet been picked up
1426:C:/StellarisWare/driverlib\can.c **** //! by the host application
1427:C:/StellarisWare/driverlib\can.c **** //! - \b CAN_STS_MSGVAL - if a message object's MSGVAL bit is set, the object
1428:C:/StellarisWare/driverlib\can.c **** //! has a valid configuration programmed.  The host application can use this
1429:C:/StellarisWare/driverlib\can.c **** //! information to determine which message objects are empty/unused.
1430:C:/StellarisWare/driverlib\can.c **** //!
1431:C:/StellarisWare/driverlib\can.c **** //! \return Returns the value of the status register.
1432:C:/StellarisWare/driverlib\can.c **** //
1433:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1434:C:/StellarisWare/driverlib\can.c **** unsigned long
1435:C:/StellarisWare/driverlib\can.c **** CANStatusGet(unsigned long ulBase, tCANStsReg eStatusReg)
1436:C:/StellarisWare/driverlib\can.c **** {
 1409              		.loc 1 1436 0
 1410              		.cfi_startproc
 1411              		@ args = 0, pretend = 0, frame = 16
 1412              		@ frame_needed = 1, uses_anonymous_args = 0
 1413 0000 80B5     		push	{r7, lr}
 1414              	.LCFI57:
 1415              		.cfi_def_cfa_offset 8
 1416              		.cfi_offset 14, -4
 1417              		.cfi_offset 7, -8
 1418 0002 84B0     		sub	sp, sp, #16
 1419              	.LCFI58:
 1420              		.cfi_def_cfa_offset 24
 1421 0004 00AF     		add	r7, sp, #0
 1422              	.LCFI59:
 1423              		.cfi_def_cfa_register 7
 1424 0006 7860     		str	r0, [r7, #4]
 1425 0008 0B46     		mov	r3, r1
 1426 000a FB70     		strb	r3, [r7, #3]
1437:C:/StellarisWare/driverlib\can.c ****     unsigned long ulStatus;
1438:C:/StellarisWare/driverlib\can.c **** 
1439:C:/StellarisWare/driverlib\can.c ****     //
1440:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1441:C:/StellarisWare/driverlib\can.c ****     //
1442:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1443:C:/StellarisWare/driverlib\can.c **** 
1444:C:/StellarisWare/driverlib\can.c ****     switch(eStatusReg)
 1427              		.loc 1 1444 0
 1428 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1429 000e 032B     		cmp	r3, #3
 1430 0010 56D8     		bhi	.L69
 1431 0012 01A2     		adr	r2, .L74
 1432 0014 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1433              		.align	2
 1434              	.L74:
 1435 0018 29000000 		.word	.L70+1
 1436 001c 49000000 		.word	.L71+1
 1437 0020 71000000 		.word	.L72+1
 1438 0024 99000000 		.word	.L73+1
 1439              	.L70:
1445:C:/StellarisWare/driverlib\can.c ****     {
1446:C:/StellarisWare/driverlib\can.c ****         //
1447:C:/StellarisWare/driverlib\can.c ****         // Just return the global CAN status register since that is what was
1448:C:/StellarisWare/driverlib\can.c ****         // requested.
1449:C:/StellarisWare/driverlib\can.c ****         //
1450:C:/StellarisWare/driverlib\can.c ****         case CAN_STS_CONTROL:
1451:C:/StellarisWare/driverlib\can.c ****         {
1452:C:/StellarisWare/driverlib\can.c ****             ulStatus = CANRegRead(ulBase + CAN_O_STS);
 1440              		.loc 1 1452 0
 1441 0028 7B68     		ldr	r3, [r7, #4]
 1442 002a 03F10403 		add	r3, r3, #4
 1443 002e 1846     		mov	r0, r3
 1444 0030 FFF7FEFF 		bl	CANRegRead
 1445 0034 F860     		str	r0, [r7, #12]
1453:C:/StellarisWare/driverlib\can.c ****             CANRegWrite(ulBase + CAN_O_STS,
 1446              		.loc 1 1453 0
 1447 0036 7B68     		ldr	r3, [r7, #4]
 1448 0038 03F10403 		add	r3, r3, #4
 1449 003c 1846     		mov	r0, r3
 1450 003e 6FF01F01 		mvn	r1, #31
 1451 0042 FFF7FEFF 		bl	CANRegWrite
1454:C:/StellarisWare/driverlib\can.c ****                         ~(CAN_STS_RXOK | CAN_STS_TXOK | CAN_STS_LEC_M));
1455:C:/StellarisWare/driverlib\can.c ****             break;
 1452              		.loc 1 1455 0
 1453 0046 3FE0     		b	.L75
 1454              	.L71:
1456:C:/StellarisWare/driverlib\can.c ****         }
1457:C:/StellarisWare/driverlib\can.c **** 
1458:C:/StellarisWare/driverlib\can.c ****         //
1459:C:/StellarisWare/driverlib\can.c ****         // Combine the Transmit status bits into one 32bit value.
1460:C:/StellarisWare/driverlib\can.c ****         //
1461:C:/StellarisWare/driverlib\can.c ****         case CAN_STS_TXREQUEST:
1462:C:/StellarisWare/driverlib\can.c ****         {
1463:C:/StellarisWare/driverlib\can.c ****             ulStatus = CANRegRead(ulBase + CAN_O_TXRQ1);
 1455              		.loc 1 1463 0
 1456 0048 7B68     		ldr	r3, [r7, #4]
 1457 004a 03F58073 		add	r3, r3, #256
 1458 004e 1846     		mov	r0, r3
 1459 0050 FFF7FEFF 		bl	CANRegRead
 1460 0054 F860     		str	r0, [r7, #12]
1464:C:/StellarisWare/driverlib\can.c ****             ulStatus |= CANRegRead(ulBase + CAN_O_TXRQ2) << 16;
 1461              		.loc 1 1464 0
 1462 0056 7B68     		ldr	r3, [r7, #4]
 1463 0058 03F58273 		add	r3, r3, #260
 1464 005c 1846     		mov	r0, r3
 1465 005e FFF7FEFF 		bl	CANRegRead
 1466 0062 0346     		mov	r3, r0
 1467 0064 4FEA0343 		lsl	r3, r3, #16
 1468 0068 FA68     		ldr	r2, [r7, #12]
 1469 006a 1343     		orrs	r3, r3, r2
 1470 006c FB60     		str	r3, [r7, #12]
1465:C:/StellarisWare/driverlib\can.c ****             break;
 1471              		.loc 1 1465 0
 1472 006e 2BE0     		b	.L75
 1473              	.L72:
1466:C:/StellarisWare/driverlib\can.c ****         }
1467:C:/StellarisWare/driverlib\can.c **** 
1468:C:/StellarisWare/driverlib\can.c ****         //
1469:C:/StellarisWare/driverlib\can.c ****         // Combine the New Data status bits into one 32bit value.
1470:C:/StellarisWare/driverlib\can.c ****         //
1471:C:/StellarisWare/driverlib\can.c ****         case CAN_STS_NEWDAT:
1472:C:/StellarisWare/driverlib\can.c ****         {
1473:C:/StellarisWare/driverlib\can.c ****             ulStatus = CANRegRead(ulBase + CAN_O_NWDA1);
 1474              		.loc 1 1473 0
 1475 0070 7B68     		ldr	r3, [r7, #4]
 1476 0072 03F59073 		add	r3, r3, #288
 1477 0076 1846     		mov	r0, r3
 1478 0078 FFF7FEFF 		bl	CANRegRead
 1479 007c F860     		str	r0, [r7, #12]
1474:C:/StellarisWare/driverlib\can.c ****             ulStatus |= CANRegRead(ulBase + CAN_O_NWDA2) << 16;
 1480              		.loc 1 1474 0
 1481 007e 7B68     		ldr	r3, [r7, #4]
 1482 0080 03F59273 		add	r3, r3, #292
 1483 0084 1846     		mov	r0, r3
 1484 0086 FFF7FEFF 		bl	CANRegRead
 1485 008a 0346     		mov	r3, r0
 1486 008c 4FEA0343 		lsl	r3, r3, #16
 1487 0090 FA68     		ldr	r2, [r7, #12]
 1488 0092 1343     		orrs	r3, r3, r2
 1489 0094 FB60     		str	r3, [r7, #12]
1475:C:/StellarisWare/driverlib\can.c ****             break;
 1490              		.loc 1 1475 0
 1491 0096 17E0     		b	.L75
 1492              	.L73:
1476:C:/StellarisWare/driverlib\can.c ****         }
1477:C:/StellarisWare/driverlib\can.c **** 
1478:C:/StellarisWare/driverlib\can.c ****         //
1479:C:/StellarisWare/driverlib\can.c ****         // Combine the Message valid status bits into one 32bit value.
1480:C:/StellarisWare/driverlib\can.c ****         //
1481:C:/StellarisWare/driverlib\can.c ****         case CAN_STS_MSGVAL:
1482:C:/StellarisWare/driverlib\can.c ****         {
1483:C:/StellarisWare/driverlib\can.c ****             ulStatus = CANRegRead(ulBase + CAN_O_MSG1VAL);
 1493              		.loc 1 1483 0
 1494 0098 7B68     		ldr	r3, [r7, #4]
 1495 009a 03F5B073 		add	r3, r3, #352
 1496 009e 1846     		mov	r0, r3
 1497 00a0 FFF7FEFF 		bl	CANRegRead
 1498 00a4 F860     		str	r0, [r7, #12]
1484:C:/StellarisWare/driverlib\can.c ****             ulStatus |= CANRegRead(ulBase + CAN_O_MSG2VAL) << 16;
 1499              		.loc 1 1484 0
 1500 00a6 7B68     		ldr	r3, [r7, #4]
 1501 00a8 03F5B273 		add	r3, r3, #356
 1502 00ac 1846     		mov	r0, r3
 1503 00ae FFF7FEFF 		bl	CANRegRead
 1504 00b2 0346     		mov	r3, r0
 1505 00b4 4FEA0343 		lsl	r3, r3, #16
 1506 00b8 FA68     		ldr	r2, [r7, #12]
 1507 00ba 1343     		orrs	r3, r3, r2
 1508 00bc FB60     		str	r3, [r7, #12]
1485:C:/StellarisWare/driverlib\can.c ****             break;
 1509              		.loc 1 1485 0
 1510 00be 03E0     		b	.L75
 1511              	.L69:
1486:C:/StellarisWare/driverlib\can.c ****         }
1487:C:/StellarisWare/driverlib\can.c **** 
1488:C:/StellarisWare/driverlib\can.c ****         //
1489:C:/StellarisWare/driverlib\can.c ****         // Unknown CAN status requested so return 0.
1490:C:/StellarisWare/driverlib\can.c ****         //
1491:C:/StellarisWare/driverlib\can.c ****         default:
1492:C:/StellarisWare/driverlib\can.c ****         {
1493:C:/StellarisWare/driverlib\can.c ****             ulStatus = 0;
 1512              		.loc 1 1493 0
 1513 00c0 4FF00003 		mov	r3, #0
 1514 00c4 FB60     		str	r3, [r7, #12]
1494:C:/StellarisWare/driverlib\can.c ****             break;
 1515              		.loc 1 1494 0
 1516 00c6 00BF     		nop
 1517              	.L75:
1495:C:/StellarisWare/driverlib\can.c ****         }
1496:C:/StellarisWare/driverlib\can.c ****     }
1497:C:/StellarisWare/driverlib\can.c ****     return(ulStatus);
 1518              		.loc 1 1497 0
 1519 00c8 FB68     		ldr	r3, [r7, #12]
1498:C:/StellarisWare/driverlib\can.c **** }
 1520              		.loc 1 1498 0
 1521 00ca 1846     		mov	r0, r3
 1522 00cc 07F11007 		add	r7, r7, #16
 1523 00d0 BD46     		mov	sp, r7
 1524 00d2 80BD     		pop	{r7, pc}
 1525              		.cfi_endproc
 1526              	.LFE19:
 1528              		.section	.text.CANErrCntrGet,"ax",%progbits
 1529              		.align	2
 1530              		.global	CANErrCntrGet
 1531              		.thumb
 1532              		.thumb_func
 1534              	CANErrCntrGet:
 1535              	.LFB20:
1499:C:/StellarisWare/driverlib\can.c **** 
1500:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1501:C:/StellarisWare/driverlib\can.c **** //
1502:C:/StellarisWare/driverlib\can.c **** //! Reads the CAN controller error counter register.
1503:C:/StellarisWare/driverlib\can.c **** //!
1504:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1505:C:/StellarisWare/driverlib\can.c **** //! \param pulRxCount is a pointer to storage for the receive error counter.
1506:C:/StellarisWare/driverlib\can.c **** //! \param pulTxCount is a pointer to storage for the transmit error counter.
1507:C:/StellarisWare/driverlib\can.c **** //!
1508:C:/StellarisWare/driverlib\can.c **** //! This function reads the error counter register and returns the transmit and
1509:C:/StellarisWare/driverlib\can.c **** //! receive error counts to the caller along with a flag indicating if the
1510:C:/StellarisWare/driverlib\can.c **** //! controller receive counter has reached the error passive limit.  The values
1511:C:/StellarisWare/driverlib\can.c **** //! of the receive and transmit error counters are returned through the
1512:C:/StellarisWare/driverlib\can.c **** //! pointers provided as parameters.
1513:C:/StellarisWare/driverlib\can.c **** //!
1514:C:/StellarisWare/driverlib\can.c **** //! After this call, \e *pulRxCount holds the current receive error count
1515:C:/StellarisWare/driverlib\can.c **** //! and \e *pulTxCount holds the current transmit error count.
1516:C:/StellarisWare/driverlib\can.c **** //!
1517:C:/StellarisWare/driverlib\can.c **** //! \return Returns \b true if the receive error count has reached the error
1518:C:/StellarisWare/driverlib\can.c **** //! passive limit, and \b false if the error count is below the error passive
1519:C:/StellarisWare/driverlib\can.c **** //! limit.
1520:C:/StellarisWare/driverlib\can.c **** //
1521:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1522:C:/StellarisWare/driverlib\can.c **** tBoolean
1523:C:/StellarisWare/driverlib\can.c **** CANErrCntrGet(unsigned long ulBase, unsigned long *pulRxCount,
1524:C:/StellarisWare/driverlib\can.c ****               unsigned long *pulTxCount)
1525:C:/StellarisWare/driverlib\can.c **** {
 1536              		.loc 1 1525 0
 1537              		.cfi_startproc
 1538              		@ args = 0, pretend = 0, frame = 24
 1539              		@ frame_needed = 1, uses_anonymous_args = 0
 1540 0000 80B5     		push	{r7, lr}
 1541              	.LCFI60:
 1542              		.cfi_def_cfa_offset 8
 1543              		.cfi_offset 14, -4
 1544              		.cfi_offset 7, -8
 1545 0002 86B0     		sub	sp, sp, #24
 1546              	.LCFI61:
 1547              		.cfi_def_cfa_offset 32
 1548 0004 00AF     		add	r7, sp, #0
 1549              	.LCFI62:
 1550              		.cfi_def_cfa_register 7
 1551 0006 F860     		str	r0, [r7, #12]
 1552 0008 B960     		str	r1, [r7, #8]
 1553 000a 7A60     		str	r2, [r7, #4]
1526:C:/StellarisWare/driverlib\can.c ****     unsigned long ulCANError;
1527:C:/StellarisWare/driverlib\can.c **** 
1528:C:/StellarisWare/driverlib\can.c ****     //
1529:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1530:C:/StellarisWare/driverlib\can.c ****     //
1531:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1532:C:/StellarisWare/driverlib\can.c **** 
1533:C:/StellarisWare/driverlib\can.c ****     //
1534:C:/StellarisWare/driverlib\can.c ****     // Read the current count of transmit/receive errors.
1535:C:/StellarisWare/driverlib\can.c ****     //
1536:C:/StellarisWare/driverlib\can.c ****     ulCANError = CANRegRead(ulBase + CAN_O_ERR);
 1554              		.loc 1 1536 0
 1555 000c FB68     		ldr	r3, [r7, #12]
 1556 000e 03F10803 		add	r3, r3, #8
 1557 0012 1846     		mov	r0, r3
 1558 0014 FFF7FEFF 		bl	CANRegRead
 1559 0018 7861     		str	r0, [r7, #20]
1537:C:/StellarisWare/driverlib\can.c **** 
1538:C:/StellarisWare/driverlib\can.c ****     //
1539:C:/StellarisWare/driverlib\can.c ****     // Extract the error numbers from the register value.
1540:C:/StellarisWare/driverlib\can.c ****     //
1541:C:/StellarisWare/driverlib\can.c ****     *pulRxCount = (ulCANError & CAN_ERR_REC_M) >> CAN_ERR_REC_S;
 1560              		.loc 1 1541 0
 1561 001a 7B69     		ldr	r3, [r7, #20]
 1562 001c 03F4FE43 		and	r3, r3, #32512
 1563 0020 4FEA1322 		lsr	r2, r3, #8
 1564 0024 BB68     		ldr	r3, [r7, #8]
 1565 0026 1A60     		str	r2, [r3, #0]
1542:C:/StellarisWare/driverlib\can.c ****     *pulTxCount = (ulCANError & CAN_ERR_TEC_M) >> CAN_ERR_TEC_S;
 1566              		.loc 1 1542 0
 1567 0028 7B69     		ldr	r3, [r7, #20]
 1568 002a DAB2     		uxtb	r2, r3
 1569 002c 7B68     		ldr	r3, [r7, #4]
 1570 002e 1A60     		str	r2, [r3, #0]
1543:C:/StellarisWare/driverlib\can.c **** 
1544:C:/StellarisWare/driverlib\can.c ****     if(ulCANError & CAN_ERR_RP)
 1571              		.loc 1 1544 0
 1572 0030 7B69     		ldr	r3, [r7, #20]
 1573 0032 03F40043 		and	r3, r3, #32768
 1574 0036 002B     		cmp	r3, #0
 1575 0038 02D0     		beq	.L77
1545:C:/StellarisWare/driverlib\can.c ****     {
1546:C:/StellarisWare/driverlib\can.c ****         return(true);
 1576              		.loc 1 1546 0
 1577 003a 4FF00103 		mov	r3, #1
 1578 003e 01E0     		b	.L78
 1579              	.L77:
1547:C:/StellarisWare/driverlib\can.c ****     }
1548:C:/StellarisWare/driverlib\can.c ****     return(false);
 1580              		.loc 1 1548 0
 1581 0040 4FF00003 		mov	r3, #0
 1582              	.L78:
1549:C:/StellarisWare/driverlib\can.c **** }
 1583              		.loc 1 1549 0
 1584 0044 1846     		mov	r0, r3
 1585 0046 07F11807 		add	r7, r7, #24
 1586 004a BD46     		mov	sp, r7
 1587 004c 80BD     		pop	{r7, pc}
 1588              		.cfi_endproc
 1589              	.LFE20:
 1591 004e 00BF     		.section	.text.CANMessageSet,"ax",%progbits
 1592              		.align	2
 1593              		.global	CANMessageSet
 1594              		.thumb
 1595              		.thumb_func
 1597              	CANMessageSet:
 1598              	.LFB21:
1550:C:/StellarisWare/driverlib\can.c **** 
1551:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1552:C:/StellarisWare/driverlib\can.c **** //
1553:C:/StellarisWare/driverlib\can.c **** //! Configures a message object in the CAN controller.
1554:C:/StellarisWare/driverlib\can.c **** //!
1555:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1556:C:/StellarisWare/driverlib\can.c **** //! \param ulObjID is the object number to configure (1-32).
1557:C:/StellarisWare/driverlib\can.c **** //! \param pMsgObject is a pointer to a structure containing message object
1558:C:/StellarisWare/driverlib\can.c **** //! settings.
1559:C:/StellarisWare/driverlib\can.c **** //! \param eMsgType indicates the type of message for this object.
1560:C:/StellarisWare/driverlib\can.c **** //!
1561:C:/StellarisWare/driverlib\can.c **** //! This function is used to configure any one of the 32 message objects in the
1562:C:/StellarisWare/driverlib\can.c **** //! CAN controller.  A message object can be configured to be any type of CAN
1563:C:/StellarisWare/driverlib\can.c **** //! message object as well as to use automatic transmission and reception.
1564:C:/StellarisWare/driverlib\can.c **** //! This call also allows the message object to be configured to generate
1565:C:/StellarisWare/driverlib\can.c **** //! interrupts on completion of message receipt or transmission.  The
1566:C:/StellarisWare/driverlib\can.c **** //! message object can also be configured with a filter/mask so that actions
1567:C:/StellarisWare/driverlib\can.c **** //! are only taken when a message that meets certain parameters is seen on the
1568:C:/StellarisWare/driverlib\can.c **** //! CAN bus.
1569:C:/StellarisWare/driverlib\can.c **** //!
1570:C:/StellarisWare/driverlib\can.c **** //! The \e eMsgType parameter must be one of the following values:
1571:C:/StellarisWare/driverlib\can.c **** //!
1572:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_TYPE_TX - CAN transmit message object.
1573:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_TYPE_TX_REMOTE - CAN transmit remote request message object.
1574:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_TYPE_RX - CAN receive message object.
1575:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_TYPE_RX_REMOTE - CAN receive remote request message object.
1576:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_TYPE_RXTX_REMOTE - CAN remote frame receive remote, then
1577:C:/StellarisWare/driverlib\can.c **** //! transmit message object.
1578:C:/StellarisWare/driverlib\can.c **** //!
1579:C:/StellarisWare/driverlib\can.c **** //! The message object pointed to by \e pMsgObject must be populated by the
1580:C:/StellarisWare/driverlib\can.c **** //! caller, as follows:
1581:C:/StellarisWare/driverlib\can.c **** //!
1582:C:/StellarisWare/driverlib\can.c **** //! - \e ulMsgID - contains the message ID, either 11 or 29 bits.
1583:C:/StellarisWare/driverlib\can.c **** //! - \e ulMsgIDMask - mask of bits from \e ulMsgID that must match if
1584:C:/StellarisWare/driverlib\can.c **** //! identifier filtering is enabled.
1585:C:/StellarisWare/driverlib\can.c **** //! - \e ulFlags
1586:C:/StellarisWare/driverlib\can.c **** //!   - Set \b MSG_OBJ_TX_INT_ENABLE flag to enable interrupt on transmission.
1587:C:/StellarisWare/driverlib\can.c **** //!   - Set \b MSG_OBJ_RX_INT_ENABLE flag to enable interrupt on receipt.
1588:C:/StellarisWare/driverlib\can.c **** //!   - Set \b MSG_OBJ_USE_ID_FILTER flag to enable filtering based on the
1589:C:/StellarisWare/driverlib\can.c **** //!   identifier mask specified by \e ulMsgIDMask.
1590:C:/StellarisWare/driverlib\can.c **** //! - \e ulMsgLen - the number of bytes in the message data.  This parameter
1591:C:/StellarisWare/driverlib\can.c **** //! should be non-zero even for a remote frame; it should match the expected
1592:C:/StellarisWare/driverlib\can.c **** //! bytes of data in the responding data frame.
1593:C:/StellarisWare/driverlib\can.c **** //! - \e pucMsgData - points to a buffer containing up to 8 bytes of data for a
1594:C:/StellarisWare/driverlib\can.c **** //! data frame.
1595:C:/StellarisWare/driverlib\can.c **** //!
1596:C:/StellarisWare/driverlib\can.c **** //! \b Example: To send a data frame or remote frame (in response to a remote
1597:C:/StellarisWare/driverlib\can.c **** //! request), take the following steps:
1598:C:/StellarisWare/driverlib\can.c **** //!
1599:C:/StellarisWare/driverlib\can.c **** //! -# Set \e eMsgType to \b MSG_OBJ_TYPE_TX.
1600:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulMsgID to the message ID.
1601:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulFlags. Make sure to set \b MSG_OBJ_TX_INT_ENABLE to
1602:C:/StellarisWare/driverlib\can.c **** //! allow an interrupt to be generated when the message is sent.
1603:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulMsgLen to the number of bytes in the data frame.
1604:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->pucMsgData to point to an array containing the bytes
1605:C:/StellarisWare/driverlib\can.c **** //! to send in the message.
1606:C:/StellarisWare/driverlib\can.c **** //! -# Call this function with \e ulObjID set to one of the 32 object buffers.
1607:C:/StellarisWare/driverlib\can.c **** //!
1608:C:/StellarisWare/driverlib\can.c **** //! \b Example: To receive a specific data frame, take the following steps:
1609:C:/StellarisWare/driverlib\can.c **** //!
1610:C:/StellarisWare/driverlib\can.c **** //! -# Set \e eMsgObjType to \b MSG_OBJ_TYPE_RX.
1611:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulMsgID to the full message ID, or a partial mask to
1612:C:/StellarisWare/driverlib\can.c **** //! use partial ID matching.
1613:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulMsgIDMask bits that should be used for masking
1614:C:/StellarisWare/driverlib\can.c **** //! during comparison.
1615:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulFlags as follows:
1616:C:/StellarisWare/driverlib\can.c **** //!   - Set \b MSG_OBJ_RX_INT_ENABLE flag to be interrupted when the data frame
1617:C:/StellarisWare/driverlib\can.c **** //!   is received.
1618:C:/StellarisWare/driverlib\can.c **** //!   - Set \b MSG_OBJ_USE_ID_FILTER flag to enable identifier-based filtering.
1619:C:/StellarisWare/driverlib\can.c **** //! -# Set \e pMsgObject->ulMsgLen to the number of bytes in the expected data
1620:C:/StellarisWare/driverlib\can.c **** //! frame.
1621:C:/StellarisWare/driverlib\can.c **** //! -# The buffer pointed to by \e pMsgObject->pucMsgData is not used by this
1622:C:/StellarisWare/driverlib\can.c **** //! call as no data is present at the time of the call.
1623:C:/StellarisWare/driverlib\can.c **** //! -# Call this function with \e ulObjID set to one of the 32 object buffers.
1624:C:/StellarisWare/driverlib\can.c **** //!
1625:C:/StellarisWare/driverlib\can.c **** //! If you specify a message object buffer that already contains a message
1626:C:/StellarisWare/driverlib\can.c **** //! definition, it is overwritten.
1627:C:/StellarisWare/driverlib\can.c **** //!
1628:C:/StellarisWare/driverlib\can.c **** //! \return None.
1629:C:/StellarisWare/driverlib\can.c **** //
1630:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1631:C:/StellarisWare/driverlib\can.c **** void
1632:C:/StellarisWare/driverlib\can.c **** CANMessageSet(unsigned long ulBase, unsigned long ulObjID,
1633:C:/StellarisWare/driverlib\can.c ****               tCANMsgObject *pMsgObject, tMsgObjType eMsgType)
1634:C:/StellarisWare/driverlib\can.c **** {
 1599              		.loc 1 1634 0
 1600              		.cfi_startproc
 1601              		@ args = 0, pretend = 0, frame = 32
 1602              		@ frame_needed = 1, uses_anonymous_args = 0
 1603 0000 80B5     		push	{r7, lr}
 1604              	.LCFI63:
 1605              		.cfi_def_cfa_offset 8
 1606              		.cfi_offset 14, -4
 1607              		.cfi_offset 7, -8
 1608 0002 88B0     		sub	sp, sp, #32
 1609              	.LCFI64:
 1610              		.cfi_def_cfa_offset 40
 1611 0004 00AF     		add	r7, sp, #0
 1612              	.LCFI65:
 1613              		.cfi_def_cfa_register 7
 1614 0006 F860     		str	r0, [r7, #12]
 1615 0008 B960     		str	r1, [r7, #8]
 1616 000a 7A60     		str	r2, [r7, #4]
 1617 000c FB70     		strb	r3, [r7, #3]
1635:C:/StellarisWare/driverlib\can.c ****     unsigned short usCmdMaskReg;
1636:C:/StellarisWare/driverlib\can.c ****     unsigned short usMaskReg0, usMaskReg1;
1637:C:/StellarisWare/driverlib\can.c ****     unsigned short usArbReg0, usArbReg1;
1638:C:/StellarisWare/driverlib\can.c ****     unsigned short usMsgCtrl;
1639:C:/StellarisWare/driverlib\can.c ****     tBoolean bTransferData;
1640:C:/StellarisWare/driverlib\can.c ****     tBoolean bUseExtendedID;
1641:C:/StellarisWare/driverlib\can.c **** 
1642:C:/StellarisWare/driverlib\can.c ****     bTransferData = 0;
 1618              		.loc 1 1642 0
 1619 000e 4FF00003 		mov	r3, #0
 1620 0012 FB74     		strb	r3, [r7, #19]
1643:C:/StellarisWare/driverlib\can.c **** 
1644:C:/StellarisWare/driverlib\can.c ****     //
1645:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
1646:C:/StellarisWare/driverlib\can.c ****     //
1647:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
1648:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulObjID <= 32) && (ulObjID != 0));
1649:C:/StellarisWare/driverlib\can.c ****     ASSERT((eMsgType == MSG_OBJ_TYPE_TX) ||
1650:C:/StellarisWare/driverlib\can.c ****            (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) ||
1651:C:/StellarisWare/driverlib\can.c ****            (eMsgType == MSG_OBJ_TYPE_RX) ||
1652:C:/StellarisWare/driverlib\can.c ****            (eMsgType == MSG_OBJ_TYPE_RX_REMOTE) ||
1653:C:/StellarisWare/driverlib\can.c ****            (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) ||
1654:C:/StellarisWare/driverlib\can.c ****            (eMsgType == MSG_OBJ_TYPE_RXTX_REMOTE));
1655:C:/StellarisWare/driverlib\can.c **** 
1656:C:/StellarisWare/driverlib\can.c ****     //
1657:C:/StellarisWare/driverlib\can.c ****     // Wait for busy bit to clear
1658:C:/StellarisWare/driverlib\can.c ****     //
1659:C:/StellarisWare/driverlib\can.c ****     while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 1621              		.loc 1 1659 0
 1622 0014 00BF     		nop
 1623              	.L80:
 1624              		.loc 1 1659 0 is_stmt 0 discriminator 1
 1625 0016 FB68     		ldr	r3, [r7, #12]
 1626 0018 03F12003 		add	r3, r3, #32
 1627 001c 1846     		mov	r0, r3
 1628 001e FFF7FEFF 		bl	CANRegRead
 1629 0022 0346     		mov	r3, r0
 1630 0024 03F40043 		and	r3, r3, #32768
 1631 0028 002B     		cmp	r3, #0
 1632 002a F4D1     		bne	.L80
1660:C:/StellarisWare/driverlib\can.c ****     {
1661:C:/StellarisWare/driverlib\can.c ****     }
1662:C:/StellarisWare/driverlib\can.c **** 
1663:C:/StellarisWare/driverlib\can.c ****     //
1664:C:/StellarisWare/driverlib\can.c ****     // See if we need to use an extended identifier or not.
1665:C:/StellarisWare/driverlib\can.c ****     //
1666:C:/StellarisWare/driverlib\can.c ****     if((pMsgObject->ulMsgID > CAN_MAX_11BIT_MSG_ID) ||
 1633              		.loc 1 1666 0 is_stmt 1
 1634 002c 7B68     		ldr	r3, [r7, #4]
 1635 002e 1A68     		ldr	r2, [r3, #0]
 1636 0030 40F2FF73 		movw	r3, #2047
 1637 0034 9A42     		cmp	r2, r3
 1638 0036 05D8     		bhi	.L81
1667:C:/StellarisWare/driverlib\can.c ****        (pMsgObject->ulFlags & MSG_OBJ_EXTENDED_ID))
 1639              		.loc 1 1667 0 discriminator 1
 1640 0038 7B68     		ldr	r3, [r7, #4]
 1641 003a 9B68     		ldr	r3, [r3, #8]
 1642 003c 03F00403 		and	r3, r3, #4
1666:C:/StellarisWare/driverlib\can.c ****     if((pMsgObject->ulMsgID > CAN_MAX_11BIT_MSG_ID) ||
 1643              		.loc 1 1666 0 discriminator 1
 1644 0040 002B     		cmp	r3, #0
 1645 0042 03D0     		beq	.L82
 1646              	.L81:
1668:C:/StellarisWare/driverlib\can.c ****     {
1669:C:/StellarisWare/driverlib\can.c ****         bUseExtendedID = 1;
 1647              		.loc 1 1669 0
 1648 0044 4FF00103 		mov	r3, #1
 1649 0048 BB74     		strb	r3, [r7, #18]
 1650 004a 02E0     		b	.L83
 1651              	.L82:
1670:C:/StellarisWare/driverlib\can.c ****     }
1671:C:/StellarisWare/driverlib\can.c ****     else
1672:C:/StellarisWare/driverlib\can.c ****     {
1673:C:/StellarisWare/driverlib\can.c ****         bUseExtendedID = 0;
 1652              		.loc 1 1673 0
 1653 004c 4FF00003 		mov	r3, #0
 1654 0050 BB74     		strb	r3, [r7, #18]
 1655              	.L83:
1674:C:/StellarisWare/driverlib\can.c ****     }
1675:C:/StellarisWare/driverlib\can.c **** 
1676:C:/StellarisWare/driverlib\can.c ****     //
1677:C:/StellarisWare/driverlib\can.c ****     // This is always a write to the Message object as this call is setting a
1678:C:/StellarisWare/driverlib\can.c ****     // message object.  This call will also always set all size bits so it sets
1679:C:/StellarisWare/driverlib\can.c ****     // both data bits.  The call will use the CONTROL register to set control
1680:C:/StellarisWare/driverlib\can.c ****     // bits so this bit needs to be set as well.
1681:C:/StellarisWare/driverlib\can.c ****     //
1682:C:/StellarisWare/driverlib\can.c ****     usCmdMaskReg = (CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_DATAA | CAN_IF1CMSK_DATAB |
 1656              		.loc 1 1682 0
 1657 0052 4FF09303 		mov	r3, #147
 1658 0056 FB83     		strh	r3, [r7, #30]	@ movhi
1683:C:/StellarisWare/driverlib\can.c ****                     CAN_IF1CMSK_CONTROL);
1684:C:/StellarisWare/driverlib\can.c **** 
1685:C:/StellarisWare/driverlib\can.c ****     //
1686:C:/StellarisWare/driverlib\can.c ****     // Initialize the values to a known state before filling them in based on
1687:C:/StellarisWare/driverlib\can.c ****     // the type of message object that is being configured.
1688:C:/StellarisWare/driverlib\can.c ****     //
1689:C:/StellarisWare/driverlib\can.c ****     usArbReg0 = 0;
 1659              		.loc 1 1689 0
 1660 0058 4FF00003 		mov	r3, #0
 1661 005c 3B83     		strh	r3, [r7, #24]	@ movhi
1690:C:/StellarisWare/driverlib\can.c ****     usArbReg1 = 0;
 1662              		.loc 1 1690 0
 1663 005e 4FF00003 		mov	r3, #0
 1664 0062 FB82     		strh	r3, [r7, #22]	@ movhi
1691:C:/StellarisWare/driverlib\can.c ****     usMsgCtrl = 0;
 1665              		.loc 1 1691 0
 1666 0064 4FF00003 		mov	r3, #0
 1667 0068 BB82     		strh	r3, [r7, #20]	@ movhi
1692:C:/StellarisWare/driverlib\can.c ****     usMaskReg0 = 0;
 1668              		.loc 1 1692 0
 1669 006a 4FF00003 		mov	r3, #0
 1670 006e BB83     		strh	r3, [r7, #28]	@ movhi
1693:C:/StellarisWare/driverlib\can.c ****     usMaskReg1 = 0;
 1671              		.loc 1 1693 0
 1672 0070 4FF00003 		mov	r3, #0
 1673 0074 7B83     		strh	r3, [r7, #26]	@ movhi
1694:C:/StellarisWare/driverlib\can.c **** 
1695:C:/StellarisWare/driverlib\can.c ****     switch(eMsgType)
 1674              		.loc 1 1695 0
 1675 0076 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1676 0078 042B     		cmp	r3, #4
 1677 007a 00F23081 		bhi	.L104
 1678 007e 01A2     		adr	r2, .L90
 1679 0080 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1680              		.align	2
 1681              	.L90:
 1682 0084 99000000 		.word	.L85+1
 1683 0088 AF000000 		.word	.L86+1
 1684 008c BF000000 		.word	.L87+1
 1685 0090 C7000000 		.word	.L88+1
 1686 0094 E9000000 		.word	.L89+1
 1687              	.L85:
1696:C:/StellarisWare/driverlib\can.c ****     {
1697:C:/StellarisWare/driverlib\can.c ****         //
1698:C:/StellarisWare/driverlib\can.c ****         // Transmit message object.
1699:C:/StellarisWare/driverlib\can.c ****         //
1700:C:/StellarisWare/driverlib\can.c ****         case MSG_OBJ_TYPE_TX:
1701:C:/StellarisWare/driverlib\can.c ****         {
1702:C:/StellarisWare/driverlib\can.c ****             //
1703:C:/StellarisWare/driverlib\can.c ****             // Set the TXRQST bit and the reset the rest of the register.
1704:C:/StellarisWare/driverlib\can.c ****             //
1705:C:/StellarisWare/driverlib\can.c ****             usMsgCtrl |= CAN_IF1MCTL_TXRQST;
 1688              		.loc 1 1705 0
 1689 0098 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1690 009a 43F48073 		orr	r3, r3, #256
 1691 009e BB82     		strh	r3, [r7, #20]	@ movhi
1706:C:/StellarisWare/driverlib\can.c ****             usArbReg1 = CAN_IF1ARB2_DIR;
 1692              		.loc 1 1706 0
 1693 00a0 4FF40053 		mov	r3, #8192
 1694 00a4 FB82     		strh	r3, [r7, #22]	@ movhi
1707:C:/StellarisWare/driverlib\can.c ****             bTransferData = 1;
 1695              		.loc 1 1707 0
 1696 00a6 4FF00103 		mov	r3, #1
 1697 00aa FB74     		strb	r3, [r7, #19]
1708:C:/StellarisWare/driverlib\can.c ****             break;
 1698              		.loc 1 1708 0
 1699 00ac 26E0     		b	.L91
 1700              	.L86:
1709:C:/StellarisWare/driverlib\can.c ****         }
1710:C:/StellarisWare/driverlib\can.c **** 
1711:C:/StellarisWare/driverlib\can.c ****         //
1712:C:/StellarisWare/driverlib\can.c ****         // Transmit remote request message object
1713:C:/StellarisWare/driverlib\can.c ****         //
1714:C:/StellarisWare/driverlib\can.c ****         case MSG_OBJ_TYPE_TX_REMOTE:
1715:C:/StellarisWare/driverlib\can.c ****         {
1716:C:/StellarisWare/driverlib\can.c ****             //
1717:C:/StellarisWare/driverlib\can.c ****             // Set the TXRQST bit and the reset the rest of the register.
1718:C:/StellarisWare/driverlib\can.c ****             //
1719:C:/StellarisWare/driverlib\can.c ****             usMsgCtrl |= CAN_IF1MCTL_TXRQST;
 1701              		.loc 1 1719 0
 1702 00ae BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1703 00b0 43F48073 		orr	r3, r3, #256
 1704 00b4 BB82     		strh	r3, [r7, #20]	@ movhi
1720:C:/StellarisWare/driverlib\can.c ****             usArbReg1 = 0;
 1705              		.loc 1 1720 0
 1706 00b6 4FF00003 		mov	r3, #0
 1707 00ba FB82     		strh	r3, [r7, #22]	@ movhi
1721:C:/StellarisWare/driverlib\can.c ****             break;
 1708              		.loc 1 1721 0
 1709 00bc 1EE0     		b	.L91
 1710              	.L87:
1722:C:/StellarisWare/driverlib\can.c ****         }
1723:C:/StellarisWare/driverlib\can.c **** 
1724:C:/StellarisWare/driverlib\can.c ****         //
1725:C:/StellarisWare/driverlib\can.c ****         // Receive message object.
1726:C:/StellarisWare/driverlib\can.c ****         //
1727:C:/StellarisWare/driverlib\can.c ****         case MSG_OBJ_TYPE_RX:
1728:C:/StellarisWare/driverlib\can.c ****         {
1729:C:/StellarisWare/driverlib\can.c ****             //
1730:C:/StellarisWare/driverlib\can.c ****             // This clears the DIR bit along with everything else.  The TXRQST
1731:C:/StellarisWare/driverlib\can.c ****             // bit was cleared by defaulting usMsgCtrl to 0.
1732:C:/StellarisWare/driverlib\can.c ****             //
1733:C:/StellarisWare/driverlib\can.c ****             usArbReg1 = 0;
 1711              		.loc 1 1733 0
 1712 00be 4FF00003 		mov	r3, #0
 1713 00c2 FB82     		strh	r3, [r7, #22]	@ movhi
1734:C:/StellarisWare/driverlib\can.c ****             break;
 1714              		.loc 1 1734 0
 1715 00c4 1AE0     		b	.L91
 1716              	.L88:
1735:C:/StellarisWare/driverlib\can.c ****         }
1736:C:/StellarisWare/driverlib\can.c **** 
1737:C:/StellarisWare/driverlib\can.c ****         //
1738:C:/StellarisWare/driverlib\can.c ****         // Receive remote request message object.
1739:C:/StellarisWare/driverlib\can.c ****         //
1740:C:/StellarisWare/driverlib\can.c ****         case MSG_OBJ_TYPE_RX_REMOTE:
1741:C:/StellarisWare/driverlib\can.c ****         {
1742:C:/StellarisWare/driverlib\can.c ****             //
1743:C:/StellarisWare/driverlib\can.c ****             // The DIR bit is set to one for remote receivers.  The TXRQST bit
1744:C:/StellarisWare/driverlib\can.c ****             // was cleared by defaulting usMsgCtrl to 0.
1745:C:/StellarisWare/driverlib\can.c ****             //
1746:C:/StellarisWare/driverlib\can.c ****             usArbReg1 = CAN_IF1ARB2_DIR;
 1717              		.loc 1 1746 0
 1718 00c6 4FF40053 		mov	r3, #8192
 1719 00ca FB82     		strh	r3, [r7, #22]	@ movhi
1747:C:/StellarisWare/driverlib\can.c **** 
1748:C:/StellarisWare/driverlib\can.c ****             //
1749:C:/StellarisWare/driverlib\can.c ****             // Set this object so that it only indicates that a remote frame
1750:C:/StellarisWare/driverlib\can.c ****             // was received and allow for software to handle it by sending back
1751:C:/StellarisWare/driverlib\can.c ****             // a data frame.
1752:C:/StellarisWare/driverlib\can.c ****             //
1753:C:/StellarisWare/driverlib\can.c ****             usMsgCtrl = CAN_IF1MCTL_UMASK;
 1720              		.loc 1 1753 0
 1721 00cc 4FF48053 		mov	r3, #4096
 1722 00d0 BB82     		strh	r3, [r7, #20]	@ movhi
1754:C:/StellarisWare/driverlib\can.c **** 
1755:C:/StellarisWare/driverlib\can.c ****             //
1756:C:/StellarisWare/driverlib\can.c ****             // Use the full Identifier by default.
1757:C:/StellarisWare/driverlib\can.c ****             //
1758:C:/StellarisWare/driverlib\can.c ****             usMaskReg0 = 0xffff;
 1723              		.loc 1 1758 0
 1724 00d2 4FF6FF73 		movw	r3, #65535
 1725 00d6 BB83     		strh	r3, [r7, #28]	@ movhi
1759:C:/StellarisWare/driverlib\can.c ****             usMaskReg1 = 0x1fff;
 1726              		.loc 1 1759 0
 1727 00d8 41F6FF73 		movw	r3, #8191
 1728 00dc 7B83     		strh	r3, [r7, #26]	@ movhi
1760:C:/StellarisWare/driverlib\can.c **** 
1761:C:/StellarisWare/driverlib\can.c ****             //
1762:C:/StellarisWare/driverlib\can.c ****             // Make sure to send the mask to the message object.
1763:C:/StellarisWare/driverlib\can.c ****             //
1764:C:/StellarisWare/driverlib\can.c ****             usCmdMaskReg |= CAN_IF1CMSK_MASK;
 1729              		.loc 1 1764 0
 1730 00de FB8B     		ldrh	r3, [r7, #30]	@ movhi
 1731 00e0 43F04003 		orr	r3, r3, #64
 1732 00e4 FB83     		strh	r3, [r7, #30]	@ movhi
1765:C:/StellarisWare/driverlib\can.c ****             break;
 1733              		.loc 1 1765 0
 1734 00e6 09E0     		b	.L91
 1735              	.L89:
1766:C:/StellarisWare/driverlib\can.c ****         }
1767:C:/StellarisWare/driverlib\can.c **** 
1768:C:/StellarisWare/driverlib\can.c ****         //
1769:C:/StellarisWare/driverlib\can.c ****         // Remote frame receive remote, with auto-transmit message object.
1770:C:/StellarisWare/driverlib\can.c ****         //
1771:C:/StellarisWare/driverlib\can.c ****         case MSG_OBJ_TYPE_RXTX_REMOTE:
1772:C:/StellarisWare/driverlib\can.c ****         {
1773:C:/StellarisWare/driverlib\can.c ****             //
1774:C:/StellarisWare/driverlib\can.c ****             // Oddly the DIR bit is set to one for remote receivers.
1775:C:/StellarisWare/driverlib\can.c ****             //
1776:C:/StellarisWare/driverlib\can.c ****             usArbReg1 = CAN_IF1ARB2_DIR;
 1736              		.loc 1 1776 0
 1737 00e8 4FF40053 		mov	r3, #8192
 1738 00ec FB82     		strh	r3, [r7, #22]	@ movhi
1777:C:/StellarisWare/driverlib\can.c **** 
1778:C:/StellarisWare/driverlib\can.c ****             //
1779:C:/StellarisWare/driverlib\can.c ****             // Set this object to auto answer if a matching identifier is seen.
1780:C:/StellarisWare/driverlib\can.c ****             //
1781:C:/StellarisWare/driverlib\can.c ****             usMsgCtrl = CAN_IF1MCTL_RMTEN | CAN_IF1MCTL_UMASK;
 1739              		.loc 1 1781 0
 1740 00ee 4FF49053 		mov	r3, #4608
 1741 00f2 BB82     		strh	r3, [r7, #20]	@ movhi
1782:C:/StellarisWare/driverlib\can.c **** 
1783:C:/StellarisWare/driverlib\can.c ****             //
1784:C:/StellarisWare/driverlib\can.c ****             // The data to be returned needs to be filled in.
1785:C:/StellarisWare/driverlib\can.c ****             //
1786:C:/StellarisWare/driverlib\can.c ****             bTransferData = 1;
 1742              		.loc 1 1786 0
 1743 00f4 4FF00103 		mov	r3, #1
 1744 00f8 FB74     		strb	r3, [r7, #19]
1787:C:/StellarisWare/driverlib\can.c ****             break;
 1745              		.loc 1 1787 0
 1746 00fa 00BF     		nop
 1747              	.L91:
1788:C:/StellarisWare/driverlib\can.c ****         }
1789:C:/StellarisWare/driverlib\can.c **** 
1790:C:/StellarisWare/driverlib\can.c ****         //
1791:C:/StellarisWare/driverlib\can.c ****         // This case should never happen due to the ASSERT statement at the
1792:C:/StellarisWare/driverlib\can.c ****         // beginning of this function.
1793:C:/StellarisWare/driverlib\can.c ****         //
1794:C:/StellarisWare/driverlib\can.c ****         default:
1795:C:/StellarisWare/driverlib\can.c ****         {
1796:C:/StellarisWare/driverlib\can.c ****             return;
1797:C:/StellarisWare/driverlib\can.c ****         }
1798:C:/StellarisWare/driverlib\can.c ****     }
1799:C:/StellarisWare/driverlib\can.c **** 
1800:C:/StellarisWare/driverlib\can.c ****     //
1801:C:/StellarisWare/driverlib\can.c ****     // Configure the Mask Registers.
1802:C:/StellarisWare/driverlib\can.c ****     //
1803:C:/StellarisWare/driverlib\can.c ****     if(pMsgObject->ulFlags & MSG_OBJ_USE_ID_FILTER)
 1748              		.loc 1 1803 0
 1749 00fc 7B68     		ldr	r3, [r7, #4]
 1750 00fe 9B68     		ldr	r3, [r3, #8]
 1751 0100 03F00803 		and	r3, r3, #8
 1752 0104 002B     		cmp	r3, #0
 1753 0106 1ED0     		beq	.L93
1804:C:/StellarisWare/driverlib\can.c ****     {
1805:C:/StellarisWare/driverlib\can.c ****         if(bUseExtendedID)
 1754              		.loc 1 1805 0
 1755 0108 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
 1756 010a 002B     		cmp	r3, #0
 1757 010c 0DD0     		beq	.L94
1806:C:/StellarisWare/driverlib\can.c ****         {
1807:C:/StellarisWare/driverlib\can.c ****             //
1808:C:/StellarisWare/driverlib\can.c ****             // Set the 29 bits of Identifier mask that were requested.
1809:C:/StellarisWare/driverlib\can.c ****             //
1810:C:/StellarisWare/driverlib\can.c ****             usMaskReg0 = pMsgObject->ulMsgIDMask & CAN_IF1MSK1_IDMSK_M;
 1758              		.loc 1 1810 0
 1759 010e 7B68     		ldr	r3, [r7, #4]
 1760 0110 5B68     		ldr	r3, [r3, #4]
 1761 0112 BB83     		strh	r3, [r7, #28]	@ movhi
1811:C:/StellarisWare/driverlib\can.c ****             usMaskReg1 = ((pMsgObject->ulMsgIDMask >> 16) &
 1762              		.loc 1 1811 0
 1763 0114 7B68     		ldr	r3, [r7, #4]
 1764 0116 5B68     		ldr	r3, [r3, #4]
 1765 0118 4FEA1343 		lsr	r3, r3, #16
 1766 011c 9BB2     		uxth	r3, r3
 1767 011e 4FEAC343 		lsl	r3, r3, #19
 1768 0122 4FEAD343 		lsr	r3, r3, #19
 1769 0126 7B83     		strh	r3, [r7, #26]	@ movhi
 1770 0128 0DE0     		b	.L93
 1771              	.L94:
1812:C:/StellarisWare/driverlib\can.c ****                             CAN_IF1MSK2_IDMSK_M);
1813:C:/StellarisWare/driverlib\can.c ****         }
1814:C:/StellarisWare/driverlib\can.c ****         else
1815:C:/StellarisWare/driverlib\can.c ****         {
1816:C:/StellarisWare/driverlib\can.c ****             //
1817:C:/StellarisWare/driverlib\can.c ****             // Lower 16 bit are unused so set them to zero.
1818:C:/StellarisWare/driverlib\can.c ****             //
1819:C:/StellarisWare/driverlib\can.c ****             usMaskReg0 = 0;
 1772              		.loc 1 1819 0
 1773 012a 4FF00003 		mov	r3, #0
 1774 012e BB83     		strh	r3, [r7, #28]	@ movhi
1820:C:/StellarisWare/driverlib\can.c **** 
1821:C:/StellarisWare/driverlib\can.c ****             //
1822:C:/StellarisWare/driverlib\can.c ****             // Put the 11 bit Mask Identifier into the upper bits of the field
1823:C:/StellarisWare/driverlib\can.c ****             // in the register.
1824:C:/StellarisWare/driverlib\can.c ****             //
1825:C:/StellarisWare/driverlib\can.c ****             usMaskReg1 = ((pMsgObject->ulMsgIDMask << 2) &
 1775              		.loc 1 1825 0
 1776 0130 7B68     		ldr	r3, [r7, #4]
 1777 0132 5B68     		ldr	r3, [r3, #4]
 1778 0134 9BB2     		uxth	r3, r3
 1779 0136 4FEA8303 		lsl	r3, r3, #2
 1780 013a 9BB2     		uxth	r3, r3
 1781 013c 4FEAC343 		lsl	r3, r3, #19
 1782 0140 4FEAD343 		lsr	r3, r3, #19
 1783 0144 7B83     		strh	r3, [r7, #26]	@ movhi
 1784              	.L93:
1826:C:/StellarisWare/driverlib\can.c ****                             CAN_IF1MSK2_IDMSK_M);
1827:C:/StellarisWare/driverlib\can.c ****         }
1828:C:/StellarisWare/driverlib\can.c ****     }
1829:C:/StellarisWare/driverlib\can.c **** 
1830:C:/StellarisWare/driverlib\can.c ****     //
1831:C:/StellarisWare/driverlib\can.c ****     // If the caller wants to filter on the extended ID bit then set it.
1832:C:/StellarisWare/driverlib\can.c ****     //
1833:C:/StellarisWare/driverlib\can.c ****     if((pMsgObject->ulFlags & MSG_OBJ_USE_EXT_FILTER) ==
 1785              		.loc 1 1833 0
 1786 0146 7B68     		ldr	r3, [r7, #4]
 1787 0148 9B68     		ldr	r3, [r3, #8]
 1788 014a 03F02803 		and	r3, r3, #40
 1789 014e 282B     		cmp	r3, #40
 1790 0150 05D1     		bne	.L95
1834:C:/StellarisWare/driverlib\can.c ****        MSG_OBJ_USE_EXT_FILTER)
1835:C:/StellarisWare/driverlib\can.c ****     {
1836:C:/StellarisWare/driverlib\can.c ****         usMaskReg1 |= CAN_IF1MSK2_MXTD;
 1791              		.loc 1 1836 0
 1792 0152 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 1793 0154 6FEA4343 		mvn	r3, r3, lsl #17
 1794 0158 6FEA5343 		mvn	r3, r3, lsr #17
 1795 015c 7B83     		strh	r3, [r7, #26]	@ movhi
 1796              	.L95:
1837:C:/StellarisWare/driverlib\can.c ****     }
1838:C:/StellarisWare/driverlib\can.c **** 
1839:C:/StellarisWare/driverlib\can.c ****     //
1840:C:/StellarisWare/driverlib\can.c ****     // The caller wants to filter on the message direction field.
1841:C:/StellarisWare/driverlib\can.c ****     //
1842:C:/StellarisWare/driverlib\can.c ****     if((pMsgObject->ulFlags & MSG_OBJ_USE_DIR_FILTER) ==
 1797              		.loc 1 1842 0
 1798 015e 7B68     		ldr	r3, [r7, #4]
 1799 0160 9B68     		ldr	r3, [r3, #8]
 1800 0162 03F01803 		and	r3, r3, #24
 1801 0166 182B     		cmp	r3, #24
 1802 0168 03D1     		bne	.L96
1843:C:/StellarisWare/driverlib\can.c ****        MSG_OBJ_USE_DIR_FILTER)
1844:C:/StellarisWare/driverlib\can.c ****     {
1845:C:/StellarisWare/driverlib\can.c ****         usMaskReg1 |= CAN_IF1MSK2_MDIR;
 1803              		.loc 1 1845 0
 1804 016a 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 1805 016c 43F48043 		orr	r3, r3, #16384
 1806 0170 7B83     		strh	r3, [r7, #26]	@ movhi
 1807              	.L96:
1846:C:/StellarisWare/driverlib\can.c ****     }
1847:C:/StellarisWare/driverlib\can.c **** 
1848:C:/StellarisWare/driverlib\can.c ****     if(pMsgObject->ulFlags & (MSG_OBJ_USE_ID_FILTER | MSG_OBJ_USE_DIR_FILTER |
 1808              		.loc 1 1848 0
 1809 0172 7B68     		ldr	r3, [r7, #4]
 1810 0174 9B68     		ldr	r3, [r3, #8]
 1811 0176 03F03803 		and	r3, r3, #56
 1812 017a 002B     		cmp	r3, #0
 1813 017c 07D0     		beq	.L97
1849:C:/StellarisWare/driverlib\can.c ****                               MSG_OBJ_USE_EXT_FILTER))
1850:C:/StellarisWare/driverlib\can.c ****     {
1851:C:/StellarisWare/driverlib\can.c ****         //
1852:C:/StellarisWare/driverlib\can.c ****         // Set the UMASK bit to enable using the mask register.
1853:C:/StellarisWare/driverlib\can.c ****         //
1854:C:/StellarisWare/driverlib\can.c ****         usMsgCtrl |= CAN_IF1MCTL_UMASK;
 1814              		.loc 1 1854 0
 1815 017e BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1816 0180 43F48053 		orr	r3, r3, #4096
 1817 0184 BB82     		strh	r3, [r7, #20]	@ movhi
1855:C:/StellarisWare/driverlib\can.c **** 
1856:C:/StellarisWare/driverlib\can.c ****         //
1857:C:/StellarisWare/driverlib\can.c ****         // Set the MASK bit so that this gets transferred to the Message Object.
1858:C:/StellarisWare/driverlib\can.c ****         //
1859:C:/StellarisWare/driverlib\can.c ****         usCmdMaskReg |= CAN_IF1CMSK_MASK;
 1818              		.loc 1 1859 0
 1819 0186 FB8B     		ldrh	r3, [r7, #30]	@ movhi
 1820 0188 43F04003 		orr	r3, r3, #64
 1821 018c FB83     		strh	r3, [r7, #30]	@ movhi
 1822              	.L97:
1860:C:/StellarisWare/driverlib\can.c ****     }
1861:C:/StellarisWare/driverlib\can.c **** 
1862:C:/StellarisWare/driverlib\can.c ****     //
1863:C:/StellarisWare/driverlib\can.c ****     // Set the Arb bit so that this gets transferred to the Message object.
1864:C:/StellarisWare/driverlib\can.c ****     //
1865:C:/StellarisWare/driverlib\can.c ****     usCmdMaskReg |= CAN_IF1CMSK_ARB;
 1823              		.loc 1 1865 0
 1824 018e FB8B     		ldrh	r3, [r7, #30]	@ movhi
 1825 0190 43F02003 		orr	r3, r3, #32
 1826 0194 FB83     		strh	r3, [r7, #30]	@ movhi
1866:C:/StellarisWare/driverlib\can.c **** 
1867:C:/StellarisWare/driverlib\can.c ****     //
1868:C:/StellarisWare/driverlib\can.c ****     // Configure the Arbitration registers.
1869:C:/StellarisWare/driverlib\can.c ****     //
1870:C:/StellarisWare/driverlib\can.c ****     if(bUseExtendedID)
 1827              		.loc 1 1870 0
 1828 0196 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
 1829 0198 002B     		cmp	r3, #0
 1830 019a 19D0     		beq	.L98
1871:C:/StellarisWare/driverlib\can.c ****     {
1872:C:/StellarisWare/driverlib\can.c ****         //
1873:C:/StellarisWare/driverlib\can.c ****         // Set the 29 bit version of the Identifier for this message object.
1874:C:/StellarisWare/driverlib\can.c ****         //
1875:C:/StellarisWare/driverlib\can.c ****         usArbReg0 |= pMsgObject->ulMsgID & CAN_IF1ARB1_ID_M;
 1831              		.loc 1 1875 0
 1832 019c 7B68     		ldr	r3, [r7, #4]
 1833 019e 1B68     		ldr	r3, [r3, #0]
 1834 01a0 9AB2     		uxth	r2, r3
 1835 01a2 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 1836 01a4 1343     		orrs	r3, r3, r2
 1837 01a6 3B83     		strh	r3, [r7, #24]	@ movhi
1876:C:/StellarisWare/driverlib\can.c ****         usArbReg1 |= (pMsgObject->ulMsgID >> 16) & CAN_IF1ARB2_ID_M;
 1838              		.loc 1 1876 0
 1839 01a8 7B68     		ldr	r3, [r7, #4]
 1840 01aa 1B68     		ldr	r3, [r3, #0]
 1841 01ac 4FEA1343 		lsr	r3, r3, #16
 1842 01b0 9BB2     		uxth	r3, r3
 1843 01b2 4FEAC343 		lsl	r3, r3, #19
 1844 01b6 4FEAD343 		lsr	r3, r3, #19
 1845 01ba 9AB2     		uxth	r2, r3
 1846 01bc FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1847 01be 1343     		orrs	r3, r3, r2
 1848 01c0 FB82     		strh	r3, [r7, #22]	@ movhi
1877:C:/StellarisWare/driverlib\can.c **** 
1878:C:/StellarisWare/driverlib\can.c ****         //
1879:C:/StellarisWare/driverlib\can.c ****         // Mark the message as valid and set the extended ID bit.
1880:C:/StellarisWare/driverlib\can.c ****         //
1881:C:/StellarisWare/driverlib\can.c ****         usArbReg1 |= CAN_IF1ARB2_MSGVAL | CAN_IF1ARB2_XTD;
 1849              		.loc 1 1881 0
 1850 01c2 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1851 01c4 6FEA8343 		mvn	r3, r3, lsl #18
 1852 01c8 6FEA9343 		mvn	r3, r3, lsr #18
 1853 01cc FB82     		strh	r3, [r7, #22]	@ movhi
 1854 01ce 13E0     		b	.L99
 1855              	.L98:
1882:C:/StellarisWare/driverlib\can.c ****     }
1883:C:/StellarisWare/driverlib\can.c ****     else
1884:C:/StellarisWare/driverlib\can.c ****     {
1885:C:/StellarisWare/driverlib\can.c ****         //
1886:C:/StellarisWare/driverlib\can.c ****         // Set the 11 bit version of the Identifier for this message object.
1887:C:/StellarisWare/driverlib\can.c ****         // The lower 18 bits are set to zero.
1888:C:/StellarisWare/driverlib\can.c ****         //
1889:C:/StellarisWare/driverlib\can.c ****         usArbReg1 |= (pMsgObject->ulMsgID << 2) & CAN_IF1ARB2_ID_M;
 1856              		.loc 1 1889 0
 1857 01d0 7B68     		ldr	r3, [r7, #4]
 1858 01d2 1B68     		ldr	r3, [r3, #0]
 1859 01d4 9BB2     		uxth	r3, r3
 1860 01d6 4FEA8303 		lsl	r3, r3, #2
 1861 01da 9BB2     		uxth	r3, r3
 1862 01dc 4FEAC343 		lsl	r3, r3, #19
 1863 01e0 4FEAD343 		lsr	r3, r3, #19
 1864 01e4 9AB2     		uxth	r2, r3
 1865 01e6 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1866 01e8 1343     		orrs	r3, r3, r2
 1867 01ea FB82     		strh	r3, [r7, #22]	@ movhi
1890:C:/StellarisWare/driverlib\can.c **** 
1891:C:/StellarisWare/driverlib\can.c ****         //
1892:C:/StellarisWare/driverlib\can.c ****         // Mark the message as valid.
1893:C:/StellarisWare/driverlib\can.c ****         //
1894:C:/StellarisWare/driverlib\can.c ****         usArbReg1 |= CAN_IF1ARB2_MSGVAL;
 1868              		.loc 1 1894 0
 1869 01ec FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1870 01ee 6FEA4343 		mvn	r3, r3, lsl #17
 1871 01f2 6FEA5343 		mvn	r3, r3, lsr #17
 1872 01f6 FB82     		strh	r3, [r7, #22]	@ movhi
 1873              	.L99:
1895:C:/StellarisWare/driverlib\can.c ****     }
1896:C:/StellarisWare/driverlib\can.c **** 
1897:C:/StellarisWare/driverlib\can.c ****     //
1898:C:/StellarisWare/driverlib\can.c ****     // Set the data length since this is set for all transfers.  This is also a
1899:C:/StellarisWare/driverlib\can.c ****     // single transfer and not a FIFO transfer so set EOB bit.
1900:C:/StellarisWare/driverlib\can.c ****     //
1901:C:/StellarisWare/driverlib\can.c ****     usMsgCtrl |= (pMsgObject->ulMsgLen & CAN_IF1MCTL_DLC_M);
 1874              		.loc 1 1901 0
 1875 01f8 7B68     		ldr	r3, [r7, #4]
 1876 01fa DB68     		ldr	r3, [r3, #12]
 1877 01fc 9BB2     		uxth	r3, r3
 1878 01fe 03F00F03 		and	r3, r3, #15
 1879 0202 9AB2     		uxth	r2, r3
 1880 0204 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1881 0206 1343     		orrs	r3, r3, r2
 1882 0208 BB82     		strh	r3, [r7, #20]	@ movhi
1902:C:/StellarisWare/driverlib\can.c **** 
1903:C:/StellarisWare/driverlib\can.c ****     //
1904:C:/StellarisWare/driverlib\can.c ****     // Mark this as the last entry if this is not the last entry in a FIFO.
1905:C:/StellarisWare/driverlib\can.c ****     //
1906:C:/StellarisWare/driverlib\can.c ****     if((pMsgObject->ulFlags & MSG_OBJ_FIFO) == 0)
 1883              		.loc 1 1906 0
 1884 020a 7B68     		ldr	r3, [r7, #4]
 1885 020c 9B68     		ldr	r3, [r3, #8]
 1886 020e 03F40073 		and	r3, r3, #512
 1887 0212 002B     		cmp	r3, #0
 1888 0214 03D1     		bne	.L100
1907:C:/StellarisWare/driverlib\can.c ****     {
1908:C:/StellarisWare/driverlib\can.c ****         usMsgCtrl |= CAN_IF1MCTL_EOB;
 1889              		.loc 1 1908 0
 1890 0216 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1891 0218 43F08003 		orr	r3, r3, #128
 1892 021c BB82     		strh	r3, [r7, #20]	@ movhi
 1893              	.L100:
1909:C:/StellarisWare/driverlib\can.c ****     }
1910:C:/StellarisWare/driverlib\can.c **** 
1911:C:/StellarisWare/driverlib\can.c ****     //
1912:C:/StellarisWare/driverlib\can.c ****     // Enable transmit interrupts if they should be enabled.
1913:C:/StellarisWare/driverlib\can.c ****     //
1914:C:/StellarisWare/driverlib\can.c ****     if(pMsgObject->ulFlags & MSG_OBJ_TX_INT_ENABLE)
 1894              		.loc 1 1914 0
 1895 021e 7B68     		ldr	r3, [r7, #4]
 1896 0220 9B68     		ldr	r3, [r3, #8]
 1897 0222 03F00103 		and	r3, r3, #1
 1898 0226 DBB2     		uxtb	r3, r3
 1899 0228 002B     		cmp	r3, #0
 1900 022a 03D0     		beq	.L101
1915:C:/StellarisWare/driverlib\can.c ****     {
1916:C:/StellarisWare/driverlib\can.c ****         usMsgCtrl |= CAN_IF1MCTL_TXIE;
 1901              		.loc 1 1916 0
 1902 022c BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1903 022e 43F40063 		orr	r3, r3, #2048
 1904 0232 BB82     		strh	r3, [r7, #20]	@ movhi
 1905              	.L101:
1917:C:/StellarisWare/driverlib\can.c ****     }
1918:C:/StellarisWare/driverlib\can.c **** 
1919:C:/StellarisWare/driverlib\can.c ****     //
1920:C:/StellarisWare/driverlib\can.c ****     // Enable receive interrupts if they should be enabled.
1921:C:/StellarisWare/driverlib\can.c ****     //
1922:C:/StellarisWare/driverlib\can.c ****     if(pMsgObject->ulFlags & MSG_OBJ_RX_INT_ENABLE)
 1906              		.loc 1 1922 0
 1907 0234 7B68     		ldr	r3, [r7, #4]
 1908 0236 9B68     		ldr	r3, [r3, #8]
 1909 0238 03F00203 		and	r3, r3, #2
 1910 023c 002B     		cmp	r3, #0
 1911 023e 03D0     		beq	.L102
1923:C:/StellarisWare/driverlib\can.c ****     {
1924:C:/StellarisWare/driverlib\can.c ****         usMsgCtrl |= CAN_IF1MCTL_RXIE;
 1912              		.loc 1 1924 0
 1913 0240 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 1914 0242 43F48063 		orr	r3, r3, #1024
 1915 0246 BB82     		strh	r3, [r7, #20]	@ movhi
 1916              	.L102:
1925:C:/StellarisWare/driverlib\can.c ****     }
1926:C:/StellarisWare/driverlib\can.c **** 
1927:C:/StellarisWare/driverlib\can.c ****     //
1928:C:/StellarisWare/driverlib\can.c ****     // Write the data out to the CAN Data registers if needed.
1929:C:/StellarisWare/driverlib\can.c ****     //
1930:C:/StellarisWare/driverlib\can.c ****     if(bTransferData)
 1917              		.loc 1 1930 0
 1918 0248 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1919 024a 002B     		cmp	r3, #0
 1920 024c 0CD0     		beq	.L103
1931:C:/StellarisWare/driverlib\can.c ****     {
1932:C:/StellarisWare/driverlib\can.c ****         CANDataRegWrite(pMsgObject->pucMsgData,
 1921              		.loc 1 1932 0
 1922 024e 7B68     		ldr	r3, [r7, #4]
 1923 0250 1969     		ldr	r1, [r3, #16]
1933:C:/StellarisWare/driverlib\can.c ****                         (unsigned long *)(ulBase + CAN_O_IF1DA1),
 1924              		.loc 1 1933 0
 1925 0252 FB68     		ldr	r3, [r7, #12]
 1926 0254 03F13C03 		add	r3, r3, #60
1932:C:/StellarisWare/driverlib\can.c ****         CANDataRegWrite(pMsgObject->pucMsgData,
 1927              		.loc 1 1932 0
 1928 0258 1A46     		mov	r2, r3
1934:C:/StellarisWare/driverlib\can.c ****                         pMsgObject->ulMsgLen);
 1929              		.loc 1 1934 0
 1930 025a 7B68     		ldr	r3, [r7, #4]
1932:C:/StellarisWare/driverlib\can.c ****         CANDataRegWrite(pMsgObject->pucMsgData,
 1931              		.loc 1 1932 0
 1932 025c DB68     		ldr	r3, [r3, #12]
 1933 025e 0846     		mov	r0, r1
 1934 0260 1146     		mov	r1, r2
 1935 0262 1A46     		mov	r2, r3
 1936 0264 FFF7FEFF 		bl	CANDataRegWrite
 1937              	.L103:
1935:C:/StellarisWare/driverlib\can.c ****     }
1936:C:/StellarisWare/driverlib\can.c **** 
1937:C:/StellarisWare/driverlib\can.c ****     //
1938:C:/StellarisWare/driverlib\can.c ****     // Write out the registers to program the message object.
1939:C:/StellarisWare/driverlib\can.c ****     //
1940:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CMSK, usCmdMaskReg);
 1938              		.loc 1 1940 0
 1939 0268 FB68     		ldr	r3, [r7, #12]
 1940 026a 03F12402 		add	r2, r3, #36
 1941 026e FB8B     		ldrh	r3, [r7, #30]
 1942 0270 1046     		mov	r0, r2
 1943 0272 1946     		mov	r1, r3
 1944 0274 FFF7FEFF 		bl	CANRegWrite
1941:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1MSK1, usMaskReg0);
 1945              		.loc 1 1941 0
 1946 0278 FB68     		ldr	r3, [r7, #12]
 1947 027a 03F12802 		add	r2, r3, #40
 1948 027e BB8B     		ldrh	r3, [r7, #28]
 1949 0280 1046     		mov	r0, r2
 1950 0282 1946     		mov	r1, r3
 1951 0284 FFF7FEFF 		bl	CANRegWrite
1942:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1MSK2, usMaskReg1);
 1952              		.loc 1 1942 0
 1953 0288 FB68     		ldr	r3, [r7, #12]
 1954 028a 03F12C02 		add	r2, r3, #44
 1955 028e 7B8B     		ldrh	r3, [r7, #26]
 1956 0290 1046     		mov	r0, r2
 1957 0292 1946     		mov	r1, r3
 1958 0294 FFF7FEFF 		bl	CANRegWrite
1943:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1ARB1, usArbReg0);
 1959              		.loc 1 1943 0
 1960 0298 FB68     		ldr	r3, [r7, #12]
 1961 029a 03F13002 		add	r2, r3, #48
 1962 029e 3B8B     		ldrh	r3, [r7, #24]
 1963 02a0 1046     		mov	r0, r2
 1964 02a2 1946     		mov	r1, r3
 1965 02a4 FFF7FEFF 		bl	CANRegWrite
1944:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1ARB2, usArbReg1);
 1966              		.loc 1 1944 0
 1967 02a8 FB68     		ldr	r3, [r7, #12]
 1968 02aa 03F13402 		add	r2, r3, #52
 1969 02ae FB8A     		ldrh	r3, [r7, #22]
 1970 02b0 1046     		mov	r0, r2
 1971 02b2 1946     		mov	r1, r3
 1972 02b4 FFF7FEFF 		bl	CANRegWrite
1945:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1MCTL, usMsgCtrl);
 1973              		.loc 1 1945 0
 1974 02b8 FB68     		ldr	r3, [r7, #12]
 1975 02ba 03F13802 		add	r2, r3, #56
 1976 02be BB8A     		ldrh	r3, [r7, #20]
 1977 02c0 1046     		mov	r0, r2
 1978 02c2 1946     		mov	r1, r3
 1979 02c4 FFF7FEFF 		bl	CANRegWrite
1946:C:/StellarisWare/driverlib\can.c **** 
1947:C:/StellarisWare/driverlib\can.c ****     //
1948:C:/StellarisWare/driverlib\can.c ****     // Transfer the message object to the message object specified by ulObjID.
1949:C:/StellarisWare/driverlib\can.c ****     //
1950:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CRQ, ulObjID & CAN_IF1CRQ_MNUM_M);
 1980              		.loc 1 1950 0
 1981 02c8 FB68     		ldr	r3, [r7, #12]
 1982 02ca 03F12002 		add	r2, r3, #32
 1983 02ce BB68     		ldr	r3, [r7, #8]
 1984 02d0 03F03F03 		and	r3, r3, #63
 1985 02d4 1046     		mov	r0, r2
 1986 02d6 1946     		mov	r1, r3
 1987 02d8 FFF7FEFF 		bl	CANRegWrite
 1988 02dc 00E0     		b	.L79
 1989              	.L104:
1796:C:/StellarisWare/driverlib\can.c ****             return;
 1990              		.loc 1 1796 0
 1991 02de 00BF     		nop
 1992              	.L79:
1951:C:/StellarisWare/driverlib\can.c **** }
 1993              		.loc 1 1951 0
 1994 02e0 07F12007 		add	r7, r7, #32
 1995 02e4 BD46     		mov	sp, r7
 1996 02e6 80BD     		pop	{r7, pc}
 1997              		.cfi_endproc
 1998              	.LFE21:
 2000              		.section	.text.CANMessageGet,"ax",%progbits
 2001              		.align	2
 2002              		.global	CANMessageGet
 2003              		.thumb
 2004              		.thumb_func
 2006              	CANMessageGet:
 2007              	.LFB22:
1952:C:/StellarisWare/driverlib\can.c **** 
1953:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1954:C:/StellarisWare/driverlib\can.c **** //
1955:C:/StellarisWare/driverlib\can.c **** //! Reads a CAN message from one of the message object buffers.
1956:C:/StellarisWare/driverlib\can.c **** //!
1957:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
1958:C:/StellarisWare/driverlib\can.c **** //! \param ulObjID is the object number to read (1-32).
1959:C:/StellarisWare/driverlib\can.c **** //! \param pMsgObject points to a structure containing message object fields.
1960:C:/StellarisWare/driverlib\can.c **** //! \param bClrPendingInt indicates whether an associated interrupt should be
1961:C:/StellarisWare/driverlib\can.c **** //! cleared.
1962:C:/StellarisWare/driverlib\can.c **** //!
1963:C:/StellarisWare/driverlib\can.c **** //! This function is used to read the contents of one of the 32 message objects
1964:C:/StellarisWare/driverlib\can.c **** //! in the CAN controller and return it to the caller.  The data returned is
1965:C:/StellarisWare/driverlib\can.c **** //! stored in the fields of the caller-supplied structure pointed to by
1966:C:/StellarisWare/driverlib\can.c **** //! \e pMsgObject.  The data consists of all of the parts of a CAN message,
1967:C:/StellarisWare/driverlib\can.c **** //! plus some control and status information.
1968:C:/StellarisWare/driverlib\can.c **** //!
1969:C:/StellarisWare/driverlib\can.c **** //! Normally, this function is used to read a message object that has received
1970:C:/StellarisWare/driverlib\can.c **** //! and stored a CAN message with a certain identifier.  However, this function
1971:C:/StellarisWare/driverlib\can.c **** //! could also be used to read the contents of a message object in order to
1972:C:/StellarisWare/driverlib\can.c **** //! load the fields of the structure in case only part of the structure must
1973:C:/StellarisWare/driverlib\can.c **** //! be changed from a previous setting.
1974:C:/StellarisWare/driverlib\can.c **** //!
1975:C:/StellarisWare/driverlib\can.c **** //! When using CANMessageGet(), all of the same fields of the structure are
1976:C:/StellarisWare/driverlib\can.c **** //! populated in the same way as when the CANMessageSet() function is used,
1977:C:/StellarisWare/driverlib\can.c **** //! with the following exceptions:
1978:C:/StellarisWare/driverlib\can.c **** //!
1979:C:/StellarisWare/driverlib\can.c **** //! \e pMsgObject->ulFlags:
1980:C:/StellarisWare/driverlib\can.c **** //!
1981:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_NEW_DATA indicates if this data is new since the last time it
1982:C:/StellarisWare/driverlib\can.c **** //! was read
1983:C:/StellarisWare/driverlib\can.c **** //! - \b MSG_OBJ_DATA_LOST indicates that at least one message was received on
1984:C:/StellarisWare/driverlib\can.c **** //! this message object and not read by the host before being overwritten.
1985:C:/StellarisWare/driverlib\can.c **** //!
1986:C:/StellarisWare/driverlib\can.c **** //! \return None.
1987:C:/StellarisWare/driverlib\can.c **** //
1988:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
1989:C:/StellarisWare/driverlib\can.c **** void
1990:C:/StellarisWare/driverlib\can.c **** CANMessageGet(unsigned long ulBase, unsigned long ulObjID,
1991:C:/StellarisWare/driverlib\can.c ****               tCANMsgObject *pMsgObject, tBoolean bClrPendingInt)
1992:C:/StellarisWare/driverlib\can.c **** {
 2008              		.loc 1 1992 0
 2009              		.cfi_startproc
 2010              		@ args = 0, pretend = 0, frame = 32
 2011              		@ frame_needed = 1, uses_anonymous_args = 0
 2012 0000 80B5     		push	{r7, lr}
 2013              	.LCFI66:
 2014              		.cfi_def_cfa_offset 8
 2015              		.cfi_offset 14, -4
 2016              		.cfi_offset 7, -8
 2017 0002 88B0     		sub	sp, sp, #32
 2018              	.LCFI67:
 2019              		.cfi_def_cfa_offset 40
 2020 0004 00AF     		add	r7, sp, #0
 2021              	.LCFI68:
 2022              		.cfi_def_cfa_register 7
 2023 0006 F860     		str	r0, [r7, #12]
 2024 0008 B960     		str	r1, [r7, #8]
 2025 000a 7A60     		str	r2, [r7, #4]
 2026 000c FB70     		strb	r3, [r7, #3]
1993:C:/StellarisWare/driverlib\can.c ****     unsigned short usCmdMaskReg;
1994:C:/StellarisWare/driverlib\can.c ****     unsigned short usMaskReg0, usMaskReg1;
1995:C:/StellarisWare/driverlib\can.c ****     unsigned short usArbReg0, usArbReg1;
1996:C:/StellarisWare/driverlib\can.c ****     unsigned short usMsgCtrl;
1997:C:/StellarisWare/driverlib\can.c **** 
1998:C:/StellarisWare/driverlib\can.c ****     //
1999:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
2000:C:/StellarisWare/driverlib\can.c ****     //
2001:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
2002:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulObjID <= 32) && (ulObjID != 0));
2003:C:/StellarisWare/driverlib\can.c **** 
2004:C:/StellarisWare/driverlib\can.c ****     //
2005:C:/StellarisWare/driverlib\can.c ****     // This is always a read to the Message object as this call is setting a
2006:C:/StellarisWare/driverlib\can.c ****     // message object.
2007:C:/StellarisWare/driverlib\can.c ****     //
2008:C:/StellarisWare/driverlib\can.c ****     usCmdMaskReg = (CAN_IF1CMSK_DATAA | CAN_IF1CMSK_DATAB |
 2027              		.loc 1 2008 0
 2028 000e 4FF07303 		mov	r3, #115
 2029 0012 FB83     		strh	r3, [r7, #30]	@ movhi
2009:C:/StellarisWare/driverlib\can.c ****                     CAN_IF1CMSK_CONTROL | CAN_IF1CMSK_MASK | CAN_IF1CMSK_ARB);
2010:C:/StellarisWare/driverlib\can.c **** 
2011:C:/StellarisWare/driverlib\can.c ****     //
2012:C:/StellarisWare/driverlib\can.c ****     // Clear a pending interrupt and new data in a message object.
2013:C:/StellarisWare/driverlib\can.c ****     //
2014:C:/StellarisWare/driverlib\can.c ****     if(bClrPendingInt)
 2030              		.loc 1 2014 0
 2031 0014 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2032 0016 002B     		cmp	r3, #0
 2033 0018 03D0     		beq	.L106
2015:C:/StellarisWare/driverlib\can.c ****     {
2016:C:/StellarisWare/driverlib\can.c ****         usCmdMaskReg |= CAN_IF1CMSK_CLRINTPND;
 2034              		.loc 1 2016 0
 2035 001a FB8B     		ldrh	r3, [r7, #30]	@ movhi
 2036 001c 43F00803 		orr	r3, r3, #8
 2037 0020 FB83     		strh	r3, [r7, #30]	@ movhi
 2038              	.L106:
2017:C:/StellarisWare/driverlib\can.c ****     }
2018:C:/StellarisWare/driverlib\can.c **** 
2019:C:/StellarisWare/driverlib\can.c ****     //
2020:C:/StellarisWare/driverlib\can.c ****     // Set up the request for data from the message object.
2021:C:/StellarisWare/driverlib\can.c ****     //
2022:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF2CMSK, usCmdMaskReg);
 2039              		.loc 1 2022 0
 2040 0022 FB68     		ldr	r3, [r7, #12]
 2041 0024 03F18402 		add	r2, r3, #132
 2042 0028 FB8B     		ldrh	r3, [r7, #30]
 2043 002a 1046     		mov	r0, r2
 2044 002c 1946     		mov	r1, r3
 2045 002e FFF7FEFF 		bl	CANRegWrite
2023:C:/StellarisWare/driverlib\can.c **** 
2024:C:/StellarisWare/driverlib\can.c ****     //
2025:C:/StellarisWare/driverlib\can.c ****     // Transfer the message object to the message object specified by ulObjID.
2026:C:/StellarisWare/driverlib\can.c ****     //
2027:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF2CRQ, ulObjID & CAN_IF1CRQ_MNUM_M);
 2046              		.loc 1 2027 0
 2047 0032 FB68     		ldr	r3, [r7, #12]
 2048 0034 03F18002 		add	r2, r3, #128
 2049 0038 BB68     		ldr	r3, [r7, #8]
 2050 003a 03F03F03 		and	r3, r3, #63
 2051 003e 1046     		mov	r0, r2
 2052 0040 1946     		mov	r1, r3
 2053 0042 FFF7FEFF 		bl	CANRegWrite
2028:C:/StellarisWare/driverlib\can.c **** 
2029:C:/StellarisWare/driverlib\can.c ****     //
2030:C:/StellarisWare/driverlib\can.c ****     // Wait for busy bit to clear
2031:C:/StellarisWare/driverlib\can.c ****     //
2032:C:/StellarisWare/driverlib\can.c ****     while(CANRegRead(ulBase + CAN_O_IF2CRQ) & CAN_IF1CRQ_BUSY)
 2054              		.loc 1 2032 0
 2055 0046 00BF     		nop
 2056              	.L107:
 2057              		.loc 1 2032 0 is_stmt 0 discriminator 1
 2058 0048 FB68     		ldr	r3, [r7, #12]
 2059 004a 03F18003 		add	r3, r3, #128
 2060 004e 1846     		mov	r0, r3
 2061 0050 FFF7FEFF 		bl	CANRegRead
 2062 0054 0346     		mov	r3, r0
 2063 0056 03F40043 		and	r3, r3, #32768
 2064 005a 002B     		cmp	r3, #0
 2065 005c F4D1     		bne	.L107
2033:C:/StellarisWare/driverlib\can.c ****     {
2034:C:/StellarisWare/driverlib\can.c ****     }
2035:C:/StellarisWare/driverlib\can.c **** 
2036:C:/StellarisWare/driverlib\can.c ****     //
2037:C:/StellarisWare/driverlib\can.c ****     // Read out the IF Registers.
2038:C:/StellarisWare/driverlib\can.c ****     //
2039:C:/StellarisWare/driverlib\can.c ****     usMaskReg0 = CANRegRead(ulBase + CAN_O_IF2MSK1);
 2066              		.loc 1 2039 0 is_stmt 1
 2067 005e FB68     		ldr	r3, [r7, #12]
 2068 0060 03F18803 		add	r3, r3, #136
 2069 0064 1846     		mov	r0, r3
 2070 0066 FFF7FEFF 		bl	CANRegRead
 2071 006a 0346     		mov	r3, r0
 2072 006c BB83     		strh	r3, [r7, #28]	@ movhi
2040:C:/StellarisWare/driverlib\can.c ****     usMaskReg1 = CANRegRead(ulBase + CAN_O_IF2MSK2);
 2073              		.loc 1 2040 0
 2074 006e FB68     		ldr	r3, [r7, #12]
 2075 0070 03F18C03 		add	r3, r3, #140
 2076 0074 1846     		mov	r0, r3
 2077 0076 FFF7FEFF 		bl	CANRegRead
 2078 007a 0346     		mov	r3, r0
 2079 007c 7B83     		strh	r3, [r7, #26]	@ movhi
2041:C:/StellarisWare/driverlib\can.c ****     usArbReg0 = CANRegRead(ulBase + CAN_O_IF2ARB1);
 2080              		.loc 1 2041 0
 2081 007e FB68     		ldr	r3, [r7, #12]
 2082 0080 03F19003 		add	r3, r3, #144
 2083 0084 1846     		mov	r0, r3
 2084 0086 FFF7FEFF 		bl	CANRegRead
 2085 008a 0346     		mov	r3, r0
 2086 008c 3B83     		strh	r3, [r7, #24]	@ movhi
2042:C:/StellarisWare/driverlib\can.c ****     usArbReg1 = CANRegRead(ulBase + CAN_O_IF2ARB2);
 2087              		.loc 1 2042 0
 2088 008e FB68     		ldr	r3, [r7, #12]
 2089 0090 03F19403 		add	r3, r3, #148
 2090 0094 1846     		mov	r0, r3
 2091 0096 FFF7FEFF 		bl	CANRegRead
 2092 009a 0346     		mov	r3, r0
 2093 009c FB82     		strh	r3, [r7, #22]	@ movhi
2043:C:/StellarisWare/driverlib\can.c ****     usMsgCtrl = CANRegRead(ulBase + CAN_O_IF2MCTL);
 2094              		.loc 1 2043 0
 2095 009e FB68     		ldr	r3, [r7, #12]
 2096 00a0 03F19803 		add	r3, r3, #152
 2097 00a4 1846     		mov	r0, r3
 2098 00a6 FFF7FEFF 		bl	CANRegRead
 2099 00aa 0346     		mov	r3, r0
 2100 00ac BB82     		strh	r3, [r7, #20]	@ movhi
2044:C:/StellarisWare/driverlib\can.c **** 
2045:C:/StellarisWare/driverlib\can.c ****     pMsgObject->ulFlags = MSG_OBJ_NO_FLAGS;
 2101              		.loc 1 2045 0
 2102 00ae 7B68     		ldr	r3, [r7, #4]
 2103 00b0 4FF00002 		mov	r2, #0
 2104 00b4 9A60     		str	r2, [r3, #8]
2046:C:/StellarisWare/driverlib\can.c **** 
2047:C:/StellarisWare/driverlib\can.c ****     //
2048:C:/StellarisWare/driverlib\can.c ****     // Determine if this is a remote frame by checking the TXRQST and DIR bits.
2049:C:/StellarisWare/driverlib\can.c ****     //
2050:C:/StellarisWare/driverlib\can.c ****     if((!(usMsgCtrl & CAN_IF1MCTL_TXRQST) && (usArbReg1 & CAN_IF1ARB2_DIR)) ||
 2105              		.loc 1 2050 0
 2106 00b6 BB8A     		ldrh	r3, [r7, #20]
 2107 00b8 03F48073 		and	r3, r3, #256
 2108 00bc 002B     		cmp	r3, #0
 2109 00be 04D1     		bne	.L108
 2110              		.loc 1 2050 0 is_stmt 0 discriminator 1
 2111 00c0 FB8A     		ldrh	r3, [r7, #22]
 2112 00c2 03F40053 		and	r3, r3, #8192
 2113 00c6 002B     		cmp	r3, #0
 2114 00c8 09D1     		bne	.L109
 2115              	.L108:
2051:C:/StellarisWare/driverlib\can.c ****        ((usMsgCtrl & CAN_IF1MCTL_TXRQST) && (!(usArbReg1 & CAN_IF1ARB2_DIR))))
 2116              		.loc 1 2051 0 is_stmt 1 discriminator 2
 2117 00ca BB8A     		ldrh	r3, [r7, #20]
 2118 00cc 03F48073 		and	r3, r3, #256
2050:C:/StellarisWare/driverlib\can.c ****     if((!(usMsgCtrl & CAN_IF1MCTL_TXRQST) && (usArbReg1 & CAN_IF1ARB2_DIR)) ||
 2119              		.loc 1 2050 0 discriminator 2
 2120 00d0 002B     		cmp	r3, #0
 2121 00d2 0AD0     		beq	.L110
 2122              		.loc 1 2051 0
 2123 00d4 FB8A     		ldrh	r3, [r7, #22]
 2124 00d6 03F40053 		and	r3, r3, #8192
 2125 00da 002B     		cmp	r3, #0
 2126 00dc 05D1     		bne	.L110
 2127              	.L109:
2052:C:/StellarisWare/driverlib\can.c ****     {
2053:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_REMOTE_FRAME;
 2128              		.loc 1 2053 0
 2129 00de 7B68     		ldr	r3, [r7, #4]
 2130 00e0 9B68     		ldr	r3, [r3, #8]
 2131 00e2 43F04002 		orr	r2, r3, #64
 2132 00e6 7B68     		ldr	r3, [r7, #4]
 2133 00e8 9A60     		str	r2, [r3, #8]
 2134              	.L110:
2054:C:/StellarisWare/driverlib\can.c ****     }
2055:C:/StellarisWare/driverlib\can.c **** 
2056:C:/StellarisWare/driverlib\can.c ****     //
2057:C:/StellarisWare/driverlib\can.c ****     // Get the identifier out of the register, the format depends on size of
2058:C:/StellarisWare/driverlib\can.c ****     // the mask.
2059:C:/StellarisWare/driverlib\can.c ****     //
2060:C:/StellarisWare/driverlib\can.c ****     if(usArbReg1 & CAN_IF1ARB2_XTD)
 2135              		.loc 1 2060 0
 2136 00ea FB8A     		ldrh	r3, [r7, #22]
 2137 00ec 03F48043 		and	r3, r3, #16384
 2138 00f0 002B     		cmp	r3, #0
 2139 00f2 12D0     		beq	.L111
2061:C:/StellarisWare/driverlib\can.c ****     {
2062:C:/StellarisWare/driverlib\can.c ****         //
2063:C:/StellarisWare/driverlib\can.c ****         // Set the 29 bit version of the Identifier for this message object.
2064:C:/StellarisWare/driverlib\can.c ****         //
2065:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulMsgID = ((usArbReg1 & CAN_IF1ARB2_ID_M) << 16) |
 2140              		.loc 1 2065 0
 2141 00f4 FB8A     		ldrh	r3, [r7, #22]
 2142 00f6 4FEAC343 		lsl	r3, r3, #19
 2143 00fa 4FEAD343 		lsr	r3, r3, #19
 2144 00fe 4FEA0342 		lsl	r2, r3, #16
 2145 0102 3B8B     		ldrh	r3, [r7, #24]
 2146 0104 1343     		orrs	r3, r3, r2
 2147 0106 1A46     		mov	r2, r3
 2148 0108 7B68     		ldr	r3, [r7, #4]
 2149 010a 1A60     		str	r2, [r3, #0]
2066:C:/StellarisWare/driverlib\can.c ****             usArbReg0;
2067:C:/StellarisWare/driverlib\can.c **** 
2068:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_EXTENDED_ID;
 2150              		.loc 1 2068 0
 2151 010c 7B68     		ldr	r3, [r7, #4]
 2152 010e 9B68     		ldr	r3, [r3, #8]
 2153 0110 43F00402 		orr	r2, r3, #4
 2154 0114 7B68     		ldr	r3, [r7, #4]
 2155 0116 9A60     		str	r2, [r3, #8]
 2156 0118 09E0     		b	.L112
 2157              	.L111:
2069:C:/StellarisWare/driverlib\can.c ****     }
2070:C:/StellarisWare/driverlib\can.c ****     else
2071:C:/StellarisWare/driverlib\can.c ****     {
2072:C:/StellarisWare/driverlib\can.c ****         //
2073:C:/StellarisWare/driverlib\can.c ****         // The Identifier is an 11 bit value.
2074:C:/StellarisWare/driverlib\can.c ****         //
2075:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulMsgID = (usArbReg1 & CAN_IF1ARB2_ID_M) >> 2;
 2158              		.loc 1 2075 0
 2159 011a FB8A     		ldrh	r3, [r7, #22]
 2160 011c 4FEAC343 		lsl	r3, r3, #19
 2161 0120 4FEAD343 		lsr	r3, r3, #19
 2162 0124 4FEAA303 		asr	r3, r3, #2
 2163 0128 1A46     		mov	r2, r3
 2164 012a 7B68     		ldr	r3, [r7, #4]
 2165 012c 1A60     		str	r2, [r3, #0]
 2166              	.L112:
2076:C:/StellarisWare/driverlib\can.c ****     }
2077:C:/StellarisWare/driverlib\can.c **** 
2078:C:/StellarisWare/driverlib\can.c ****     //
2079:C:/StellarisWare/driverlib\can.c ****     // Indicate that we lost some data.
2080:C:/StellarisWare/driverlib\can.c ****     //
2081:C:/StellarisWare/driverlib\can.c ****     if(usMsgCtrl & CAN_IF1MCTL_MSGLST)
 2167              		.loc 1 2081 0
 2168 012e BB8A     		ldrh	r3, [r7, #20]
 2169 0130 03F48043 		and	r3, r3, #16384
 2170 0134 002B     		cmp	r3, #0
 2171 0136 05D0     		beq	.L113
2082:C:/StellarisWare/driverlib\can.c ****     {
2083:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_DATA_LOST;
 2172              		.loc 1 2083 0
 2173 0138 7B68     		ldr	r3, [r7, #4]
 2174 013a 9B68     		ldr	r3, [r3, #8]
 2175 013c 43F48072 		orr	r2, r3, #256
 2176 0140 7B68     		ldr	r3, [r7, #4]
 2177 0142 9A60     		str	r2, [r3, #8]
 2178              	.L113:
2084:C:/StellarisWare/driverlib\can.c ****     }
2085:C:/StellarisWare/driverlib\can.c **** 
2086:C:/StellarisWare/driverlib\can.c ****     //
2087:C:/StellarisWare/driverlib\can.c ****     // Set the flag to indicate if ID masking was used.
2088:C:/StellarisWare/driverlib\can.c ****     //
2089:C:/StellarisWare/driverlib\can.c ****     if(usMsgCtrl & CAN_IF1MCTL_UMASK)
 2179              		.loc 1 2089 0
 2180 0144 BB8A     		ldrh	r3, [r7, #20]
 2181 0146 03F48053 		and	r3, r3, #4096
 2182 014a 002B     		cmp	r3, #0
 2183 014c 54D0     		beq	.L114
2090:C:/StellarisWare/driverlib\can.c ****     {
2091:C:/StellarisWare/driverlib\can.c ****         if(usArbReg1 & CAN_IF1ARB2_XTD)
 2184              		.loc 1 2091 0
 2185 014e FB8A     		ldrh	r3, [r7, #22]
 2186 0150 03F48043 		and	r3, r3, #16384
 2187 0154 002B     		cmp	r3, #0
 2188 0156 1ED0     		beq	.L115
2092:C:/StellarisWare/driverlib\can.c ****         {
2093:C:/StellarisWare/driverlib\can.c ****             //
2094:C:/StellarisWare/driverlib\can.c ****             // The Identifier Mask is assumed to also be a 29 bit value.
2095:C:/StellarisWare/driverlib\can.c ****             //
2096:C:/StellarisWare/driverlib\can.c ****             pMsgObject->ulMsgIDMask =
2097:C:/StellarisWare/driverlib\can.c ****                 ((usMaskReg1 & CAN_IF1MSK2_IDMSK_M) << 16) | usMaskReg0;
 2189              		.loc 1 2097 0
 2190 0158 7B8B     		ldrh	r3, [r7, #26]
 2191 015a 4FEAC343 		lsl	r3, r3, #19
 2192 015e 4FEAD343 		lsr	r3, r3, #19
 2193 0162 4FEA0342 		lsl	r2, r3, #16
 2194 0166 BB8B     		ldrh	r3, [r7, #28]
 2195 0168 1343     		orrs	r3, r3, r2
2096:C:/StellarisWare/driverlib\can.c ****             pMsgObject->ulMsgIDMask =
 2196              		.loc 1 2096 0
 2197 016a 1A46     		mov	r2, r3
 2198 016c 7B68     		ldr	r3, [r7, #4]
 2199 016e 5A60     		str	r2, [r3, #4]
2098:C:/StellarisWare/driverlib\can.c **** 
2099:C:/StellarisWare/driverlib\can.c ****             //
2100:C:/StellarisWare/driverlib\can.c ****             // If this is a fully specified Mask and a remote frame then don't
2101:C:/StellarisWare/driverlib\can.c ****             // set the MSG_OBJ_USE_ID_FILTER because the ID was not really
2102:C:/StellarisWare/driverlib\can.c ****             // filtered.
2103:C:/StellarisWare/driverlib\can.c ****             //
2104:C:/StellarisWare/driverlib\can.c ****             if((pMsgObject->ulMsgIDMask != 0x1fffffff) ||
 2200              		.loc 1 2104 0
 2201 0170 7B68     		ldr	r3, [r7, #4]
 2202 0172 5A68     		ldr	r2, [r3, #4]
 2203 0174 6FF06043 		mvn	r3, #-536870912
 2204 0178 9A42     		cmp	r2, r3
 2205 017a 05D1     		bne	.L116
2105:C:/StellarisWare/driverlib\can.c ****                ((pMsgObject->ulFlags & MSG_OBJ_REMOTE_FRAME) == 0))
 2206              		.loc 1 2105 0 discriminator 1
 2207 017c 7B68     		ldr	r3, [r7, #4]
 2208 017e 9B68     		ldr	r3, [r3, #8]
 2209 0180 03F04003 		and	r3, r3, #64
2104:C:/StellarisWare/driverlib\can.c ****             if((pMsgObject->ulMsgIDMask != 0x1fffffff) ||
 2210              		.loc 1 2104 0 discriminator 1
 2211 0184 002B     		cmp	r3, #0
 2212 0186 22D1     		bne	.L117
 2213              	.L116:
2106:C:/StellarisWare/driverlib\can.c ****             {
2107:C:/StellarisWare/driverlib\can.c ****                 pMsgObject->ulFlags |= MSG_OBJ_USE_ID_FILTER;
 2214              		.loc 1 2107 0
 2215 0188 7B68     		ldr	r3, [r7, #4]
 2216 018a 9B68     		ldr	r3, [r3, #8]
 2217 018c 43F00802 		orr	r2, r3, #8
 2218 0190 7B68     		ldr	r3, [r7, #4]
 2219 0192 9A60     		str	r2, [r3, #8]
 2220 0194 1BE0     		b	.L117
 2221              	.L115:
2108:C:/StellarisWare/driverlib\can.c ****             }
2109:C:/StellarisWare/driverlib\can.c ****         }
2110:C:/StellarisWare/driverlib\can.c ****         else
2111:C:/StellarisWare/driverlib\can.c ****         {
2112:C:/StellarisWare/driverlib\can.c ****             //
2113:C:/StellarisWare/driverlib\can.c ****             // The Identifier Mask is assumed to also be an 11 bit value.
2114:C:/StellarisWare/driverlib\can.c ****             //
2115:C:/StellarisWare/driverlib\can.c ****             pMsgObject->ulMsgIDMask = ((usMaskReg1 & CAN_IF1MSK2_IDMSK_M) >>
 2222              		.loc 1 2115 0
 2223 0196 7B8B     		ldrh	r3, [r7, #26]
 2224 0198 4FEAC343 		lsl	r3, r3, #19
 2225 019c 4FEAD343 		lsr	r3, r3, #19
 2226 01a0 4FEAA303 		asr	r3, r3, #2
 2227 01a4 1A46     		mov	r2, r3
 2228 01a6 7B68     		ldr	r3, [r7, #4]
 2229 01a8 5A60     		str	r2, [r3, #4]
2116:C:/StellarisWare/driverlib\can.c ****                                        2);
2117:C:/StellarisWare/driverlib\can.c **** 
2118:C:/StellarisWare/driverlib\can.c ****             //
2119:C:/StellarisWare/driverlib\can.c ****             // If this is a fully specified Mask and a remote frame then don't
2120:C:/StellarisWare/driverlib\can.c ****             // set the MSG_OBJ_USE_ID_FILTER because the ID was not really
2121:C:/StellarisWare/driverlib\can.c ****             // filtered.
2122:C:/StellarisWare/driverlib\can.c ****             //
2123:C:/StellarisWare/driverlib\can.c ****             if((pMsgObject->ulMsgIDMask != 0x7ff) ||
 2230              		.loc 1 2123 0
 2231 01aa 7B68     		ldr	r3, [r7, #4]
 2232 01ac 5A68     		ldr	r2, [r3, #4]
 2233 01ae 40F2FF73 		movw	r3, #2047
 2234 01b2 9A42     		cmp	r2, r3
 2235 01b4 05D1     		bne	.L118
2124:C:/StellarisWare/driverlib\can.c ****                ((pMsgObject->ulFlags & MSG_OBJ_REMOTE_FRAME) == 0))
 2236              		.loc 1 2124 0 discriminator 1
 2237 01b6 7B68     		ldr	r3, [r7, #4]
 2238 01b8 9B68     		ldr	r3, [r3, #8]
 2239 01ba 03F04003 		and	r3, r3, #64
2123:C:/StellarisWare/driverlib\can.c ****             if((pMsgObject->ulMsgIDMask != 0x7ff) ||
 2240              		.loc 1 2123 0 discriminator 1
 2241 01be 002B     		cmp	r3, #0
 2242 01c0 05D1     		bne	.L117
 2243              	.L118:
2125:C:/StellarisWare/driverlib\can.c ****             {
2126:C:/StellarisWare/driverlib\can.c ****                 pMsgObject->ulFlags |= MSG_OBJ_USE_ID_FILTER;
 2244              		.loc 1 2126 0
 2245 01c2 7B68     		ldr	r3, [r7, #4]
 2246 01c4 9B68     		ldr	r3, [r3, #8]
 2247 01c6 43F00802 		orr	r2, r3, #8
 2248 01ca 7B68     		ldr	r3, [r7, #4]
 2249 01cc 9A60     		str	r2, [r3, #8]
 2250              	.L117:
2127:C:/StellarisWare/driverlib\can.c ****             }
2128:C:/StellarisWare/driverlib\can.c ****         }
2129:C:/StellarisWare/driverlib\can.c **** 
2130:C:/StellarisWare/driverlib\can.c ****         //
2131:C:/StellarisWare/driverlib\can.c ****         // Indicate if the extended bit was used in filtering.
2132:C:/StellarisWare/driverlib\can.c ****         //
2133:C:/StellarisWare/driverlib\can.c ****         if(usMaskReg1 & CAN_IF1MSK2_MXTD)
 2251              		.loc 1 2133 0
 2252 01ce 7B8B     		ldrh	r3, [r7, #26]
 2253 01d0 1BB2     		sxth	r3, r3
 2254 01d2 002B     		cmp	r3, #0
 2255 01d4 05DA     		bge	.L119
2134:C:/StellarisWare/driverlib\can.c ****         {
2135:C:/StellarisWare/driverlib\can.c ****             pMsgObject->ulFlags |= MSG_OBJ_USE_EXT_FILTER;
 2256              		.loc 1 2135 0
 2257 01d6 7B68     		ldr	r3, [r7, #4]
 2258 01d8 9B68     		ldr	r3, [r3, #8]
 2259 01da 43F02802 		orr	r2, r3, #40
 2260 01de 7B68     		ldr	r3, [r7, #4]
 2261 01e0 9A60     		str	r2, [r3, #8]
 2262              	.L119:
2136:C:/StellarisWare/driverlib\can.c ****         }
2137:C:/StellarisWare/driverlib\can.c **** 
2138:C:/StellarisWare/driverlib\can.c ****         //
2139:C:/StellarisWare/driverlib\can.c ****         // Indicate if direction filtering was enabled.
2140:C:/StellarisWare/driverlib\can.c ****         //
2141:C:/StellarisWare/driverlib\can.c ****         if(usMaskReg1 & CAN_IF1MSK2_MDIR)
 2263              		.loc 1 2141 0
 2264 01e2 7B8B     		ldrh	r3, [r7, #26]
 2265 01e4 03F48043 		and	r3, r3, #16384
 2266 01e8 002B     		cmp	r3, #0
 2267 01ea 05D0     		beq	.L114
2142:C:/StellarisWare/driverlib\can.c ****         {
2143:C:/StellarisWare/driverlib\can.c ****             pMsgObject->ulFlags |= MSG_OBJ_USE_DIR_FILTER;
 2268              		.loc 1 2143 0
 2269 01ec 7B68     		ldr	r3, [r7, #4]
 2270 01ee 9B68     		ldr	r3, [r3, #8]
 2271 01f0 43F01802 		orr	r2, r3, #24
 2272 01f4 7B68     		ldr	r3, [r7, #4]
 2273 01f6 9A60     		str	r2, [r3, #8]
 2274              	.L114:
2144:C:/StellarisWare/driverlib\can.c ****         }
2145:C:/StellarisWare/driverlib\can.c ****     }
2146:C:/StellarisWare/driverlib\can.c **** 
2147:C:/StellarisWare/driverlib\can.c ****     //
2148:C:/StellarisWare/driverlib\can.c ****     // Set the interrupt flags.
2149:C:/StellarisWare/driverlib\can.c ****     //
2150:C:/StellarisWare/driverlib\can.c ****     if(usMsgCtrl & CAN_IF1MCTL_TXIE)
 2275              		.loc 1 2150 0
 2276 01f8 BB8A     		ldrh	r3, [r7, #20]
 2277 01fa 03F40063 		and	r3, r3, #2048
 2278 01fe 002B     		cmp	r3, #0
 2279 0200 05D0     		beq	.L120
2151:C:/StellarisWare/driverlib\can.c ****     {
2152:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_TX_INT_ENABLE;
 2280              		.loc 1 2152 0
 2281 0202 7B68     		ldr	r3, [r7, #4]
 2282 0204 9B68     		ldr	r3, [r3, #8]
 2283 0206 43F00102 		orr	r2, r3, #1
 2284 020a 7B68     		ldr	r3, [r7, #4]
 2285 020c 9A60     		str	r2, [r3, #8]
 2286              	.L120:
2153:C:/StellarisWare/driverlib\can.c ****     }
2154:C:/StellarisWare/driverlib\can.c ****     if(usMsgCtrl & CAN_IF1MCTL_RXIE)
 2287              		.loc 1 2154 0
 2288 020e BB8A     		ldrh	r3, [r7, #20]
 2289 0210 03F48063 		and	r3, r3, #1024
 2290 0214 002B     		cmp	r3, #0
 2291 0216 05D0     		beq	.L121
2155:C:/StellarisWare/driverlib\can.c ****     {
2156:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_RX_INT_ENABLE;
 2292              		.loc 1 2156 0
 2293 0218 7B68     		ldr	r3, [r7, #4]
 2294 021a 9B68     		ldr	r3, [r3, #8]
 2295 021c 43F00202 		orr	r2, r3, #2
 2296 0220 7B68     		ldr	r3, [r7, #4]
 2297 0222 9A60     		str	r2, [r3, #8]
 2298              	.L121:
2157:C:/StellarisWare/driverlib\can.c ****     }
2158:C:/StellarisWare/driverlib\can.c **** 
2159:C:/StellarisWare/driverlib\can.c ****     //
2160:C:/StellarisWare/driverlib\can.c ****     // See if there is new data available.
2161:C:/StellarisWare/driverlib\can.c ****     //
2162:C:/StellarisWare/driverlib\can.c ****     if(usMsgCtrl & CAN_IF1MCTL_NEWDAT)
 2299              		.loc 1 2162 0
 2300 0224 BB8A     		ldrh	r3, [r7, #20]
 2301 0226 1BB2     		sxth	r3, r3
 2302 0228 002B     		cmp	r3, #0
 2303 022a 3CDA     		bge	.L122
2163:C:/StellarisWare/driverlib\can.c ****     {
2164:C:/StellarisWare/driverlib\can.c ****         //
2165:C:/StellarisWare/driverlib\can.c ****         // Get the amount of data needed to be read.
2166:C:/StellarisWare/driverlib\can.c ****         //
2167:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulMsgLen = (usMsgCtrl & CAN_IF1MCTL_DLC_M);
 2304              		.loc 1 2167 0
 2305 022c BB8A     		ldrh	r3, [r7, #20]
 2306 022e 03F00F02 		and	r2, r3, #15
 2307 0232 7B68     		ldr	r3, [r7, #4]
 2308 0234 DA60     		str	r2, [r3, #12]
2168:C:/StellarisWare/driverlib\can.c **** 
2169:C:/StellarisWare/driverlib\can.c ****         //
2170:C:/StellarisWare/driverlib\can.c ****         // Don't read any data for a remote frame, there is nothing valid in
2171:C:/StellarisWare/driverlib\can.c ****         // that buffer anyway.
2172:C:/StellarisWare/driverlib\can.c ****         //
2173:C:/StellarisWare/driverlib\can.c ****         if((pMsgObject->ulFlags & MSG_OBJ_REMOTE_FRAME) == 0)
 2309              		.loc 1 2173 0
 2310 0236 7B68     		ldr	r3, [r7, #4]
 2311 0238 9B68     		ldr	r3, [r3, #8]
 2312 023a 03F04003 		and	r3, r3, #64
 2313 023e 002B     		cmp	r3, #0
 2314 0240 0CD1     		bne	.L123
2174:C:/StellarisWare/driverlib\can.c ****         {
2175:C:/StellarisWare/driverlib\can.c ****             //
2176:C:/StellarisWare/driverlib\can.c ****             // Read out the data from the CAN registers.
2177:C:/StellarisWare/driverlib\can.c ****             //
2178:C:/StellarisWare/driverlib\can.c ****             CANDataRegRead(pMsgObject->pucMsgData,
 2315              		.loc 1 2178 0
 2316 0242 7B68     		ldr	r3, [r7, #4]
 2317 0244 1969     		ldr	r1, [r3, #16]
2179:C:/StellarisWare/driverlib\can.c ****                            (unsigned long *)(ulBase + CAN_O_IF2DA1),
 2318              		.loc 1 2179 0
 2319 0246 FB68     		ldr	r3, [r7, #12]
 2320 0248 03F19C03 		add	r3, r3, #156
2178:C:/StellarisWare/driverlib\can.c ****             CANDataRegRead(pMsgObject->pucMsgData,
 2321              		.loc 1 2178 0
 2322 024c 1A46     		mov	r2, r3
2180:C:/StellarisWare/driverlib\can.c ****                            pMsgObject->ulMsgLen);
 2323              		.loc 1 2180 0
 2324 024e 7B68     		ldr	r3, [r7, #4]
2178:C:/StellarisWare/driverlib\can.c ****             CANDataRegRead(pMsgObject->pucMsgData,
 2325              		.loc 1 2178 0
 2326 0250 DB68     		ldr	r3, [r3, #12]
 2327 0252 0846     		mov	r0, r1
 2328 0254 1146     		mov	r1, r2
 2329 0256 1A46     		mov	r2, r3
 2330 0258 FFF7FEFF 		bl	CANDataRegRead
 2331              	.L123:
2181:C:/StellarisWare/driverlib\can.c ****         }
2182:C:/StellarisWare/driverlib\can.c **** 
2183:C:/StellarisWare/driverlib\can.c ****         //
2184:C:/StellarisWare/driverlib\can.c ****         // Now clear out the new data flag.
2185:C:/StellarisWare/driverlib\can.c ****         //
2186:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF2CMSK, CAN_IF1CMSK_NEWDAT);
 2332              		.loc 1 2186 0
 2333 025c FB68     		ldr	r3, [r7, #12]
 2334 025e 03F18403 		add	r3, r3, #132
 2335 0262 1846     		mov	r0, r3
 2336 0264 4FF00401 		mov	r1, #4
 2337 0268 FFF7FEFF 		bl	CANRegWrite
2187:C:/StellarisWare/driverlib\can.c **** 
2188:C:/StellarisWare/driverlib\can.c ****         //
2189:C:/StellarisWare/driverlib\can.c ****         // Transfer the message object to the message object specified by
2190:C:/StellarisWare/driverlib\can.c ****         // ulObjID.
2191:C:/StellarisWare/driverlib\can.c ****         //
2192:C:/StellarisWare/driverlib\can.c ****         CANRegWrite(ulBase + CAN_O_IF2CRQ, ulObjID & CAN_IF1CRQ_MNUM_M);
 2338              		.loc 1 2192 0
 2339 026c FB68     		ldr	r3, [r7, #12]
 2340 026e 03F18002 		add	r2, r3, #128
 2341 0272 BB68     		ldr	r3, [r7, #8]
 2342 0274 03F03F03 		and	r3, r3, #63
 2343 0278 1046     		mov	r0, r2
 2344 027a 1946     		mov	r1, r3
 2345 027c FFF7FEFF 		bl	CANRegWrite
2193:C:/StellarisWare/driverlib\can.c **** 
2194:C:/StellarisWare/driverlib\can.c ****         //
2195:C:/StellarisWare/driverlib\can.c ****         // Wait for busy bit to clear
2196:C:/StellarisWare/driverlib\can.c ****         //
2197:C:/StellarisWare/driverlib\can.c ****         while(CANRegRead(ulBase + CAN_O_IF2CRQ) & CAN_IF1CRQ_BUSY)
 2346              		.loc 1 2197 0
 2347 0280 00BF     		nop
 2348              	.L124:
 2349              		.loc 1 2197 0 is_stmt 0 discriminator 1
 2350 0282 FB68     		ldr	r3, [r7, #12]
 2351 0284 03F18003 		add	r3, r3, #128
 2352 0288 1846     		mov	r0, r3
 2353 028a FFF7FEFF 		bl	CANRegRead
 2354 028e 0346     		mov	r3, r0
 2355 0290 03F40043 		and	r3, r3, #32768
 2356 0294 002B     		cmp	r3, #0
 2357 0296 F4D1     		bne	.L124
2198:C:/StellarisWare/driverlib\can.c ****         {
2199:C:/StellarisWare/driverlib\can.c ****         }
2200:C:/StellarisWare/driverlib\can.c **** 
2201:C:/StellarisWare/driverlib\can.c ****         //
2202:C:/StellarisWare/driverlib\can.c ****         // Indicate that there is new data in this message.
2203:C:/StellarisWare/driverlib\can.c ****         //
2204:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulFlags |= MSG_OBJ_NEW_DATA;
 2358              		.loc 1 2204 0 is_stmt 1
 2359 0298 7B68     		ldr	r3, [r7, #4]
 2360 029a 9B68     		ldr	r3, [r3, #8]
 2361 029c 43F08002 		orr	r2, r3, #128
 2362 02a0 7B68     		ldr	r3, [r7, #4]
 2363 02a2 9A60     		str	r2, [r3, #8]
 2364 02a4 03E0     		b	.L105
 2365              	.L122:
2205:C:/StellarisWare/driverlib\can.c ****     }
2206:C:/StellarisWare/driverlib\can.c ****     else
2207:C:/StellarisWare/driverlib\can.c ****     {
2208:C:/StellarisWare/driverlib\can.c ****         //
2209:C:/StellarisWare/driverlib\can.c ****         // Along with the MSG_OBJ_NEW_DATA not being set the amount of data
2210:C:/StellarisWare/driverlib\can.c ****         // needs to be set to zero if none was available.
2211:C:/StellarisWare/driverlib\can.c ****         //
2212:C:/StellarisWare/driverlib\can.c ****         pMsgObject->ulMsgLen = 0;
 2366              		.loc 1 2212 0
 2367 02a6 7B68     		ldr	r3, [r7, #4]
 2368 02a8 4FF00002 		mov	r2, #0
 2369 02ac DA60     		str	r2, [r3, #12]
 2370              	.L105:
2213:C:/StellarisWare/driverlib\can.c ****     }
2214:C:/StellarisWare/driverlib\can.c **** }
 2371              		.loc 1 2214 0
 2372 02ae 07F12007 		add	r7, r7, #32
 2373 02b2 BD46     		mov	sp, r7
 2374 02b4 80BD     		pop	{r7, pc}
 2375              		.cfi_endproc
 2376              	.LFE22:
 2378 02b6 00BF     		.section	.text.CANMessageClear,"ax",%progbits
 2379              		.align	2
 2380              		.global	CANMessageClear
 2381              		.thumb
 2382              		.thumb_func
 2384              	CANMessageClear:
 2385              	.LFB23:
2215:C:/StellarisWare/driverlib\can.c **** 
2216:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
2217:C:/StellarisWare/driverlib\can.c **** //
2218:C:/StellarisWare/driverlib\can.c **** //! Clears a message object so that it is no longer used.
2219:C:/StellarisWare/driverlib\can.c **** //!
2220:C:/StellarisWare/driverlib\can.c **** //! \param ulBase is the base address of the CAN controller.
2221:C:/StellarisWare/driverlib\can.c **** //! \param ulObjID is the message object number to disable (1-32).
2222:C:/StellarisWare/driverlib\can.c **** //!
2223:C:/StellarisWare/driverlib\can.c **** //! This function frees the specified message object from use.  Once a message
2224:C:/StellarisWare/driverlib\can.c **** //! object has been ``cleared,'' it no longer automatically sends or
2225:C:/StellarisWare/driverlib\can.c **** //! receives messages, nor does it generate interrupts.
2226:C:/StellarisWare/driverlib\can.c **** //!
2227:C:/StellarisWare/driverlib\can.c **** //! \return None.
2228:C:/StellarisWare/driverlib\can.c **** //
2229:C:/StellarisWare/driverlib\can.c **** //*****************************************************************************
2230:C:/StellarisWare/driverlib\can.c **** void
2231:C:/StellarisWare/driverlib\can.c **** CANMessageClear(unsigned long ulBase, unsigned long ulObjID)
2232:C:/StellarisWare/driverlib\can.c **** {
 2386              		.loc 1 2232 0
 2387              		.cfi_startproc
 2388              		@ args = 0, pretend = 0, frame = 8
 2389              		@ frame_needed = 1, uses_anonymous_args = 0
 2390 0000 80B5     		push	{r7, lr}
 2391              	.LCFI69:
 2392              		.cfi_def_cfa_offset 8
 2393              		.cfi_offset 14, -4
 2394              		.cfi_offset 7, -8
 2395 0002 82B0     		sub	sp, sp, #8
 2396              	.LCFI70:
 2397              		.cfi_def_cfa_offset 16
 2398 0004 00AF     		add	r7, sp, #0
 2399              	.LCFI71:
 2400              		.cfi_def_cfa_register 7
 2401 0006 7860     		str	r0, [r7, #4]
 2402 0008 3960     		str	r1, [r7, #0]
2233:C:/StellarisWare/driverlib\can.c ****     //
2234:C:/StellarisWare/driverlib\can.c ****     // Check the arguments.
2235:C:/StellarisWare/driverlib\can.c ****     //
2236:C:/StellarisWare/driverlib\can.c ****     ASSERT(CANBaseValid(ulBase));
2237:C:/StellarisWare/driverlib\can.c ****     ASSERT((ulObjID >= 1) && (ulObjID <= 32));
2238:C:/StellarisWare/driverlib\can.c **** 
2239:C:/StellarisWare/driverlib\can.c ****     //
2240:C:/StellarisWare/driverlib\can.c ****     // Wait for busy bit to clear
2241:C:/StellarisWare/driverlib\can.c ****     //
2242:C:/StellarisWare/driverlib\can.c ****     while(CANRegRead(ulBase + CAN_O_IF1CRQ) & CAN_IF1CRQ_BUSY)
 2403              		.loc 1 2242 0
 2404 000a 00BF     		nop
 2405              	.L127:
 2406              		.loc 1 2242 0 is_stmt 0 discriminator 1
 2407 000c 7B68     		ldr	r3, [r7, #4]
 2408 000e 03F12003 		add	r3, r3, #32
 2409 0012 1846     		mov	r0, r3
 2410 0014 FFF7FEFF 		bl	CANRegRead
 2411 0018 0346     		mov	r3, r0
 2412 001a 03F40043 		and	r3, r3, #32768
 2413 001e 002B     		cmp	r3, #0
 2414 0020 F4D1     		bne	.L127
2243:C:/StellarisWare/driverlib\can.c ****     {
2244:C:/StellarisWare/driverlib\can.c ****     }
2245:C:/StellarisWare/driverlib\can.c **** 
2246:C:/StellarisWare/driverlib\can.c ****     //
2247:C:/StellarisWare/driverlib\can.c ****     // Clear the message value bit in the arbitration register.  This indicates
2248:C:/StellarisWare/driverlib\can.c ****     // the message is not valid.
2249:C:/StellarisWare/driverlib\can.c ****     //
2250:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_ARB);
 2415              		.loc 1 2250 0 is_stmt 1
 2416 0022 7B68     		ldr	r3, [r7, #4]
 2417 0024 03F12403 		add	r3, r3, #36
 2418 0028 1846     		mov	r0, r3
 2419 002a 4FF0A001 		mov	r1, #160
 2420 002e FFF7FEFF 		bl	CANRegWrite
2251:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1ARB1, 0);
 2421              		.loc 1 2251 0
 2422 0032 7B68     		ldr	r3, [r7, #4]
 2423 0034 03F13003 		add	r3, r3, #48
 2424 0038 1846     		mov	r0, r3
 2425 003a 4FF00001 		mov	r1, #0
 2426 003e FFF7FEFF 		bl	CANRegWrite
2252:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1ARB2, 0);
 2427              		.loc 1 2252 0
 2428 0042 7B68     		ldr	r3, [r7, #4]
 2429 0044 03F13403 		add	r3, r3, #52
 2430 0048 1846     		mov	r0, r3
 2431 004a 4FF00001 		mov	r1, #0
 2432 004e FFF7FEFF 		bl	CANRegWrite
2253:C:/StellarisWare/driverlib\can.c **** 
2254:C:/StellarisWare/driverlib\can.c ****     //
2255:C:/StellarisWare/driverlib\can.c ****     // Initiate programming the message object
2256:C:/StellarisWare/driverlib\can.c ****     //
2257:C:/StellarisWare/driverlib\can.c ****     CANRegWrite(ulBase + CAN_O_IF1CRQ, ulObjID & CAN_IF1CRQ_MNUM_M);
 2433              		.loc 1 2257 0
 2434 0052 7B68     		ldr	r3, [r7, #4]
 2435 0054 03F12002 		add	r2, r3, #32
 2436 0058 3B68     		ldr	r3, [r7, #0]
 2437 005a 03F03F03 		and	r3, r3, #63
 2438 005e 1046     		mov	r0, r2
 2439 0060 1946     		mov	r1, r3
 2440 0062 FFF7FEFF 		bl	CANRegWrite
2258:C:/StellarisWare/driverlib\can.c **** }
 2441              		.loc 1 2258 0
 2442 0066 07F10807 		add	r7, r7, #8
 2443 006a BD46     		mov	sp, r7
 2444 006c 80BD     		pop	{r7, pc}
 2445              		.cfi_endproc
 2446              	.LFE23:
 2448 006e 00BF     		.text
 2449              	.Letext0:
 2450              		.file 2 "C:\\StellarisWare/driverlib/can.h"
 2451              		.file 3 "C:\\StellarisWare/inc/hw_types.h"
DEFINED SYMBOLS
                            *ABS*:00000000 can.c
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:19     .rodata:00000000 $d
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:22     .rodata:00000000 g_usCANBitValues
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:40     .text.CANIntNumberGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:44     .text.CANIntNumberGet:00000000 CANIntNumberGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:112    .text.CANRegRead:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:116    .text.CANRegRead:00000000 CANRegRead
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:200    .text.CANRegWrite:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:204    .text.CANRegWrite:00000000 CANRegWrite
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:250    .text.CANDataRegWrite:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:254    .text.CANDataRegWrite:00000000 CANDataRegWrite
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:328    .text.CANDataRegRead:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:332    .text.CANDataRegRead:00000000 CANDataRegRead
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:405    .text.CANInit:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:410    .text.CANInit:00000000 CANInit
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:545    .text.CANEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:550    .text.CANEnable:00000000 CANEnable
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:585    .text.CANDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:590    .text.CANDisable:00000000 CANDisable
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:625    .text.CANBitTimingGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:630    .text.CANBitTimingGet:00000000 CANBitTimingGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:705    .text.CANBitRateSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:710    .text.CANBitRateSet:00000000 CANBitRateSet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:853    .text.CANBitTimingSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:858    .text.CANBitTimingSet:00000000 CANBitTimingSet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:966    .text.CANIntRegister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:971    .text.CANIntRegister:00000000 CANIntRegister
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1010   .text.CANIntUnregister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1015   .text.CANIntUnregister:00000000 CANIntUnregister
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1052   .text.CANIntEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1057   .text.CANIntEnable:00000000 CANIntEnable
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1094   .text.CANIntDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1099   .text.CANIntDisable:00000000 CANIntDisable
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1137   .text.CANIntStatus:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1142   .text.CANIntStatus:00000000 CANIntStatus
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1218   .text.CANIntClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1223   .text.CANIntClear:00000000 CANIntClear
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1300   .text.CANRetrySet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1305   .text.CANRetrySet:00000000 CANRetrySet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1356   .text.CANRetryGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1361   .text.CANRetryGet:00000000 CANRetryGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1402   .text.CANStatusGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1407   .text.CANStatusGet:00000000 CANStatusGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1435   .text.CANStatusGet:00000018 $d
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1441   .text.CANStatusGet:00000028 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1529   .text.CANErrCntrGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1534   .text.CANErrCntrGet:00000000 CANErrCntrGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1592   .text.CANMessageSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1597   .text.CANMessageSet:00000000 CANMessageSet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1682   .text.CANMessageSet:00000084 $d
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:1689   .text.CANMessageSet:00000098 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:2001   .text.CANMessageGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:2006   .text.CANMessageGet:00000000 CANMessageGet
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:2379   .text.CANMessageClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccd0yuEX.s:2384   .text.CANMessageClear:00000000 CANMessageClear
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
IntDisable
IntEnable
IntRegister
IntUnregister
