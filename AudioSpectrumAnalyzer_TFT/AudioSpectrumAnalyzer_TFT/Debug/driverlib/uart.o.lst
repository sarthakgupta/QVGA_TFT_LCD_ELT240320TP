   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	g_ppulUARTIntMap:
  23 0000 00C00040 		.word	1073790976
  24 0004 15000000 		.word	21
  25 0008 00D00040 		.word	1073795072
  26 000c 16000000 		.word	22
  27 0010 00E00040 		.word	1073799168
  28 0014 31000000 		.word	49
  29 0018 00F00040 		.word	1073803264
  30 001c 4B000000 		.word	75
  31 0020 00000140 		.word	1073807360
  32 0024 4C000000 		.word	76
  33 0028 00100140 		.word	1073811456
  34 002c 4D000000 		.word	77
  35 0030 00200140 		.word	1073815552
  36 0034 4E000000 		.word	78
  37 0038 00300140 		.word	1073819648
  38 003c 4F000000 		.word	79
  39              		.section	.text.UARTIntNumberGet,"ax",%progbits
  40              		.align	2
  41              		.thumb
  42              		.thumb_func
  44              	UARTIntNumberGet:
  45              	.LFB0:
  46              		.file 1 "C:/StellarisWare/driverlib/uart.c"
   1:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
   2:C:/StellarisWare/driverlib\uart.c **** //
   3:C:/StellarisWare/driverlib\uart.c **** // uart.c - Driver for the UART.
   4:C:/StellarisWare/driverlib\uart.c **** //
   5:C:/StellarisWare/driverlib\uart.c **** // Copyright (c) 2005-2012 Texas Instruments Incorporated.  All rights reserved.
   6:C:/StellarisWare/driverlib\uart.c **** // Software License Agreement
   7:C:/StellarisWare/driverlib\uart.c **** // 
   8:C:/StellarisWare/driverlib\uart.c **** //   Redistribution and use in source and binary forms, with or without
   9:C:/StellarisWare/driverlib\uart.c **** //   modification, are permitted provided that the following conditions
  10:C:/StellarisWare/driverlib\uart.c **** //   are met:
  11:C:/StellarisWare/driverlib\uart.c **** // 
  12:C:/StellarisWare/driverlib\uart.c **** //   Redistributions of source code must retain the above copyright
  13:C:/StellarisWare/driverlib\uart.c **** //   notice, this list of conditions and the following disclaimer.
  14:C:/StellarisWare/driverlib\uart.c **** // 
  15:C:/StellarisWare/driverlib\uart.c **** //   Redistributions in binary form must reproduce the above copyright
  16:C:/StellarisWare/driverlib\uart.c **** //   notice, this list of conditions and the following disclaimer in the
  17:C:/StellarisWare/driverlib\uart.c **** //   documentation and/or other materials provided with the  
  18:C:/StellarisWare/driverlib\uart.c **** //   distribution.
  19:C:/StellarisWare/driverlib\uart.c **** // 
  20:C:/StellarisWare/driverlib\uart.c **** //   Neither the name of Texas Instruments Incorporated nor the names of
  21:C:/StellarisWare/driverlib\uart.c **** //   its contributors may be used to endorse or promote products derived
  22:C:/StellarisWare/driverlib\uart.c **** //   from this software without specific prior written permission.
  23:C:/StellarisWare/driverlib\uart.c **** // 
  24:C:/StellarisWare/driverlib\uart.c **** // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  25:C:/StellarisWare/driverlib\uart.c **** // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  26:C:/StellarisWare/driverlib\uart.c **** // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  27:C:/StellarisWare/driverlib\uart.c **** // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  28:C:/StellarisWare/driverlib\uart.c **** // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  29:C:/StellarisWare/driverlib\uart.c **** // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  30:C:/StellarisWare/driverlib\uart.c **** // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  31:C:/StellarisWare/driverlib\uart.c **** // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  32:C:/StellarisWare/driverlib\uart.c **** // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  33:C:/StellarisWare/driverlib\uart.c **** // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  34:C:/StellarisWare/driverlib\uart.c **** // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/StellarisWare/driverlib\uart.c **** // 
  36:C:/StellarisWare/driverlib\uart.c **** // This is part of revision 9107 of the Stellaris Peripheral Driver Library.
  37:C:/StellarisWare/driverlib\uart.c **** //
  38:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  39:C:/StellarisWare/driverlib\uart.c **** 
  40:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  41:C:/StellarisWare/driverlib\uart.c **** //
  42:C:/StellarisWare/driverlib\uart.c **** //! \addtogroup uart_api
  43:C:/StellarisWare/driverlib\uart.c **** //! @{
  44:C:/StellarisWare/driverlib\uart.c **** //
  45:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  46:C:/StellarisWare/driverlib\uart.c **** 
  47:C:/StellarisWare/driverlib\uart.c **** #include "inc/hw_ints.h"
  48:C:/StellarisWare/driverlib\uart.c **** #include "inc/hw_memmap.h"
  49:C:/StellarisWare/driverlib\uart.c **** #include "inc/hw_sysctl.h"
  50:C:/StellarisWare/driverlib\uart.c **** #include "inc/hw_types.h"
  51:C:/StellarisWare/driverlib\uart.c **** #include "inc/hw_uart.h"
  52:C:/StellarisWare/driverlib\uart.c **** #include "driverlib/debug.h"
  53:C:/StellarisWare/driverlib\uart.c **** #include "driverlib/interrupt.h"
  54:C:/StellarisWare/driverlib\uart.c **** #include "driverlib/uart.h"
  55:C:/StellarisWare/driverlib\uart.c **** 
  56:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  57:C:/StellarisWare/driverlib\uart.c **** //
  58:C:/StellarisWare/driverlib\uart.c **** // The system clock divider defining the maximum baud rate supported by the
  59:C:/StellarisWare/driverlib\uart.c **** // UART.
  60:C:/StellarisWare/driverlib\uart.c **** //
  61:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  62:C:/StellarisWare/driverlib\uart.c **** #define UART_CLK_DIVIDER        ((CLASS_IS_SANDSTORM ||                       \
  63:C:/StellarisWare/driverlib\uart.c ****                                   (CLASS_IS_FURY && REVISION_IS_A2) ||        \
  64:C:/StellarisWare/driverlib\uart.c ****                                   (CLASS_IS_DUSTDEVIL && REVISION_IS_A0)) ?   \
  65:C:/StellarisWare/driverlib\uart.c ****                                  16 : 8)
  66:C:/StellarisWare/driverlib\uart.c **** 
  67:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  68:C:/StellarisWare/driverlib\uart.c **** //
  69:C:/StellarisWare/driverlib\uart.c **** // A mapping of UART base address to interupt number.
  70:C:/StellarisWare/driverlib\uart.c **** //
  71:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  72:C:/StellarisWare/driverlib\uart.c **** static const unsigned long g_ppulUARTIntMap[][2] =
  73:C:/StellarisWare/driverlib\uart.c **** {
  74:C:/StellarisWare/driverlib\uart.c ****     { UART0_BASE, INT_UART0 },
  75:C:/StellarisWare/driverlib\uart.c ****     { UART1_BASE, INT_UART1 },
  76:C:/StellarisWare/driverlib\uart.c ****     { UART2_BASE, INT_UART2 },
  77:C:/StellarisWare/driverlib\uart.c ****     { UART3_BASE, INT_UART3 },
  78:C:/StellarisWare/driverlib\uart.c ****     { UART4_BASE, INT_UART4 },
  79:C:/StellarisWare/driverlib\uart.c ****     { UART5_BASE, INT_UART5 },
  80:C:/StellarisWare/driverlib\uart.c ****     { UART6_BASE, INT_UART6 },
  81:C:/StellarisWare/driverlib\uart.c ****     { UART7_BASE, INT_UART7 },
  82:C:/StellarisWare/driverlib\uart.c **** };
  83:C:/StellarisWare/driverlib\uart.c **** 
  84:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  85:C:/StellarisWare/driverlib\uart.c **** //
  86:C:/StellarisWare/driverlib\uart.c **** //! \internal
  87:C:/StellarisWare/driverlib\uart.c **** //! Checks a UART base address.
  88:C:/StellarisWare/driverlib\uart.c **** //!
  89:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
  90:C:/StellarisWare/driverlib\uart.c **** //!
  91:C:/StellarisWare/driverlib\uart.c **** //! This function determines if a UART port base address is valid.
  92:C:/StellarisWare/driverlib\uart.c **** //!
  93:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b true if the base address is valid and \b false
  94:C:/StellarisWare/driverlib\uart.c **** //! otherwise.
  95:C:/StellarisWare/driverlib\uart.c **** //
  96:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
  97:C:/StellarisWare/driverlib\uart.c **** #ifdef DEBUG
  98:C:/StellarisWare/driverlib\uart.c **** static tBoolean
  99:C:/StellarisWare/driverlib\uart.c **** UARTBaseValid(unsigned long ulBase)
 100:C:/StellarisWare/driverlib\uart.c **** {
 101:C:/StellarisWare/driverlib\uart.c ****     return((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
 102:C:/StellarisWare/driverlib\uart.c ****            (ulBase == UART2_BASE) || (ulBase == UART3_BASE) ||
 103:C:/StellarisWare/driverlib\uart.c ****            (ulBase == UART4_BASE) || (ulBase == UART5_BASE) ||
 104:C:/StellarisWare/driverlib\uart.c ****            (ulBase == UART6_BASE) || (ulBase == UART7_BASE));
 105:C:/StellarisWare/driverlib\uart.c **** }
 106:C:/StellarisWare/driverlib\uart.c **** #endif
 107:C:/StellarisWare/driverlib\uart.c **** 
 108:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 109:C:/StellarisWare/driverlib\uart.c **** //
 110:C:/StellarisWare/driverlib\uart.c **** //! \internal
 111:C:/StellarisWare/driverlib\uart.c **** //! Gets the UART interrupt number.
 112:C:/StellarisWare/driverlib\uart.c **** //!
 113:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 114:C:/StellarisWare/driverlib\uart.c **** //!
 115:C:/StellarisWare/driverlib\uart.c **** //! Given a UART base address, this function returns the corresponding
 116:C:/StellarisWare/driverlib\uart.c **** //! interrupt number.
 117:C:/StellarisWare/driverlib\uart.c **** //!
 118:C:/StellarisWare/driverlib\uart.c **** //! \return Returns a UART interrupt number, or -1 if \e ulBase is invalid.
 119:C:/StellarisWare/driverlib\uart.c **** //
 120:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 121:C:/StellarisWare/driverlib\uart.c **** static long
 122:C:/StellarisWare/driverlib\uart.c **** UARTIntNumberGet(unsigned long ulBase)
 123:C:/StellarisWare/driverlib\uart.c **** {
  47              		.loc 1 123 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 16
  50              		@ frame_needed = 1, uses_anonymous_args = 0
  51              		@ link register save eliminated.
  52 0000 80B4     		push	{r7}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 4
  55              		.cfi_offset 7, -4
  56 0002 85B0     		sub	sp, sp, #20
  57              	.LCFI1:
  58              		.cfi_def_cfa_offset 24
  59 0004 00AF     		add	r7, sp, #0
  60              	.LCFI2:
  61              		.cfi_def_cfa_register 7
  62 0006 7860     		str	r0, [r7, #4]
 124:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulIdx;
 125:C:/StellarisWare/driverlib\uart.c **** 
 126:C:/StellarisWare/driverlib\uart.c ****     //
 127:C:/StellarisWare/driverlib\uart.c ****     // Loop through the table that maps UART base addresses to interrupt
 128:C:/StellarisWare/driverlib\uart.c ****     // numbers.
 129:C:/StellarisWare/driverlib\uart.c ****     //
 130:C:/StellarisWare/driverlib\uart.c ****     for(ulIdx = 0; ulIdx < (sizeof(g_ppulUARTIntMap) /
  63              		.loc 1 130 0
  64 0008 4FF00003 		mov	r3, #0
  65 000c FB60     		str	r3, [r7, #12]
  66 000e 17E0     		b	.L2
  67              	.L5:
 131:C:/StellarisWare/driverlib\uart.c ****                             sizeof(g_ppulUARTIntMap[0])); ulIdx++)
 132:C:/StellarisWare/driverlib\uart.c ****     {
 133:C:/StellarisWare/driverlib\uart.c ****         //
 134:C:/StellarisWare/driverlib\uart.c ****         // See if this base address matches.
 135:C:/StellarisWare/driverlib\uart.c ****         //
 136:C:/StellarisWare/driverlib\uart.c ****         if(g_ppulUARTIntMap[ulIdx][0] == ulBase)
  68              		.loc 1 136 0
  69 0010 40F20003 		movw	r3, #:lower16:g_ppulUARTIntMap
  70 0014 C0F20003 		movt	r3, #:upper16:g_ppulUARTIntMap
  71 0018 FA68     		ldr	r2, [r7, #12]
  72 001a 53F83220 		ldr	r2, [r3, r2, lsl #3]
  73 001e 7B68     		ldr	r3, [r7, #4]
  74 0020 9A42     		cmp	r2, r3
  75 0022 09D1     		bne	.L3
 137:C:/StellarisWare/driverlib\uart.c ****         {
 138:C:/StellarisWare/driverlib\uart.c ****             //
 139:C:/StellarisWare/driverlib\uart.c ****             // Return the corresponding interrupt number.
 140:C:/StellarisWare/driverlib\uart.c ****             //
 141:C:/StellarisWare/driverlib\uart.c ****             return(g_ppulUARTIntMap[ulIdx][1]);
  76              		.loc 1 141 0
  77 0024 40F20002 		movw	r2, #:lower16:g_ppulUARTIntMap
  78 0028 C0F20002 		movt	r2, #:upper16:g_ppulUARTIntMap
  79 002c FB68     		ldr	r3, [r7, #12]
  80 002e 4FEAC303 		lsl	r3, r3, #3
  81 0032 D318     		adds	r3, r2, r3
  82 0034 5B68     		ldr	r3, [r3, #4]
  83 0036 08E0     		b	.L4
  84              	.L3:
 131:C:/StellarisWare/driverlib\uart.c ****                             sizeof(g_ppulUARTIntMap[0])); ulIdx++)
  85              		.loc 1 131 0
  86 0038 FB68     		ldr	r3, [r7, #12]
  87 003a 03F10103 		add	r3, r3, #1
  88 003e FB60     		str	r3, [r7, #12]
  89              	.L2:
 130:C:/StellarisWare/driverlib\uart.c ****     for(ulIdx = 0; ulIdx < (sizeof(g_ppulUARTIntMap) /
  90              		.loc 1 130 0 discriminator 1
  91 0040 FB68     		ldr	r3, [r7, #12]
  92 0042 072B     		cmp	r3, #7
  93 0044 E4D9     		bls	.L5
 142:C:/StellarisWare/driverlib\uart.c ****         }
 143:C:/StellarisWare/driverlib\uart.c ****     }
 144:C:/StellarisWare/driverlib\uart.c **** 
 145:C:/StellarisWare/driverlib\uart.c ****     //
 146:C:/StellarisWare/driverlib\uart.c ****     // The base address could not be found, so return an error.
 147:C:/StellarisWare/driverlib\uart.c ****     //
 148:C:/StellarisWare/driverlib\uart.c ****     return(-1);
  94              		.loc 1 148 0
  95 0046 4FF0FF33 		mov	r3, #-1
  96              	.L4:
 149:C:/StellarisWare/driverlib\uart.c **** }
  97              		.loc 1 149 0
  98 004a 1846     		mov	r0, r3
  99 004c 07F11407 		add	r7, r7, #20
 100 0050 BD46     		mov	sp, r7
 101 0052 80BC     		pop	{r7}
 102 0054 7047     		bx	lr
 103              		.cfi_endproc
 104              	.LFE0:
 106 0056 00BF     		.section	.text.UARTParityModeSet,"ax",%progbits
 107              		.align	2
 108              		.global	UARTParityModeSet
 109              		.thumb
 110              		.thumb_func
 112              	UARTParityModeSet:
 113              	.LFB1:
 150:C:/StellarisWare/driverlib\uart.c **** 
 151:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 152:C:/StellarisWare/driverlib\uart.c **** //
 153:C:/StellarisWare/driverlib\uart.c **** //! Sets the type of parity.
 154:C:/StellarisWare/driverlib\uart.c **** //!
 155:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 156:C:/StellarisWare/driverlib\uart.c **** //! \param ulParity specifies the type of parity to use.
 157:C:/StellarisWare/driverlib\uart.c **** //!
 158:C:/StellarisWare/driverlib\uart.c **** //! This function configures the type of parity to use for transmitting and
 159:C:/StellarisWare/driverlib\uart.c **** //! expect when receiving.  The \e ulParity parameter must be one of
 160:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_PAR_NONE, \b UART_CONFIG_PAR_EVEN, \b UART_CONFIG_PAR_ODD,
 161:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_PAR_ONE, or \b UART_CONFIG_PAR_ZERO.  The last two
 162:C:/StellarisWare/driverlib\uart.c **** //! parameters allow direct control of the parity bit; it is always either one
 163:C:/StellarisWare/driverlib\uart.c **** //! or zero based on the mode.
 164:C:/StellarisWare/driverlib\uart.c **** //!
 165:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 166:C:/StellarisWare/driverlib\uart.c **** //
 167:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 168:C:/StellarisWare/driverlib\uart.c **** void
 169:C:/StellarisWare/driverlib\uart.c **** UARTParityModeSet(unsigned long ulBase, unsigned long ulParity)
 170:C:/StellarisWare/driverlib\uart.c **** {
 114              		.loc 1 170 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 8
 117              		@ frame_needed = 1, uses_anonymous_args = 0
 118              		@ link register save eliminated.
 119 0000 80B4     		push	{r7}
 120              	.LCFI3:
 121              		.cfi_def_cfa_offset 4
 122              		.cfi_offset 7, -4
 123 0002 83B0     		sub	sp, sp, #12
 124              	.LCFI4:
 125              		.cfi_def_cfa_offset 16
 126 0004 00AF     		add	r7, sp, #0
 127              	.LCFI5:
 128              		.cfi_def_cfa_register 7
 129 0006 7860     		str	r0, [r7, #4]
 130 0008 3960     		str	r1, [r7, #0]
 171:C:/StellarisWare/driverlib\uart.c ****     //
 172:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 173:C:/StellarisWare/driverlib\uart.c ****     //
 174:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 175:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulParity == UART_CONFIG_PAR_NONE) ||
 176:C:/StellarisWare/driverlib\uart.c ****            (ulParity == UART_CONFIG_PAR_EVEN) ||
 177:C:/StellarisWare/driverlib\uart.c ****            (ulParity == UART_CONFIG_PAR_ODD) ||
 178:C:/StellarisWare/driverlib\uart.c ****            (ulParity == UART_CONFIG_PAR_ONE) ||
 179:C:/StellarisWare/driverlib\uart.c ****            (ulParity == UART_CONFIG_PAR_ZERO));
 180:C:/StellarisWare/driverlib\uart.c **** 
 181:C:/StellarisWare/driverlib\uart.c ****     //
 182:C:/StellarisWare/driverlib\uart.c ****     // Set the parity mode.
 183:C:/StellarisWare/driverlib\uart.c ****     //
 184:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ((HWREG(ulBase + UART_O_LCRH) &
 131              		.loc 1 184 0
 132 000a 7B68     		ldr	r3, [r7, #4]
 133 000c 03F12C03 		add	r3, r3, #44
 134 0010 7A68     		ldr	r2, [r7, #4]
 135 0012 02F12C02 		add	r2, r2, #44
 136 0016 1268     		ldr	r2, [r2, #0]
 137 0018 22F08601 		bic	r1, r2, #134
 185:C:/StellarisWare/driverlib\uart.c ****                                     ~(UART_LCRH_SPS | UART_LCRH_EPS |
 186:C:/StellarisWare/driverlib\uart.c ****                                       UART_LCRH_PEN)) | ulParity);
 138              		.loc 1 186 0
 139 001c 3A68     		ldr	r2, [r7, #0]
 140 001e 0A43     		orrs	r2, r2, r1
 184:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ((HWREG(ulBase + UART_O_LCRH) &
 141              		.loc 1 184 0
 142 0020 1A60     		str	r2, [r3, #0]
 187:C:/StellarisWare/driverlib\uart.c **** }
 143              		.loc 1 187 0
 144 0022 07F10C07 		add	r7, r7, #12
 145 0026 BD46     		mov	sp, r7
 146 0028 80BC     		pop	{r7}
 147 002a 7047     		bx	lr
 148              		.cfi_endproc
 149              	.LFE1:
 151              		.section	.text.UARTParityModeGet,"ax",%progbits
 152              		.align	2
 153              		.global	UARTParityModeGet
 154              		.thumb
 155              		.thumb_func
 157              	UARTParityModeGet:
 158              	.LFB2:
 188:C:/StellarisWare/driverlib\uart.c **** 
 189:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 190:C:/StellarisWare/driverlib\uart.c **** //
 191:C:/StellarisWare/driverlib\uart.c **** //! Gets the type of parity currently being used.
 192:C:/StellarisWare/driverlib\uart.c **** //!
 193:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 194:C:/StellarisWare/driverlib\uart.c **** //!
 195:C:/StellarisWare/driverlib\uart.c **** //! This function gets the type of parity used for transmitting data and
 196:C:/StellarisWare/driverlib\uart.c **** //! expected when receiving data.
 197:C:/StellarisWare/driverlib\uart.c **** //!
 198:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the current parity settings, specified as one of
 199:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_PAR_NONE, \b UART_CONFIG_PAR_EVEN, \b UART_CONFIG_PAR_ODD,
 200:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_PAR_ONE, or \b UART_CONFIG_PAR_ZERO.
 201:C:/StellarisWare/driverlib\uart.c **** //
 202:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 203:C:/StellarisWare/driverlib\uart.c **** unsigned long
 204:C:/StellarisWare/driverlib\uart.c **** UARTParityModeGet(unsigned long ulBase)
 205:C:/StellarisWare/driverlib\uart.c **** {
 159              		.loc 1 205 0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 8
 162              		@ frame_needed = 1, uses_anonymous_args = 0
 163              		@ link register save eliminated.
 164 0000 80B4     		push	{r7}
 165              	.LCFI6:
 166              		.cfi_def_cfa_offset 4
 167              		.cfi_offset 7, -4
 168 0002 83B0     		sub	sp, sp, #12
 169              	.LCFI7:
 170              		.cfi_def_cfa_offset 16
 171 0004 00AF     		add	r7, sp, #0
 172              	.LCFI8:
 173              		.cfi_def_cfa_register 7
 174 0006 7860     		str	r0, [r7, #4]
 206:C:/StellarisWare/driverlib\uart.c ****     //
 207:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 208:C:/StellarisWare/driverlib\uart.c ****     //
 209:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 210:C:/StellarisWare/driverlib\uart.c **** 
 211:C:/StellarisWare/driverlib\uart.c ****     //
 212:C:/StellarisWare/driverlib\uart.c ****     // Return the current parity setting.
 213:C:/StellarisWare/driverlib\uart.c ****     //
 214:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_LCRH) &
 175              		.loc 1 214 0
 176 0008 7B68     		ldr	r3, [r7, #4]
 177 000a 03F12C03 		add	r3, r3, #44
 178 000e 1B68     		ldr	r3, [r3, #0]
 179 0010 03F08603 		and	r3, r3, #134
 215:C:/StellarisWare/driverlib\uart.c ****            (UART_LCRH_SPS | UART_LCRH_EPS | UART_LCRH_PEN));
 216:C:/StellarisWare/driverlib\uart.c **** }
 180              		.loc 1 216 0
 181 0014 1846     		mov	r0, r3
 182 0016 07F10C07 		add	r7, r7, #12
 183 001a BD46     		mov	sp, r7
 184 001c 80BC     		pop	{r7}
 185 001e 7047     		bx	lr
 186              		.cfi_endproc
 187              	.LFE2:
 189              		.section	.text.UARTFIFOLevelSet,"ax",%progbits
 190              		.align	2
 191              		.global	UARTFIFOLevelSet
 192              		.thumb
 193              		.thumb_func
 195              	UARTFIFOLevelSet:
 196              	.LFB3:
 217:C:/StellarisWare/driverlib\uart.c **** 
 218:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 219:C:/StellarisWare/driverlib\uart.c **** //
 220:C:/StellarisWare/driverlib\uart.c **** //! Sets the FIFO level at which interrupts are generated.
 221:C:/StellarisWare/driverlib\uart.c **** //!
 222:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 223:C:/StellarisWare/driverlib\uart.c **** //! \param ulTxLevel is the transmit FIFO interrupt level, specified as one of
 224:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_TX1_8, \b UART_FIFO_TX2_8, \b UART_FIFO_TX4_8,
 225:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_TX6_8, or \b UART_FIFO_TX7_8.
 226:C:/StellarisWare/driverlib\uart.c **** //! \param ulRxLevel is the receive FIFO interrupt level, specified as one of
 227:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_RX1_8, \b UART_FIFO_RX2_8, \b UART_FIFO_RX4_8,
 228:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_RX6_8, or \b UART_FIFO_RX7_8.
 229:C:/StellarisWare/driverlib\uart.c **** //!
 230:C:/StellarisWare/driverlib\uart.c **** //! This function configures the FIFO level at which transmit and receive
 231:C:/StellarisWare/driverlib\uart.c **** //! interrupts are generated.
 232:C:/StellarisWare/driverlib\uart.c **** //!
 233:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 234:C:/StellarisWare/driverlib\uart.c **** //
 235:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 236:C:/StellarisWare/driverlib\uart.c **** void
 237:C:/StellarisWare/driverlib\uart.c **** UARTFIFOLevelSet(unsigned long ulBase, unsigned long ulTxLevel,
 238:C:/StellarisWare/driverlib\uart.c ****                  unsigned long ulRxLevel)
 239:C:/StellarisWare/driverlib\uart.c **** {
 197              		.loc 1 239 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 16
 200              		@ frame_needed = 1, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 202 0000 80B4     		push	{r7}
 203              	.LCFI9:
 204              		.cfi_def_cfa_offset 4
 205              		.cfi_offset 7, -4
 206 0002 85B0     		sub	sp, sp, #20
 207              	.LCFI10:
 208              		.cfi_def_cfa_offset 24
 209 0004 00AF     		add	r7, sp, #0
 210              	.LCFI11:
 211              		.cfi_def_cfa_register 7
 212 0006 F860     		str	r0, [r7, #12]
 213 0008 B960     		str	r1, [r7, #8]
 214 000a 7A60     		str	r2, [r7, #4]
 240:C:/StellarisWare/driverlib\uart.c ****     //
 241:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 242:C:/StellarisWare/driverlib\uart.c ****     //
 243:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 244:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulTxLevel == UART_FIFO_TX1_8) ||
 245:C:/StellarisWare/driverlib\uart.c ****            (ulTxLevel == UART_FIFO_TX2_8) ||
 246:C:/StellarisWare/driverlib\uart.c ****            (ulTxLevel == UART_FIFO_TX4_8) ||
 247:C:/StellarisWare/driverlib\uart.c ****            (ulTxLevel == UART_FIFO_TX6_8) ||
 248:C:/StellarisWare/driverlib\uart.c ****            (ulTxLevel == UART_FIFO_TX7_8));
 249:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulRxLevel == UART_FIFO_RX1_8) ||
 250:C:/StellarisWare/driverlib\uart.c ****            (ulRxLevel == UART_FIFO_RX2_8) ||
 251:C:/StellarisWare/driverlib\uart.c ****            (ulRxLevel == UART_FIFO_RX4_8) ||
 252:C:/StellarisWare/driverlib\uart.c ****            (ulRxLevel == UART_FIFO_RX6_8) ||
 253:C:/StellarisWare/driverlib\uart.c ****            (ulRxLevel == UART_FIFO_RX7_8));
 254:C:/StellarisWare/driverlib\uart.c **** 
 255:C:/StellarisWare/driverlib\uart.c ****     //
 256:C:/StellarisWare/driverlib\uart.c ****     // Set the FIFO interrupt levels.
 257:C:/StellarisWare/driverlib\uart.c ****     //
 258:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_IFLS) = ulTxLevel | ulRxLevel;
 215              		.loc 1 258 0
 216 000c FB68     		ldr	r3, [r7, #12]
 217 000e 03F13403 		add	r3, r3, #52
 218 0012 B968     		ldr	r1, [r7, #8]
 219 0014 7A68     		ldr	r2, [r7, #4]
 220 0016 0A43     		orrs	r2, r2, r1
 221 0018 1A60     		str	r2, [r3, #0]
 259:C:/StellarisWare/driverlib\uart.c **** }
 222              		.loc 1 259 0
 223 001a 07F11407 		add	r7, r7, #20
 224 001e BD46     		mov	sp, r7
 225 0020 80BC     		pop	{r7}
 226 0022 7047     		bx	lr
 227              		.cfi_endproc
 228              	.LFE3:
 230              		.section	.text.UARTFIFOLevelGet,"ax",%progbits
 231              		.align	2
 232              		.global	UARTFIFOLevelGet
 233              		.thumb
 234              		.thumb_func
 236              	UARTFIFOLevelGet:
 237              	.LFB4:
 260:C:/StellarisWare/driverlib\uart.c **** 
 261:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 262:C:/StellarisWare/driverlib\uart.c **** //
 263:C:/StellarisWare/driverlib\uart.c **** //! Gets the FIFO level at which interrupts are generated.
 264:C:/StellarisWare/driverlib\uart.c **** //!
 265:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 266:C:/StellarisWare/driverlib\uart.c **** //! \param pulTxLevel is a pointer to storage for the transmit FIFO level,
 267:C:/StellarisWare/driverlib\uart.c **** //! returned as one of \b UART_FIFO_TX1_8, \b UART_FIFO_TX2_8,
 268:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_TX4_8, \b UART_FIFO_TX6_8, or \b UART_FIFO_TX7_8.
 269:C:/StellarisWare/driverlib\uart.c **** //! \param pulRxLevel is a pointer to storage for the receive FIFO level,
 270:C:/StellarisWare/driverlib\uart.c **** //! returned as one of \b UART_FIFO_RX1_8, \b UART_FIFO_RX2_8,
 271:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FIFO_RX4_8, \b UART_FIFO_RX6_8, or \b UART_FIFO_RX7_8.
 272:C:/StellarisWare/driverlib\uart.c **** //!
 273:C:/StellarisWare/driverlib\uart.c **** //! This function gets the FIFO level at which transmit and receive interrupts
 274:C:/StellarisWare/driverlib\uart.c **** //! are generated.
 275:C:/StellarisWare/driverlib\uart.c **** //!
 276:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 277:C:/StellarisWare/driverlib\uart.c **** //
 278:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 279:C:/StellarisWare/driverlib\uart.c **** void
 280:C:/StellarisWare/driverlib\uart.c **** UARTFIFOLevelGet(unsigned long ulBase, unsigned long *pulTxLevel,
 281:C:/StellarisWare/driverlib\uart.c ****                  unsigned long *pulRxLevel)
 282:C:/StellarisWare/driverlib\uart.c **** {
 238              		.loc 1 282 0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 24
 241              		@ frame_needed = 1, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 243 0000 80B4     		push	{r7}
 244              	.LCFI12:
 245              		.cfi_def_cfa_offset 4
 246              		.cfi_offset 7, -4
 247 0002 87B0     		sub	sp, sp, #28
 248              	.LCFI13:
 249              		.cfi_def_cfa_offset 32
 250 0004 00AF     		add	r7, sp, #0
 251              	.LCFI14:
 252              		.cfi_def_cfa_register 7
 253 0006 F860     		str	r0, [r7, #12]
 254 0008 B960     		str	r1, [r7, #8]
 255 000a 7A60     		str	r2, [r7, #4]
 283:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulTemp;
 284:C:/StellarisWare/driverlib\uart.c **** 
 285:C:/StellarisWare/driverlib\uart.c ****     //
 286:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 287:C:/StellarisWare/driverlib\uart.c ****     //
 288:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 289:C:/StellarisWare/driverlib\uart.c **** 
 290:C:/StellarisWare/driverlib\uart.c ****     //
 291:C:/StellarisWare/driverlib\uart.c ****     // Read the FIFO level register.
 292:C:/StellarisWare/driverlib\uart.c ****     //
 293:C:/StellarisWare/driverlib\uart.c ****     ulTemp = HWREG(ulBase + UART_O_IFLS);
 256              		.loc 1 293 0
 257 000c FB68     		ldr	r3, [r7, #12]
 258 000e 03F13403 		add	r3, r3, #52
 259 0012 1B68     		ldr	r3, [r3, #0]
 260 0014 7B61     		str	r3, [r7, #20]
 294:C:/StellarisWare/driverlib\uart.c **** 
 295:C:/StellarisWare/driverlib\uart.c ****     //
 296:C:/StellarisWare/driverlib\uart.c ****     // Extract the transmit and receive FIFO levels.
 297:C:/StellarisWare/driverlib\uart.c ****     //
 298:C:/StellarisWare/driverlib\uart.c ****     *pulTxLevel = ulTemp & UART_IFLS_TX_M;
 261              		.loc 1 298 0
 262 0016 7B69     		ldr	r3, [r7, #20]
 263 0018 03F00702 		and	r2, r3, #7
 264 001c BB68     		ldr	r3, [r7, #8]
 265 001e 1A60     		str	r2, [r3, #0]
 299:C:/StellarisWare/driverlib\uart.c ****     *pulRxLevel = ulTemp & UART_IFLS_RX_M;
 266              		.loc 1 299 0
 267 0020 7B69     		ldr	r3, [r7, #20]
 268 0022 03F03802 		and	r2, r3, #56
 269 0026 7B68     		ldr	r3, [r7, #4]
 270 0028 1A60     		str	r2, [r3, #0]
 300:C:/StellarisWare/driverlib\uart.c **** }
 271              		.loc 1 300 0
 272 002a 07F11C07 		add	r7, r7, #28
 273 002e BD46     		mov	sp, r7
 274 0030 80BC     		pop	{r7}
 275 0032 7047     		bx	lr
 276              		.cfi_endproc
 277              	.LFE4:
 279              		.section	.text.UARTConfigSetExpClk,"ax",%progbits
 280              		.align	2
 281              		.global	UARTConfigSetExpClk
 282              		.thumb
 283              		.thumb_func
 285              	UARTConfigSetExpClk:
 286              	.LFB5:
 301:C:/StellarisWare/driverlib\uart.c **** 
 302:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 303:C:/StellarisWare/driverlib\uart.c **** //
 304:C:/StellarisWare/driverlib\uart.c **** //! Sets the configuration of a UART.
 305:C:/StellarisWare/driverlib\uart.c **** //!
 306:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 307:C:/StellarisWare/driverlib\uart.c **** //! \param ulUARTClk is the rate of the clock supplied to the UART module.
 308:C:/StellarisWare/driverlib\uart.c **** //! \param ulBaud is the desired baud rate.
 309:C:/StellarisWare/driverlib\uart.c **** //! \param ulConfig is the data format for the port (number of data bits,
 310:C:/StellarisWare/driverlib\uart.c **** //! number of stop bits, and parity).
 311:C:/StellarisWare/driverlib\uart.c **** //!
 312:C:/StellarisWare/driverlib\uart.c **** //! This function configures the UART for operation in the specified data
 313:C:/StellarisWare/driverlib\uart.c **** //! format.  The baud rate is provided in the \e ulBaud parameter and the data
 314:C:/StellarisWare/driverlib\uart.c **** //! format in the \e ulConfig parameter.
 315:C:/StellarisWare/driverlib\uart.c **** //!
 316:C:/StellarisWare/driverlib\uart.c **** //! The \e ulConfig parameter is the logical OR of three values: the number of
 317:C:/StellarisWare/driverlib\uart.c **** //! data bits, the number of stop bits, and the parity.  \b UART_CONFIG_WLEN_8,
 318:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_WLEN_7, \b UART_CONFIG_WLEN_6, and \b UART_CONFIG_WLEN_5
 319:C:/StellarisWare/driverlib\uart.c **** //! select from eight to five data bits per byte (respectively).
 320:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_STOP_ONE and \b UART_CONFIG_STOP_TWO select one or two stop
 321:C:/StellarisWare/driverlib\uart.c **** //! bits (respectively).  \b UART_CONFIG_PAR_NONE, \b UART_CONFIG_PAR_EVEN,
 322:C:/StellarisWare/driverlib\uart.c **** //! \b UART_CONFIG_PAR_ODD, \b UART_CONFIG_PAR_ONE, and \b UART_CONFIG_PAR_ZERO
 323:C:/StellarisWare/driverlib\uart.c **** //! select the parity mode (no parity bit, even parity bit, odd parity bit,
 324:C:/StellarisWare/driverlib\uart.c **** //! parity bit always one, and parity bit always zero, respectively).
 325:C:/StellarisWare/driverlib\uart.c **** //!
 326:C:/StellarisWare/driverlib\uart.c **** //! The peripheral clock is the same as the processor clock.  The frequency of
 327:C:/StellarisWare/driverlib\uart.c **** //! the system clock is the value returned by SysCtlClockGet(), or it can be
 328:C:/StellarisWare/driverlib\uart.c **** //! explicitly hard coded if it is constant and known (to save the
 329:C:/StellarisWare/driverlib\uart.c **** //! code/execution overhead of a call to SysCtlClockGet()).
 330:C:/StellarisWare/driverlib\uart.c **** //!
 331:C:/StellarisWare/driverlib\uart.c **** //! For Stellaris parts that have the ability to specify the UART baud clock
 332:C:/StellarisWare/driverlib\uart.c **** //! source (via UARTClockSourceSet()), the peripheral clock can be changed to
 333:C:/StellarisWare/driverlib\uart.c **** //! PIOSC.  In this case, the peripheral clock should be specified as
 334:C:/StellarisWare/driverlib\uart.c **** //! 16,000,000 (the nominal rate of PIOSC).
 335:C:/StellarisWare/driverlib\uart.c **** //!
 336:C:/StellarisWare/driverlib\uart.c **** //! This function replaces the original UARTConfigSet() API and performs the
 337:C:/StellarisWare/driverlib\uart.c **** //! same actions.  A macro is provided in <tt>uart.h</tt> to map the original
 338:C:/StellarisWare/driverlib\uart.c **** //! API to this API.
 339:C:/StellarisWare/driverlib\uart.c **** //!
 340:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 341:C:/StellarisWare/driverlib\uart.c **** //
 342:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 343:C:/StellarisWare/driverlib\uart.c **** void
 344:C:/StellarisWare/driverlib\uart.c **** UARTConfigSetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
 345:C:/StellarisWare/driverlib\uart.c ****                     unsigned long ulBaud, unsigned long ulConfig)
 346:C:/StellarisWare/driverlib\uart.c **** {
 287              		.loc 1 346 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 24
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291 0000 80B5     		push	{r7, lr}
 292              	.LCFI15:
 293              		.cfi_def_cfa_offset 8
 294              		.cfi_offset 14, -4
 295              		.cfi_offset 7, -8
 296 0002 86B0     		sub	sp, sp, #24
 297              	.LCFI16:
 298              		.cfi_def_cfa_offset 32
 299 0004 00AF     		add	r7, sp, #0
 300              	.LCFI17:
 301              		.cfi_def_cfa_register 7
 302 0006 F860     		str	r0, [r7, #12]
 303 0008 B960     		str	r1, [r7, #8]
 304 000a 7A60     		str	r2, [r7, #4]
 305 000c 3B60     		str	r3, [r7, #0]
 347:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulDiv;
 348:C:/StellarisWare/driverlib\uart.c **** 
 349:C:/StellarisWare/driverlib\uart.c ****     //
 350:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 351:C:/StellarisWare/driverlib\uart.c ****     //
 352:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 353:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulBaud != 0);
 354:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulUARTClk >= (ulBaud * UART_CLK_DIVIDER));
 355:C:/StellarisWare/driverlib\uart.c **** 
 356:C:/StellarisWare/driverlib\uart.c ****     //
 357:C:/StellarisWare/driverlib\uart.c ****     // Stop the UART.
 358:C:/StellarisWare/driverlib\uart.c ****     //
 359:C:/StellarisWare/driverlib\uart.c ****     UARTDisable(ulBase);
 306              		.loc 1 359 0
 307 000e F868     		ldr	r0, [r7, #12]
 308 0010 FFF7FEFF 		bl	UARTDisable
 360:C:/StellarisWare/driverlib\uart.c **** 
 361:C:/StellarisWare/driverlib\uart.c ****     //
 362:C:/StellarisWare/driverlib\uart.c ****     // Is the required baud rate greater than the maximum rate supported
 363:C:/StellarisWare/driverlib\uart.c ****     // without the use of high speed mode?
 364:C:/StellarisWare/driverlib\uart.c ****     //
 365:C:/StellarisWare/driverlib\uart.c ****     if((ulBaud * 16) > ulUARTClk)
 309              		.loc 1 365 0
 310 0014 7B68     		ldr	r3, [r7, #4]
 311 0016 4FEA0312 		lsl	r2, r3, #4
 312 001a BB68     		ldr	r3, [r7, #8]
 313 001c 9A42     		cmp	r2, r3
 314 001e 0ED9     		bls	.L11
 366:C:/StellarisWare/driverlib\uart.c ****     {
 367:C:/StellarisWare/driverlib\uart.c ****         //
 368:C:/StellarisWare/driverlib\uart.c ****         // Enable high speed mode.
 369:C:/StellarisWare/driverlib\uart.c ****         //
 370:C:/StellarisWare/driverlib\uart.c ****         HWREG(ulBase + UART_O_CTL) |= UART_CTL_HSE;
 315              		.loc 1 370 0
 316 0020 FB68     		ldr	r3, [r7, #12]
 317 0022 03F13003 		add	r3, r3, #48
 318 0026 FA68     		ldr	r2, [r7, #12]
 319 0028 02F13002 		add	r2, r2, #48
 320 002c 1268     		ldr	r2, [r2, #0]
 321 002e 42F02002 		orr	r2, r2, #32
 322 0032 1A60     		str	r2, [r3, #0]
 371:C:/StellarisWare/driverlib\uart.c **** 
 372:C:/StellarisWare/driverlib\uart.c ****         //
 373:C:/StellarisWare/driverlib\uart.c ****         // Half the supplied baud rate to compensate for enabling high speed
 374:C:/StellarisWare/driverlib\uart.c ****         // mode.  This allows the following code to be common to both cases.
 375:C:/StellarisWare/driverlib\uart.c ****         //
 376:C:/StellarisWare/driverlib\uart.c ****         ulBaud /= 2;
 323              		.loc 1 376 0
 324 0034 7B68     		ldr	r3, [r7, #4]
 325 0036 4FEA5303 		lsr	r3, r3, #1
 326 003a 7B60     		str	r3, [r7, #4]
 327 003c 09E0     		b	.L12
 328              	.L11:
 377:C:/StellarisWare/driverlib\uart.c ****     }
 378:C:/StellarisWare/driverlib\uart.c ****     else
 379:C:/StellarisWare/driverlib\uart.c ****     {
 380:C:/StellarisWare/driverlib\uart.c ****         //
 381:C:/StellarisWare/driverlib\uart.c ****         // Disable high speed mode.
 382:C:/StellarisWare/driverlib\uart.c ****         //
 383:C:/StellarisWare/driverlib\uart.c ****         HWREG(ulBase + UART_O_CTL) &= ~(UART_CTL_HSE);
 329              		.loc 1 383 0
 330 003e FB68     		ldr	r3, [r7, #12]
 331 0040 03F13003 		add	r3, r3, #48
 332 0044 FA68     		ldr	r2, [r7, #12]
 333 0046 02F13002 		add	r2, r2, #48
 334 004a 1268     		ldr	r2, [r2, #0]
 335 004c 22F02002 		bic	r2, r2, #32
 336 0050 1A60     		str	r2, [r3, #0]
 337              	.L12:
 384:C:/StellarisWare/driverlib\uart.c ****     }
 385:C:/StellarisWare/driverlib\uart.c **** 
 386:C:/StellarisWare/driverlib\uart.c ****     //
 387:C:/StellarisWare/driverlib\uart.c ****     // Compute the fractional baud rate divider.
 388:C:/StellarisWare/driverlib\uart.c ****     //
 389:C:/StellarisWare/driverlib\uart.c ****     ulDiv = (((ulUARTClk * 8) / ulBaud) + 1) / 2;
 338              		.loc 1 389 0
 339 0052 BB68     		ldr	r3, [r7, #8]
 340 0054 4FEAC302 		lsl	r2, r3, #3
 341 0058 7B68     		ldr	r3, [r7, #4]
 342 005a B2FBF3F3 		udiv	r3, r2, r3
 343 005e 03F10103 		add	r3, r3, #1
 344 0062 4FEA5303 		lsr	r3, r3, #1
 345 0066 7B61     		str	r3, [r7, #20]
 390:C:/StellarisWare/driverlib\uart.c **** 
 391:C:/StellarisWare/driverlib\uart.c ****     //
 392:C:/StellarisWare/driverlib\uart.c ****     // Set the baud rate.
 393:C:/StellarisWare/driverlib\uart.c ****     //
 394:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_IBRD) = ulDiv / 64;
 346              		.loc 1 394 0
 347 0068 FB68     		ldr	r3, [r7, #12]
 348 006a 03F12403 		add	r3, r3, #36
 349 006e 7A69     		ldr	r2, [r7, #20]
 350 0070 4FEA9212 		lsr	r2, r2, #6
 351 0074 1A60     		str	r2, [r3, #0]
 395:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_FBRD) = ulDiv % 64;
 352              		.loc 1 395 0
 353 0076 FB68     		ldr	r3, [r7, #12]
 354 0078 03F12803 		add	r3, r3, #40
 355 007c 7A69     		ldr	r2, [r7, #20]
 356 007e 02F03F02 		and	r2, r2, #63
 357 0082 1A60     		str	r2, [r3, #0]
 396:C:/StellarisWare/driverlib\uart.c **** 
 397:C:/StellarisWare/driverlib\uart.c ****     //
 398:C:/StellarisWare/driverlib\uart.c ****     // Set parity, data length, and number of stop bits.
 399:C:/StellarisWare/driverlib\uart.c ****     //
 400:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ulConfig;
 358              		.loc 1 400 0
 359 0084 FB68     		ldr	r3, [r7, #12]
 360 0086 03F12C03 		add	r3, r3, #44
 361 008a 3A68     		ldr	r2, [r7, #0]
 362 008c 1A60     		str	r2, [r3, #0]
 401:C:/StellarisWare/driverlib\uart.c **** 
 402:C:/StellarisWare/driverlib\uart.c ****     //
 403:C:/StellarisWare/driverlib\uart.c ****     // Clear the flags register.
 404:C:/StellarisWare/driverlib\uart.c ****     //
 405:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_FR) = 0;
 363              		.loc 1 405 0
 364 008e FB68     		ldr	r3, [r7, #12]
 365 0090 03F11803 		add	r3, r3, #24
 366 0094 4FF00002 		mov	r2, #0
 367 0098 1A60     		str	r2, [r3, #0]
 406:C:/StellarisWare/driverlib\uart.c **** 
 407:C:/StellarisWare/driverlib\uart.c ****     //
 408:C:/StellarisWare/driverlib\uart.c ****     // Start the UART.
 409:C:/StellarisWare/driverlib\uart.c ****     //
 410:C:/StellarisWare/driverlib\uart.c ****     UARTEnable(ulBase);
 368              		.loc 1 410 0
 369 009a F868     		ldr	r0, [r7, #12]
 370 009c FFF7FEFF 		bl	UARTEnable
 411:C:/StellarisWare/driverlib\uart.c **** }
 371              		.loc 1 411 0
 372 00a0 07F11807 		add	r7, r7, #24
 373 00a4 BD46     		mov	sp, r7
 374 00a6 80BD     		pop	{r7, pc}
 375              		.cfi_endproc
 376              	.LFE5:
 378              		.section	.text.UARTConfigGetExpClk,"ax",%progbits
 379              		.align	2
 380              		.global	UARTConfigGetExpClk
 381              		.thumb
 382              		.thumb_func
 384              	UARTConfigGetExpClk:
 385              	.LFB6:
 412:C:/StellarisWare/driverlib\uart.c **** 
 413:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 414:C:/StellarisWare/driverlib\uart.c **** //
 415:C:/StellarisWare/driverlib\uart.c **** //! Gets the current configuration of a UART.
 416:C:/StellarisWare/driverlib\uart.c **** //!
 417:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 418:C:/StellarisWare/driverlib\uart.c **** //! \param ulUARTClk is the rate of the clock supplied to the UART module.
 419:C:/StellarisWare/driverlib\uart.c **** //! \param pulBaud is a pointer to storage for the baud rate.
 420:C:/StellarisWare/driverlib\uart.c **** //! \param pulConfig is a pointer to storage for the data format.
 421:C:/StellarisWare/driverlib\uart.c **** //!
 422:C:/StellarisWare/driverlib\uart.c **** //! This function determines the baud rate and data format for the UART, given
 423:C:/StellarisWare/driverlib\uart.c **** //! an explicitly provided peripheral clock (hence the ExpClk suffix).  The
 424:C:/StellarisWare/driverlib\uart.c **** //! returned baud rate is the actual baud rate; it may not be the exact baud
 425:C:/StellarisWare/driverlib\uart.c **** //! rate requested or an ``official'' baud rate.  The data format returned in
 426:C:/StellarisWare/driverlib\uart.c **** //! \e pulConfig is enumerated the same as the \e ulConfig parameter of
 427:C:/StellarisWare/driverlib\uart.c **** //! UARTConfigSetExpClk().
 428:C:/StellarisWare/driverlib\uart.c **** //!
 429:C:/StellarisWare/driverlib\uart.c **** //! The peripheral clock is the same as the processor clock.  The frequency of
 430:C:/StellarisWare/driverlib\uart.c **** //! the system clock is the value returned by SysCtlClockGet(), or it can be
 431:C:/StellarisWare/driverlib\uart.c **** //! explicitly hard coded if it is constant and known (to save the
 432:C:/StellarisWare/driverlib\uart.c **** //! code/execution overhead of a call to SysCtlClockGet()).
 433:C:/StellarisWare/driverlib\uart.c **** //!
 434:C:/StellarisWare/driverlib\uart.c **** //! For Stellaris parts that have the ability to specify the UART baud clock
 435:C:/StellarisWare/driverlib\uart.c **** //! source (via UARTClockSourceSet()), the peripheral clock can be changed to
 436:C:/StellarisWare/driverlib\uart.c **** //! PIOSC.  In this case, the peripheral clock should be specified as
 437:C:/StellarisWare/driverlib\uart.c **** //! 16,000,000 (the nominal rate of PIOSC).
 438:C:/StellarisWare/driverlib\uart.c **** //!
 439:C:/StellarisWare/driverlib\uart.c **** //! This function replaces the original UARTConfigGet() API and performs the
 440:C:/StellarisWare/driverlib\uart.c **** //! same actions.  A macro is provided in <tt>uart.h</tt> to map the original
 441:C:/StellarisWare/driverlib\uart.c **** //! API to this API.
 442:C:/StellarisWare/driverlib\uart.c **** //!
 443:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 444:C:/StellarisWare/driverlib\uart.c **** //
 445:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 446:C:/StellarisWare/driverlib\uart.c **** void
 447:C:/StellarisWare/driverlib\uart.c **** UARTConfigGetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
 448:C:/StellarisWare/driverlib\uart.c ****                     unsigned long *pulBaud, unsigned long *pulConfig)
 449:C:/StellarisWare/driverlib\uart.c **** {
 386              		.loc 1 449 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 24
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390              		@ link register save eliminated.
 391 0000 80B4     		push	{r7}
 392              	.LCFI18:
 393              		.cfi_def_cfa_offset 4
 394              		.cfi_offset 7, -4
 395 0002 87B0     		sub	sp, sp, #28
 396              	.LCFI19:
 397              		.cfi_def_cfa_offset 32
 398 0004 00AF     		add	r7, sp, #0
 399              	.LCFI20:
 400              		.cfi_def_cfa_register 7
 401 0006 F860     		str	r0, [r7, #12]
 402 0008 B960     		str	r1, [r7, #8]
 403 000a 7A60     		str	r2, [r7, #4]
 404 000c 3B60     		str	r3, [r7, #0]
 450:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulInt, ulFrac;
 451:C:/StellarisWare/driverlib\uart.c **** 
 452:C:/StellarisWare/driverlib\uart.c ****     //
 453:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 454:C:/StellarisWare/driverlib\uart.c ****     //
 455:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 456:C:/StellarisWare/driverlib\uart.c **** 
 457:C:/StellarisWare/driverlib\uart.c ****     //
 458:C:/StellarisWare/driverlib\uart.c ****     // Compute the baud rate.
 459:C:/StellarisWare/driverlib\uart.c ****     //
 460:C:/StellarisWare/driverlib\uart.c ****     ulInt = HWREG(ulBase + UART_O_IBRD);
 405              		.loc 1 460 0
 406 000e FB68     		ldr	r3, [r7, #12]
 407 0010 03F12403 		add	r3, r3, #36
 408 0014 1B68     		ldr	r3, [r3, #0]
 409 0016 7B61     		str	r3, [r7, #20]
 461:C:/StellarisWare/driverlib\uart.c ****     ulFrac = HWREG(ulBase + UART_O_FBRD);
 410              		.loc 1 461 0
 411 0018 FB68     		ldr	r3, [r7, #12]
 412 001a 03F12803 		add	r3, r3, #40
 413 001e 1B68     		ldr	r3, [r3, #0]
 414 0020 3B61     		str	r3, [r7, #16]
 462:C:/StellarisWare/driverlib\uart.c ****     *pulBaud = (ulUARTClk * 4) / ((64 * ulInt) + ulFrac);
 415              		.loc 1 462 0
 416 0022 BB68     		ldr	r3, [r7, #8]
 417 0024 4FEA8302 		lsl	r2, r3, #2
 418 0028 7B69     		ldr	r3, [r7, #20]
 419 002a 4FEA8311 		lsl	r1, r3, #6
 420 002e 3B69     		ldr	r3, [r7, #16]
 421 0030 CB18     		adds	r3, r1, r3
 422 0032 B2FBF3F2 		udiv	r2, r2, r3
 423 0036 7B68     		ldr	r3, [r7, #4]
 424 0038 1A60     		str	r2, [r3, #0]
 463:C:/StellarisWare/driverlib\uart.c **** 
 464:C:/StellarisWare/driverlib\uart.c ****     //
 465:C:/StellarisWare/driverlib\uart.c ****     // See if high speed mode enabled.
 466:C:/StellarisWare/driverlib\uart.c ****     //
 467:C:/StellarisWare/driverlib\uart.c ****     if(HWREG(ulBase + UART_O_CTL) & UART_CTL_HSE)
 425              		.loc 1 467 0
 426 003a FB68     		ldr	r3, [r7, #12]
 427 003c 03F13003 		add	r3, r3, #48
 428 0040 1B68     		ldr	r3, [r3, #0]
 429 0042 03F02003 		and	r3, r3, #32
 430 0046 002B     		cmp	r3, #0
 431 0048 05D0     		beq	.L14
 468:C:/StellarisWare/driverlib\uart.c ****     {
 469:C:/StellarisWare/driverlib\uart.c ****         //
 470:C:/StellarisWare/driverlib\uart.c ****         // High speed mode is enabled so the actual baud rate is actually
 471:C:/StellarisWare/driverlib\uart.c ****         // double what was just calculated.
 472:C:/StellarisWare/driverlib\uart.c ****         //
 473:C:/StellarisWare/driverlib\uart.c ****         *pulBaud *= 2;
 432              		.loc 1 473 0
 433 004a 7B68     		ldr	r3, [r7, #4]
 434 004c 1B68     		ldr	r3, [r3, #0]
 435 004e 4FEA4302 		lsl	r2, r3, #1
 436 0052 7B68     		ldr	r3, [r7, #4]
 437 0054 1A60     		str	r2, [r3, #0]
 438              	.L14:
 474:C:/StellarisWare/driverlib\uart.c ****     }
 475:C:/StellarisWare/driverlib\uart.c **** 
 476:C:/StellarisWare/driverlib\uart.c ****     //
 477:C:/StellarisWare/driverlib\uart.c ****     // Get the parity, data length, and number of stop bits.
 478:C:/StellarisWare/driverlib\uart.c ****     //
 479:C:/StellarisWare/driverlib\uart.c ****     *pulConfig = (HWREG(ulBase + UART_O_LCRH) &
 439              		.loc 1 479 0
 440 0056 FB68     		ldr	r3, [r7, #12]
 441 0058 03F12C03 		add	r3, r3, #44
 442 005c 1B68     		ldr	r3, [r3, #0]
 443 005e 03F0EE02 		and	r2, r3, #238
 444 0062 3B68     		ldr	r3, [r7, #0]
 445 0064 1A60     		str	r2, [r3, #0]
 480:C:/StellarisWare/driverlib\uart.c ****                   (UART_LCRH_SPS | UART_LCRH_WLEN_M | UART_LCRH_STP2 |
 481:C:/StellarisWare/driverlib\uart.c ****                    UART_LCRH_EPS | UART_LCRH_PEN));
 482:C:/StellarisWare/driverlib\uart.c **** }
 446              		.loc 1 482 0
 447 0066 07F11C07 		add	r7, r7, #28
 448 006a BD46     		mov	sp, r7
 449 006c 80BC     		pop	{r7}
 450 006e 7047     		bx	lr
 451              		.cfi_endproc
 452              	.LFE6:
 454              		.section	.text.UARTEnable,"ax",%progbits
 455              		.align	2
 456              		.global	UARTEnable
 457              		.thumb
 458              		.thumb_func
 460              	UARTEnable:
 461              	.LFB7:
 483:C:/StellarisWare/driverlib\uart.c **** 
 484:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 485:C:/StellarisWare/driverlib\uart.c **** //
 486:C:/StellarisWare/driverlib\uart.c **** //! Enables transmitting and receiving.
 487:C:/StellarisWare/driverlib\uart.c **** //!
 488:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 489:C:/StellarisWare/driverlib\uart.c **** //!
 490:C:/StellarisWare/driverlib\uart.c **** //! This function sets the UARTEN, TXE, and RXE bits and enables the transmit
 491:C:/StellarisWare/driverlib\uart.c **** //! and receive FIFOs.
 492:C:/StellarisWare/driverlib\uart.c **** //!
 493:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 494:C:/StellarisWare/driverlib\uart.c **** //
 495:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 496:C:/StellarisWare/driverlib\uart.c **** void
 497:C:/StellarisWare/driverlib\uart.c **** UARTEnable(unsigned long ulBase)
 498:C:/StellarisWare/driverlib\uart.c **** {
 462              		.loc 1 498 0
 463              		.cfi_startproc
 464              		@ args = 0, pretend = 0, frame = 8
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466              		@ link register save eliminated.
 467 0000 80B4     		push	{r7}
 468              	.LCFI21:
 469              		.cfi_def_cfa_offset 4
 470              		.cfi_offset 7, -4
 471 0002 83B0     		sub	sp, sp, #12
 472              	.LCFI22:
 473              		.cfi_def_cfa_offset 16
 474 0004 00AF     		add	r7, sp, #0
 475              	.LCFI23:
 476              		.cfi_def_cfa_register 7
 477 0006 7860     		str	r0, [r7, #4]
 499:C:/StellarisWare/driverlib\uart.c ****     //
 500:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 501:C:/StellarisWare/driverlib\uart.c ****     //
 502:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 503:C:/StellarisWare/driverlib\uart.c **** 
 504:C:/StellarisWare/driverlib\uart.c ****     //
 505:C:/StellarisWare/driverlib\uart.c ****     // Enable the FIFO.
 506:C:/StellarisWare/driverlib\uart.c ****     //
 507:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) |= UART_LCRH_FEN;
 478              		.loc 1 507 0
 479 0008 7B68     		ldr	r3, [r7, #4]
 480 000a 03F12C03 		add	r3, r3, #44
 481 000e 7A68     		ldr	r2, [r7, #4]
 482 0010 02F12C02 		add	r2, r2, #44
 483 0014 1268     		ldr	r2, [r2, #0]
 484 0016 42F01002 		orr	r2, r2, #16
 485 001a 1A60     		str	r2, [r3, #0]
 508:C:/StellarisWare/driverlib\uart.c **** 
 509:C:/StellarisWare/driverlib\uart.c ****     //
 510:C:/StellarisWare/driverlib\uart.c ****     // Enable RX, TX, and the UART.
 511:C:/StellarisWare/driverlib\uart.c ****     //
 512:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) |= (UART_CTL_UARTEN | UART_CTL_TXE |
 486              		.loc 1 512 0
 487 001c 7B68     		ldr	r3, [r7, #4]
 488 001e 03F13003 		add	r3, r3, #48
 489 0022 1A46     		mov	r2, r3
 490 0024 7B68     		ldr	r3, [r7, #4]
 491 0026 03F13003 		add	r3, r3, #48
 492 002a 1B68     		ldr	r3, [r3, #0]
 493 002c 43F44073 		orr	r3, r3, #768
 494 0030 43F00103 		orr	r3, r3, #1
 495 0034 1360     		str	r3, [r2, #0]
 513:C:/StellarisWare/driverlib\uart.c ****                                    UART_CTL_RXE);
 514:C:/StellarisWare/driverlib\uart.c **** }
 496              		.loc 1 514 0
 497 0036 07F10C07 		add	r7, r7, #12
 498 003a BD46     		mov	sp, r7
 499 003c 80BC     		pop	{r7}
 500 003e 7047     		bx	lr
 501              		.cfi_endproc
 502              	.LFE7:
 504              		.section	.text.UARTDisable,"ax",%progbits
 505              		.align	2
 506              		.global	UARTDisable
 507              		.thumb
 508              		.thumb_func
 510              	UARTDisable:
 511              	.LFB8:
 515:C:/StellarisWare/driverlib\uart.c **** 
 516:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 517:C:/StellarisWare/driverlib\uart.c **** //
 518:C:/StellarisWare/driverlib\uart.c **** //! Disables transmitting and receiving.
 519:C:/StellarisWare/driverlib\uart.c **** //!
 520:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 521:C:/StellarisWare/driverlib\uart.c **** //!
 522:C:/StellarisWare/driverlib\uart.c **** //! This function clears the UARTEN, TXE, and RXE bits, waits for the end of
 523:C:/StellarisWare/driverlib\uart.c **** //! transmission of the current character, and flushes the transmit FIFO.
 524:C:/StellarisWare/driverlib\uart.c **** //!
 525:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 526:C:/StellarisWare/driverlib\uart.c **** //
 527:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 528:C:/StellarisWare/driverlib\uart.c **** void
 529:C:/StellarisWare/driverlib\uart.c **** UARTDisable(unsigned long ulBase)
 530:C:/StellarisWare/driverlib\uart.c **** {
 512              		.loc 1 530 0
 513              		.cfi_startproc
 514              		@ args = 0, pretend = 0, frame = 8
 515              		@ frame_needed = 1, uses_anonymous_args = 0
 516              		@ link register save eliminated.
 517 0000 80B4     		push	{r7}
 518              	.LCFI24:
 519              		.cfi_def_cfa_offset 4
 520              		.cfi_offset 7, -4
 521 0002 83B0     		sub	sp, sp, #12
 522              	.LCFI25:
 523              		.cfi_def_cfa_offset 16
 524 0004 00AF     		add	r7, sp, #0
 525              	.LCFI26:
 526              		.cfi_def_cfa_register 7
 527 0006 7860     		str	r0, [r7, #4]
 531:C:/StellarisWare/driverlib\uart.c ****     //
 532:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 533:C:/StellarisWare/driverlib\uart.c ****     //
 534:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 535:C:/StellarisWare/driverlib\uart.c **** 
 536:C:/StellarisWare/driverlib\uart.c ****     //
 537:C:/StellarisWare/driverlib\uart.c ****     // Wait for end of TX.
 538:C:/StellarisWare/driverlib\uart.c ****     //
 539:C:/StellarisWare/driverlib\uart.c ****     while(HWREG(ulBase + UART_O_FR) & UART_FR_BUSY)
 528              		.loc 1 539 0
 529 0008 00BF     		nop
 530              	.L17:
 531              		.loc 1 539 0 is_stmt 0 discriminator 1
 532 000a 7B68     		ldr	r3, [r7, #4]
 533 000c 03F11803 		add	r3, r3, #24
 534 0010 1B68     		ldr	r3, [r3, #0]
 535 0012 03F00803 		and	r3, r3, #8
 536 0016 002B     		cmp	r3, #0
 537 0018 F7D1     		bne	.L17
 540:C:/StellarisWare/driverlib\uart.c ****     {
 541:C:/StellarisWare/driverlib\uart.c ****     }
 542:C:/StellarisWare/driverlib\uart.c **** 
 543:C:/StellarisWare/driverlib\uart.c ****     //
 544:C:/StellarisWare/driverlib\uart.c ****     // Disable the FIFO.
 545:C:/StellarisWare/driverlib\uart.c ****     //
 546:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) &= ~(UART_LCRH_FEN);
 538              		.loc 1 546 0 is_stmt 1
 539 001a 7B68     		ldr	r3, [r7, #4]
 540 001c 03F12C03 		add	r3, r3, #44
 541 0020 7A68     		ldr	r2, [r7, #4]
 542 0022 02F12C02 		add	r2, r2, #44
 543 0026 1268     		ldr	r2, [r2, #0]
 544 0028 22F01002 		bic	r2, r2, #16
 545 002c 1A60     		str	r2, [r3, #0]
 547:C:/StellarisWare/driverlib\uart.c **** 
 548:C:/StellarisWare/driverlib\uart.c ****     //
 549:C:/StellarisWare/driverlib\uart.c ****     // Disable the UART.
 550:C:/StellarisWare/driverlib\uart.c ****     //
 551:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) &= ~(UART_CTL_UARTEN | UART_CTL_TXE |
 546              		.loc 1 551 0
 547 002e 7B68     		ldr	r3, [r7, #4]
 548 0030 03F13003 		add	r3, r3, #48
 549 0034 1A46     		mov	r2, r3
 550 0036 7B68     		ldr	r3, [r7, #4]
 551 0038 03F13003 		add	r3, r3, #48
 552 003c 1B68     		ldr	r3, [r3, #0]
 553 003e 23F44073 		bic	r3, r3, #768
 554 0042 23F00103 		bic	r3, r3, #1
 555 0046 1360     		str	r3, [r2, #0]
 552:C:/StellarisWare/driverlib\uart.c ****                                     UART_CTL_RXE);
 553:C:/StellarisWare/driverlib\uart.c **** }
 556              		.loc 1 553 0
 557 0048 07F10C07 		add	r7, r7, #12
 558 004c BD46     		mov	sp, r7
 559 004e 80BC     		pop	{r7}
 560 0050 7047     		bx	lr
 561              		.cfi_endproc
 562              	.LFE8:
 564 0052 00BF     		.section	.text.UARTFIFOEnable,"ax",%progbits
 565              		.align	2
 566              		.global	UARTFIFOEnable
 567              		.thumb
 568              		.thumb_func
 570              	UARTFIFOEnable:
 571              	.LFB9:
 554:C:/StellarisWare/driverlib\uart.c **** 
 555:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 556:C:/StellarisWare/driverlib\uart.c **** //
 557:C:/StellarisWare/driverlib\uart.c **** //! Enables the transmit and receive FIFOs.
 558:C:/StellarisWare/driverlib\uart.c **** //!
 559:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 560:C:/StellarisWare/driverlib\uart.c **** //!
 561:C:/StellarisWare/driverlib\uart.c **** //! This functions enables the transmit and receive FIFOs in the UART.
 562:C:/StellarisWare/driverlib\uart.c **** //!
 563:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 564:C:/StellarisWare/driverlib\uart.c **** //
 565:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 566:C:/StellarisWare/driverlib\uart.c **** void
 567:C:/StellarisWare/driverlib\uart.c **** UARTFIFOEnable(unsigned long ulBase)
 568:C:/StellarisWare/driverlib\uart.c **** {
 572              		.loc 1 568 0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 8
 575              		@ frame_needed = 1, uses_anonymous_args = 0
 576              		@ link register save eliminated.
 577 0000 80B4     		push	{r7}
 578              	.LCFI27:
 579              		.cfi_def_cfa_offset 4
 580              		.cfi_offset 7, -4
 581 0002 83B0     		sub	sp, sp, #12
 582              	.LCFI28:
 583              		.cfi_def_cfa_offset 16
 584 0004 00AF     		add	r7, sp, #0
 585              	.LCFI29:
 586              		.cfi_def_cfa_register 7
 587 0006 7860     		str	r0, [r7, #4]
 569:C:/StellarisWare/driverlib\uart.c ****     //
 570:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 571:C:/StellarisWare/driverlib\uart.c ****     //
 572:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 573:C:/StellarisWare/driverlib\uart.c **** 
 574:C:/StellarisWare/driverlib\uart.c ****     //
 575:C:/StellarisWare/driverlib\uart.c ****     // Enable the FIFO.
 576:C:/StellarisWare/driverlib\uart.c ****     //
 577:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) |= UART_LCRH_FEN;
 588              		.loc 1 577 0
 589 0008 7B68     		ldr	r3, [r7, #4]
 590 000a 03F12C03 		add	r3, r3, #44
 591 000e 7A68     		ldr	r2, [r7, #4]
 592 0010 02F12C02 		add	r2, r2, #44
 593 0014 1268     		ldr	r2, [r2, #0]
 594 0016 42F01002 		orr	r2, r2, #16
 595 001a 1A60     		str	r2, [r3, #0]
 578:C:/StellarisWare/driverlib\uart.c **** }
 596              		.loc 1 578 0
 597 001c 07F10C07 		add	r7, r7, #12
 598 0020 BD46     		mov	sp, r7
 599 0022 80BC     		pop	{r7}
 600 0024 7047     		bx	lr
 601              		.cfi_endproc
 602              	.LFE9:
 604 0026 00BF     		.section	.text.UARTFIFODisable,"ax",%progbits
 605              		.align	2
 606              		.global	UARTFIFODisable
 607              		.thumb
 608              		.thumb_func
 610              	UARTFIFODisable:
 611              	.LFB10:
 579:C:/StellarisWare/driverlib\uart.c **** 
 580:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 581:C:/StellarisWare/driverlib\uart.c **** //
 582:C:/StellarisWare/driverlib\uart.c **** //! Disables the transmit and receive FIFOs.
 583:C:/StellarisWare/driverlib\uart.c **** //!
 584:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 585:C:/StellarisWare/driverlib\uart.c **** //!
 586:C:/StellarisWare/driverlib\uart.c **** //! This function disables the transmit and receive FIFOs in the UART.
 587:C:/StellarisWare/driverlib\uart.c **** //!
 588:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 589:C:/StellarisWare/driverlib\uart.c **** //
 590:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 591:C:/StellarisWare/driverlib\uart.c **** void
 592:C:/StellarisWare/driverlib\uart.c **** UARTFIFODisable(unsigned long ulBase)
 593:C:/StellarisWare/driverlib\uart.c **** {
 612              		.loc 1 593 0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 8
 615              		@ frame_needed = 1, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 617 0000 80B4     		push	{r7}
 618              	.LCFI30:
 619              		.cfi_def_cfa_offset 4
 620              		.cfi_offset 7, -4
 621 0002 83B0     		sub	sp, sp, #12
 622              	.LCFI31:
 623              		.cfi_def_cfa_offset 16
 624 0004 00AF     		add	r7, sp, #0
 625              	.LCFI32:
 626              		.cfi_def_cfa_register 7
 627 0006 7860     		str	r0, [r7, #4]
 594:C:/StellarisWare/driverlib\uart.c ****     //
 595:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 596:C:/StellarisWare/driverlib\uart.c ****     //
 597:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 598:C:/StellarisWare/driverlib\uart.c **** 
 599:C:/StellarisWare/driverlib\uart.c ****     //
 600:C:/StellarisWare/driverlib\uart.c ****     // Disable the FIFO.
 601:C:/StellarisWare/driverlib\uart.c ****     //
 602:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) &= ~(UART_LCRH_FEN);
 628              		.loc 1 602 0
 629 0008 7B68     		ldr	r3, [r7, #4]
 630 000a 03F12C03 		add	r3, r3, #44
 631 000e 7A68     		ldr	r2, [r7, #4]
 632 0010 02F12C02 		add	r2, r2, #44
 633 0014 1268     		ldr	r2, [r2, #0]
 634 0016 22F01002 		bic	r2, r2, #16
 635 001a 1A60     		str	r2, [r3, #0]
 603:C:/StellarisWare/driverlib\uart.c **** }
 636              		.loc 1 603 0
 637 001c 07F10C07 		add	r7, r7, #12
 638 0020 BD46     		mov	sp, r7
 639 0022 80BC     		pop	{r7}
 640 0024 7047     		bx	lr
 641              		.cfi_endproc
 642              	.LFE10:
 644 0026 00BF     		.section	.text.UARTEnableSIR,"ax",%progbits
 645              		.align	2
 646              		.global	UARTEnableSIR
 647              		.thumb
 648              		.thumb_func
 650              	UARTEnableSIR:
 651              	.LFB11:
 604:C:/StellarisWare/driverlib\uart.c **** 
 605:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 606:C:/StellarisWare/driverlib\uart.c **** //
 607:C:/StellarisWare/driverlib\uart.c **** //! Enables SIR (IrDA) mode on the specified UART.
 608:C:/StellarisWare/driverlib\uart.c **** //!
 609:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 610:C:/StellarisWare/driverlib\uart.c **** //! \param bLowPower indicates if SIR Low Power Mode is to be used.
 611:C:/StellarisWare/driverlib\uart.c **** //!
 612:C:/StellarisWare/driverlib\uart.c **** //! This function enables the SIREN control bit for IrDA mode on the UART.  If
 613:C:/StellarisWare/driverlib\uart.c **** //! the \e bLowPower flag is set, then SIRLP bit is also set.  This
 614:C:/StellarisWare/driverlib\uart.c **** //! function only has an effect if the UART has not been enabled
 615:C:/StellarisWare/driverlib\uart.c **** //! by a call to UARTEnable().  The call UARTEnableSIR() must be made before
 616:C:/StellarisWare/driverlib\uart.c **** //! a call to UARTConfigSetExpClk() because the UARTConfigSetExpClk() function
 617:C:/StellarisWare/driverlib\uart.c **** //! calls the UARTEnable() function.  Another option is to call UARTDisable()
 618:C:/StellarisWare/driverlib\uart.c **** //! followed by UARTEnableSIR() and then enable the UART by calling
 619:C:/StellarisWare/driverlib\uart.c **** //! UARTEnable().
 620:C:/StellarisWare/driverlib\uart.c **** //!
 621:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of SIR (IrDA) operation varies with the Stellaris
 622:C:/StellarisWare/driverlib\uart.c **** //! part in use.  Please consult the datasheet for the part you are using to
 623:C:/StellarisWare/driverlib\uart.c **** //! determine whether this support is available.
 624:C:/StellarisWare/driverlib\uart.c **** //!
 625:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 626:C:/StellarisWare/driverlib\uart.c **** //
 627:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 628:C:/StellarisWare/driverlib\uart.c **** void
 629:C:/StellarisWare/driverlib\uart.c **** UARTEnableSIR(unsigned long ulBase, tBoolean bLowPower)
 630:C:/StellarisWare/driverlib\uart.c **** {
 652              		.loc 1 630 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 8
 655              		@ frame_needed = 1, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657 0000 80B4     		push	{r7}
 658              	.LCFI33:
 659              		.cfi_def_cfa_offset 4
 660              		.cfi_offset 7, -4
 661 0002 83B0     		sub	sp, sp, #12
 662              	.LCFI34:
 663              		.cfi_def_cfa_offset 16
 664 0004 00AF     		add	r7, sp, #0
 665              	.LCFI35:
 666              		.cfi_def_cfa_register 7
 667 0006 7860     		str	r0, [r7, #4]
 668 0008 0B46     		mov	r3, r1
 669 000a FB70     		strb	r3, [r7, #3]
 631:C:/StellarisWare/driverlib\uart.c ****     //
 632:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 633:C:/StellarisWare/driverlib\uart.c ****     //
 634:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 635:C:/StellarisWare/driverlib\uart.c **** 
 636:C:/StellarisWare/driverlib\uart.c ****     //
 637:C:/StellarisWare/driverlib\uart.c ****     // Enable SIR and SIRLP (if appropriate).
 638:C:/StellarisWare/driverlib\uart.c ****     //
 639:C:/StellarisWare/driverlib\uart.c ****     if(bLowPower)
 670              		.loc 1 639 0
 671 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 672 000e 002B     		cmp	r3, #0
 673 0010 0AD0     		beq	.L21
 640:C:/StellarisWare/driverlib\uart.c ****     {
 641:C:/StellarisWare/driverlib\uart.c ****         HWREG(ulBase + UART_O_CTL) |= (UART_CTL_SIREN | UART_CTL_SIRLP);
 674              		.loc 1 641 0
 675 0012 7B68     		ldr	r3, [r7, #4]
 676 0014 03F13003 		add	r3, r3, #48
 677 0018 7A68     		ldr	r2, [r7, #4]
 678 001a 02F13002 		add	r2, r2, #48
 679 001e 1268     		ldr	r2, [r2, #0]
 680 0020 42F00602 		orr	r2, r2, #6
 681 0024 1A60     		str	r2, [r3, #0]
 682 0026 09E0     		b	.L20
 683              	.L21:
 642:C:/StellarisWare/driverlib\uart.c ****     }
 643:C:/StellarisWare/driverlib\uart.c ****     else
 644:C:/StellarisWare/driverlib\uart.c ****     {
 645:C:/StellarisWare/driverlib\uart.c ****         HWREG(ulBase + UART_O_CTL) |= (UART_CTL_SIREN);
 684              		.loc 1 645 0
 685 0028 7B68     		ldr	r3, [r7, #4]
 686 002a 03F13003 		add	r3, r3, #48
 687 002e 7A68     		ldr	r2, [r7, #4]
 688 0030 02F13002 		add	r2, r2, #48
 689 0034 1268     		ldr	r2, [r2, #0]
 690 0036 42F00202 		orr	r2, r2, #2
 691 003a 1A60     		str	r2, [r3, #0]
 692              	.L20:
 646:C:/StellarisWare/driverlib\uart.c ****     }
 647:C:/StellarisWare/driverlib\uart.c **** }
 693              		.loc 1 647 0
 694 003c 07F10C07 		add	r7, r7, #12
 695 0040 BD46     		mov	sp, r7
 696 0042 80BC     		pop	{r7}
 697 0044 7047     		bx	lr
 698              		.cfi_endproc
 699              	.LFE11:
 701 0046 00BF     		.section	.text.UARTDisableSIR,"ax",%progbits
 702              		.align	2
 703              		.global	UARTDisableSIR
 704              		.thumb
 705              		.thumb_func
 707              	UARTDisableSIR:
 708              	.LFB12:
 648:C:/StellarisWare/driverlib\uart.c **** 
 649:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 650:C:/StellarisWare/driverlib\uart.c **** //
 651:C:/StellarisWare/driverlib\uart.c **** //! Disables SIR (IrDA) mode on the specified UART.
 652:C:/StellarisWare/driverlib\uart.c **** //!
 653:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 654:C:/StellarisWare/driverlib\uart.c **** //!
 655:C:/StellarisWare/driverlib\uart.c **** //! This function clears the SIREN (IrDA) and SIRLP (Low Power) bits.  This
 656:C:/StellarisWare/driverlib\uart.c **** //! function only has an effect if the UART has not been enabled by a
 657:C:/StellarisWare/driverlib\uart.c **** //! call to UARTEnable().  The call UARTEnableSIR() must be made before
 658:C:/StellarisWare/driverlib\uart.c **** //! a call to UARTConfigSetExpClk() because the UARTConfigSetExpClk() function
 659:C:/StellarisWare/driverlib\uart.c **** //! calls the UARTEnable() function.  Another option is to call UARTDisable()
 660:C:/StellarisWare/driverlib\uart.c **** //! followed by UARTEnableSIR() and then enable the UART by calling
 661:C:/StellarisWare/driverlib\uart.c **** //! UARTEnable().
 662:C:/StellarisWare/driverlib\uart.c **** //!
 663:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of SIR (IrDA) operation varies with the Stellaris
 664:C:/StellarisWare/driverlib\uart.c **** //! part in use.  Please consult the datasheet for the part you are using to
 665:C:/StellarisWare/driverlib\uart.c **** //! determine whether this support is available.
 666:C:/StellarisWare/driverlib\uart.c **** //!
 667:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 668:C:/StellarisWare/driverlib\uart.c **** //
 669:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 670:C:/StellarisWare/driverlib\uart.c **** void
 671:C:/StellarisWare/driverlib\uart.c **** UARTDisableSIR(unsigned long ulBase)
 672:C:/StellarisWare/driverlib\uart.c **** {
 709              		.loc 1 672 0
 710              		.cfi_startproc
 711              		@ args = 0, pretend = 0, frame = 8
 712              		@ frame_needed = 1, uses_anonymous_args = 0
 713              		@ link register save eliminated.
 714 0000 80B4     		push	{r7}
 715              	.LCFI36:
 716              		.cfi_def_cfa_offset 4
 717              		.cfi_offset 7, -4
 718 0002 83B0     		sub	sp, sp, #12
 719              	.LCFI37:
 720              		.cfi_def_cfa_offset 16
 721 0004 00AF     		add	r7, sp, #0
 722              	.LCFI38:
 723              		.cfi_def_cfa_register 7
 724 0006 7860     		str	r0, [r7, #4]
 673:C:/StellarisWare/driverlib\uart.c ****     //
 674:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 675:C:/StellarisWare/driverlib\uart.c ****     //
 676:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 677:C:/StellarisWare/driverlib\uart.c **** 
 678:C:/StellarisWare/driverlib\uart.c ****     //
 679:C:/StellarisWare/driverlib\uart.c ****     // Disable SIR and SIRLP (if appropriate).
 680:C:/StellarisWare/driverlib\uart.c ****     //
 681:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) &= ~(UART_CTL_SIREN | UART_CTL_SIRLP);
 725              		.loc 1 681 0
 726 0008 7B68     		ldr	r3, [r7, #4]
 727 000a 03F13003 		add	r3, r3, #48
 728 000e 7A68     		ldr	r2, [r7, #4]
 729 0010 02F13002 		add	r2, r2, #48
 730 0014 1268     		ldr	r2, [r2, #0]
 731 0016 22F00602 		bic	r2, r2, #6
 732 001a 1A60     		str	r2, [r3, #0]
 682:C:/StellarisWare/driverlib\uart.c **** }
 733              		.loc 1 682 0
 734 001c 07F10C07 		add	r7, r7, #12
 735 0020 BD46     		mov	sp, r7
 736 0022 80BC     		pop	{r7}
 737 0024 7047     		bx	lr
 738              		.cfi_endproc
 739              	.LFE12:
 741 0026 00BF     		.section	.text.UARTSmartCardEnable,"ax",%progbits
 742              		.align	2
 743              		.global	UARTSmartCardEnable
 744              		.thumb
 745              		.thumb_func
 747              	UARTSmartCardEnable:
 748              	.LFB13:
 683:C:/StellarisWare/driverlib\uart.c **** 
 684:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 685:C:/StellarisWare/driverlib\uart.c **** //
 686:C:/StellarisWare/driverlib\uart.c **** //! Enables ISO7816 smart card mode on the specified UART.
 687:C:/StellarisWare/driverlib\uart.c **** //!
 688:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 689:C:/StellarisWare/driverlib\uart.c **** //!
 690:C:/StellarisWare/driverlib\uart.c **** //! This function enables the SMART control bit for the ISO7816 smart card mode
 691:C:/StellarisWare/driverlib\uart.c **** //! on the UART.  This call also sets 8-bit word length and even parity as
 692:C:/StellarisWare/driverlib\uart.c **** //! required by ISO7816.
 693:C:/StellarisWare/driverlib\uart.c **** //!
 694:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of SIR (IrDA) operation varies with the Stellaris
 695:C:/StellarisWare/driverlib\uart.c **** //! part in use.  Please consult the datasheet for the part you are using to
 696:C:/StellarisWare/driverlib\uart.c **** //! determine whether this support is available.
 697:C:/StellarisWare/driverlib\uart.c **** //!
 698:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 699:C:/StellarisWare/driverlib\uart.c **** //
 700:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 701:C:/StellarisWare/driverlib\uart.c **** void
 702:C:/StellarisWare/driverlib\uart.c **** UARTSmartCardEnable(unsigned long ulBase)
 703:C:/StellarisWare/driverlib\uart.c **** {
 749              		.loc 1 703 0
 750              		.cfi_startproc
 751              		@ args = 0, pretend = 0, frame = 16
 752              		@ frame_needed = 1, uses_anonymous_args = 0
 753              		@ link register save eliminated.
 754 0000 80B4     		push	{r7}
 755              	.LCFI39:
 756              		.cfi_def_cfa_offset 4
 757              		.cfi_offset 7, -4
 758 0002 85B0     		sub	sp, sp, #20
 759              	.LCFI40:
 760              		.cfi_def_cfa_offset 24
 761 0004 00AF     		add	r7, sp, #0
 762              	.LCFI41:
 763              		.cfi_def_cfa_register 7
 764 0006 7860     		str	r0, [r7, #4]
 704:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulVal;
 705:C:/StellarisWare/driverlib\uart.c **** 
 706:C:/StellarisWare/driverlib\uart.c ****     //
 707:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 708:C:/StellarisWare/driverlib\uart.c ****     //
 709:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 710:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 711:C:/StellarisWare/driverlib\uart.c **** 
 712:C:/StellarisWare/driverlib\uart.c ****     //
 713:C:/StellarisWare/driverlib\uart.c ****     // Set 8-bit word length, even parity, 2 stop bits (note that although the
 714:C:/StellarisWare/driverlib\uart.c ****     // STP2 bit is ignored when in smartcard mode, this code lets the caller
 715:C:/StellarisWare/driverlib\uart.c ****     // read back the actual setting in use).
 716:C:/StellarisWare/driverlib\uart.c ****     //
 717:C:/StellarisWare/driverlib\uart.c ****     ulVal = HWREG(ulBase + UART_O_LCRH);
 765              		.loc 1 717 0
 766 0008 7B68     		ldr	r3, [r7, #4]
 767 000a 03F12C03 		add	r3, r3, #44
 768 000e 1B68     		ldr	r3, [r3, #0]
 769 0010 FB60     		str	r3, [r7, #12]
 718:C:/StellarisWare/driverlib\uart.c ****     ulVal &= ~(UART_LCRH_SPS | UART_LCRH_EPS | UART_LCRH_PEN |
 770              		.loc 1 718 0
 771 0012 FB68     		ldr	r3, [r7, #12]
 772 0014 23F0E603 		bic	r3, r3, #230
 773 0018 FB60     		str	r3, [r7, #12]
 719:C:/StellarisWare/driverlib\uart.c ****                UART_LCRH_WLEN_M);
 720:C:/StellarisWare/driverlib\uart.c ****     ulVal |= UART_LCRH_WLEN_8 | UART_LCRH_PEN | UART_LCRH_EPS | UART_LCRH_STP2;
 774              		.loc 1 720 0
 775 001a FB68     		ldr	r3, [r7, #12]
 776 001c 43F06E03 		orr	r3, r3, #110
 777 0020 FB60     		str	r3, [r7, #12]
 721:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ulVal;
 778              		.loc 1 721 0
 779 0022 7B68     		ldr	r3, [r7, #4]
 780 0024 03F12C03 		add	r3, r3, #44
 781 0028 FA68     		ldr	r2, [r7, #12]
 782 002a 1A60     		str	r2, [r3, #0]
 722:C:/StellarisWare/driverlib\uart.c **** 
 723:C:/StellarisWare/driverlib\uart.c ****     //
 724:C:/StellarisWare/driverlib\uart.c ****     // Enable SMART mode.
 725:C:/StellarisWare/driverlib\uart.c ****     //
 726:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) |= UART_CTL_SMART;
 783              		.loc 1 726 0
 784 002c 7B68     		ldr	r3, [r7, #4]
 785 002e 03F13003 		add	r3, r3, #48
 786 0032 7A68     		ldr	r2, [r7, #4]
 787 0034 02F13002 		add	r2, r2, #48
 788 0038 1268     		ldr	r2, [r2, #0]
 789 003a 42F00802 		orr	r2, r2, #8
 790 003e 1A60     		str	r2, [r3, #0]
 727:C:/StellarisWare/driverlib\uart.c **** }
 791              		.loc 1 727 0
 792 0040 07F11407 		add	r7, r7, #20
 793 0044 BD46     		mov	sp, r7
 794 0046 80BC     		pop	{r7}
 795 0048 7047     		bx	lr
 796              		.cfi_endproc
 797              	.LFE13:
 799 004a 00BF     		.section	.text.UARTSmartCardDisable,"ax",%progbits
 800              		.align	2
 801              		.global	UARTSmartCardDisable
 802              		.thumb
 803              		.thumb_func
 805              	UARTSmartCardDisable:
 806              	.LFB14:
 728:C:/StellarisWare/driverlib\uart.c **** 
 729:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 730:C:/StellarisWare/driverlib\uart.c **** //
 731:C:/StellarisWare/driverlib\uart.c **** //! Disables ISO7816 smart card mode on the specified UART.
 732:C:/StellarisWare/driverlib\uart.c **** //!
 733:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 734:C:/StellarisWare/driverlib\uart.c **** //!
 735:C:/StellarisWare/driverlib\uart.c **** //! This function clears the SMART (ISO7816 smart card) bit in the UART
 736:C:/StellarisWare/driverlib\uart.c **** //! control register.
 737:C:/StellarisWare/driverlib\uart.c **** //!
 738:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of ISO7816 smart card mode varies with the
 739:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
 740:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
 741:C:/StellarisWare/driverlib\uart.c **** //!
 742:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 743:C:/StellarisWare/driverlib\uart.c **** //
 744:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 745:C:/StellarisWare/driverlib\uart.c **** void
 746:C:/StellarisWare/driverlib\uart.c **** UARTSmartCardDisable(unsigned long ulBase)
 747:C:/StellarisWare/driverlib\uart.c **** {
 807              		.loc 1 747 0
 808              		.cfi_startproc
 809              		@ args = 0, pretend = 0, frame = 8
 810              		@ frame_needed = 1, uses_anonymous_args = 0
 811              		@ link register save eliminated.
 812 0000 80B4     		push	{r7}
 813              	.LCFI42:
 814              		.cfi_def_cfa_offset 4
 815              		.cfi_offset 7, -4
 816 0002 83B0     		sub	sp, sp, #12
 817              	.LCFI43:
 818              		.cfi_def_cfa_offset 16
 819 0004 00AF     		add	r7, sp, #0
 820              	.LCFI44:
 821              		.cfi_def_cfa_register 7
 822 0006 7860     		str	r0, [r7, #4]
 748:C:/StellarisWare/driverlib\uart.c ****     //
 749:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 750:C:/StellarisWare/driverlib\uart.c ****     //
 751:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 752:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 753:C:/StellarisWare/driverlib\uart.c **** 
 754:C:/StellarisWare/driverlib\uart.c ****     //
 755:C:/StellarisWare/driverlib\uart.c ****     // Disable the SMART bit.
 756:C:/StellarisWare/driverlib\uart.c ****     //
 757:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) &= ~UART_CTL_SMART;
 823              		.loc 1 757 0
 824 0008 7B68     		ldr	r3, [r7, #4]
 825 000a 03F13003 		add	r3, r3, #48
 826 000e 7A68     		ldr	r2, [r7, #4]
 827 0010 02F13002 		add	r2, r2, #48
 828 0014 1268     		ldr	r2, [r2, #0]
 829 0016 22F00802 		bic	r2, r2, #8
 830 001a 1A60     		str	r2, [r3, #0]
 758:C:/StellarisWare/driverlib\uart.c **** }
 831              		.loc 1 758 0
 832 001c 07F10C07 		add	r7, r7, #12
 833 0020 BD46     		mov	sp, r7
 834 0022 80BC     		pop	{r7}
 835 0024 7047     		bx	lr
 836              		.cfi_endproc
 837              	.LFE14:
 839 0026 00BF     		.section	.text.UARTModemControlSet,"ax",%progbits
 840              		.align	2
 841              		.global	UARTModemControlSet
 842              		.thumb
 843              		.thumb_func
 845              	UARTModemControlSet:
 846              	.LFB15:
 759:C:/StellarisWare/driverlib\uart.c **** 
 760:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 761:C:/StellarisWare/driverlib\uart.c **** //
 762:C:/StellarisWare/driverlib\uart.c **** //! Sets the states of the DTR and/or RTS modem control signals.
 763:C:/StellarisWare/driverlib\uart.c **** //!
 764:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 765:C:/StellarisWare/driverlib\uart.c **** //! \param ulControl is a bit-mapped flag indicating which modem control bits
 766:C:/StellarisWare/driverlib\uart.c **** //! should be set.
 767:C:/StellarisWare/driverlib\uart.c **** //!
 768:C:/StellarisWare/driverlib\uart.c **** //! This function configures the states of the DTR or RTS modem handshake
 769:C:/StellarisWare/driverlib\uart.c **** //! outputs from the UART.
 770:C:/StellarisWare/driverlib\uart.c **** //!
 771:C:/StellarisWare/driverlib\uart.c **** //! The \e ulControl parameter is the logical OR of any of the following:
 772:C:/StellarisWare/driverlib\uart.c **** //!
 773:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_OUTPUT_DTR - The Modem Control DTR signal
 774:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_OUTPUT_RTS - The Modem Control RTS signal
 775:C:/StellarisWare/driverlib\uart.c **** //!
 776:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of ISO7816 smart card mode varies with the
 777:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
 778:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
 779:C:/StellarisWare/driverlib\uart.c **** //!
 780:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 781:C:/StellarisWare/driverlib\uart.c **** //
 782:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 783:C:/StellarisWare/driverlib\uart.c **** void
 784:C:/StellarisWare/driverlib\uart.c **** UARTModemControlSet(unsigned long ulBase, unsigned long ulControl)
 785:C:/StellarisWare/driverlib\uart.c **** {
 847              		.loc 1 785 0
 848              		.cfi_startproc
 849              		@ args = 0, pretend = 0, frame = 16
 850              		@ frame_needed = 1, uses_anonymous_args = 0
 851              		@ link register save eliminated.
 852 0000 80B4     		push	{r7}
 853              	.LCFI45:
 854              		.cfi_def_cfa_offset 4
 855              		.cfi_offset 7, -4
 856 0002 85B0     		sub	sp, sp, #20
 857              	.LCFI46:
 858              		.cfi_def_cfa_offset 24
 859 0004 00AF     		add	r7, sp, #0
 860              	.LCFI47:
 861              		.cfi_def_cfa_register 7
 862 0006 7860     		str	r0, [r7, #4]
 863 0008 3960     		str	r1, [r7, #0]
 786:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulTemp;
 787:C:/StellarisWare/driverlib\uart.c **** 
 788:C:/StellarisWare/driverlib\uart.c ****     //
 789:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 790:C:/StellarisWare/driverlib\uart.c ****     //
 791:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 792:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulBase == UART1_BASE);
 793:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulControl & ~(UART_OUTPUT_RTS | UART_OUTPUT_DTR)) == 0);
 794:C:/StellarisWare/driverlib\uart.c **** 
 795:C:/StellarisWare/driverlib\uart.c ****     //
 796:C:/StellarisWare/driverlib\uart.c ****     // Set the appropriate modem control output bits.
 797:C:/StellarisWare/driverlib\uart.c ****     //
 798:C:/StellarisWare/driverlib\uart.c ****     ulTemp = HWREG(ulBase + UART_O_CTL);
 864              		.loc 1 798 0
 865 000a 7B68     		ldr	r3, [r7, #4]
 866 000c 03F13003 		add	r3, r3, #48
 867 0010 1B68     		ldr	r3, [r3, #0]
 868 0012 FB60     		str	r3, [r7, #12]
 799:C:/StellarisWare/driverlib\uart.c ****     ulTemp |= (ulControl & (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
 869              		.loc 1 799 0
 870 0014 3B68     		ldr	r3, [r7, #0]
 871 0016 03F44063 		and	r3, r3, #3072
 872 001a FA68     		ldr	r2, [r7, #12]
 873 001c 1343     		orrs	r3, r3, r2
 874 001e FB60     		str	r3, [r7, #12]
 800:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ulTemp;
 875              		.loc 1 800 0
 876 0020 7B68     		ldr	r3, [r7, #4]
 877 0022 03F13003 		add	r3, r3, #48
 878 0026 FA68     		ldr	r2, [r7, #12]
 879 0028 1A60     		str	r2, [r3, #0]
 801:C:/StellarisWare/driverlib\uart.c **** }
 880              		.loc 1 801 0
 881 002a 07F11407 		add	r7, r7, #20
 882 002e BD46     		mov	sp, r7
 883 0030 80BC     		pop	{r7}
 884 0032 7047     		bx	lr
 885              		.cfi_endproc
 886              	.LFE15:
 888              		.section	.text.UARTModemControlClear,"ax",%progbits
 889              		.align	2
 890              		.global	UARTModemControlClear
 891              		.thumb
 892              		.thumb_func
 894              	UARTModemControlClear:
 895              	.LFB16:
 802:C:/StellarisWare/driverlib\uart.c **** 
 803:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 804:C:/StellarisWare/driverlib\uart.c **** //
 805:C:/StellarisWare/driverlib\uart.c **** //! Clears the states of the DTR and/or RTS modem control signals.
 806:C:/StellarisWare/driverlib\uart.c **** //!
 807:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 808:C:/StellarisWare/driverlib\uart.c **** //! \param ulControl is a bit-mapped flag indicating which modem control bits
 809:C:/StellarisWare/driverlib\uart.c **** //! should be set.
 810:C:/StellarisWare/driverlib\uart.c **** //!
 811:C:/StellarisWare/driverlib\uart.c **** //! This function clears the states of the DTR or RTS modem handshake outputs
 812:C:/StellarisWare/driverlib\uart.c **** //! from the UART.
 813:C:/StellarisWare/driverlib\uart.c **** //!
 814:C:/StellarisWare/driverlib\uart.c **** //! The \e ulControl parameter is the logical OR of any of the following:
 815:C:/StellarisWare/driverlib\uart.c **** //!
 816:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_OUTPUT_DTR - The Modem Control DTR signal
 817:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_OUTPUT_RTS - The Modem Control RTS signal
 818:C:/StellarisWare/driverlib\uart.c **** //!
 819:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of hardware modem handshake signals varies with the
 820:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part and UART in use.  Please consult the datasheet for the part
 821:C:/StellarisWare/driverlib\uart.c **** //! you are using to determine whether this support is available.
 822:C:/StellarisWare/driverlib\uart.c **** //!
 823:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 824:C:/StellarisWare/driverlib\uart.c **** //
 825:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 826:C:/StellarisWare/driverlib\uart.c **** void
 827:C:/StellarisWare/driverlib\uart.c **** UARTModemControlClear(unsigned long ulBase, unsigned long ulControl)
 828:C:/StellarisWare/driverlib\uart.c **** {
 896              		.loc 1 828 0
 897              		.cfi_startproc
 898              		@ args = 0, pretend = 0, frame = 16
 899              		@ frame_needed = 1, uses_anonymous_args = 0
 900              		@ link register save eliminated.
 901 0000 80B4     		push	{r7}
 902              	.LCFI48:
 903              		.cfi_def_cfa_offset 4
 904              		.cfi_offset 7, -4
 905 0002 85B0     		sub	sp, sp, #20
 906              	.LCFI49:
 907              		.cfi_def_cfa_offset 24
 908 0004 00AF     		add	r7, sp, #0
 909              	.LCFI50:
 910              		.cfi_def_cfa_register 7
 911 0006 7860     		str	r0, [r7, #4]
 912 0008 3960     		str	r1, [r7, #0]
 829:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulTemp;
 830:C:/StellarisWare/driverlib\uart.c **** 
 831:C:/StellarisWare/driverlib\uart.c ****     //
 832:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 833:C:/StellarisWare/driverlib\uart.c ****     //
 834:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 835:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulBase == UART1_BASE);
 836:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulControl & ~(UART_OUTPUT_RTS | UART_OUTPUT_DTR)) == 0);
 837:C:/StellarisWare/driverlib\uart.c **** 
 838:C:/StellarisWare/driverlib\uart.c ****     //
 839:C:/StellarisWare/driverlib\uart.c ****     // Set the appropriate modem control output bits.
 840:C:/StellarisWare/driverlib\uart.c ****     //
 841:C:/StellarisWare/driverlib\uart.c ****     ulTemp = HWREG(ulBase + UART_O_CTL);
 913              		.loc 1 841 0
 914 000a 7B68     		ldr	r3, [r7, #4]
 915 000c 03F13003 		add	r3, r3, #48
 916 0010 1B68     		ldr	r3, [r3, #0]
 917 0012 FB60     		str	r3, [r7, #12]
 842:C:/StellarisWare/driverlib\uart.c ****     ulTemp &= ~(ulControl & (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
 918              		.loc 1 842 0
 919 0014 3B68     		ldr	r3, [r7, #0]
 920 0016 03F44063 		and	r3, r3, #3072
 921 001a 6FEA0303 		mvn	r3, r3
 922 001e FA68     		ldr	r2, [r7, #12]
 923 0020 1340     		ands	r3, r3, r2
 924 0022 FB60     		str	r3, [r7, #12]
 843:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ulTemp;
 925              		.loc 1 843 0
 926 0024 7B68     		ldr	r3, [r7, #4]
 927 0026 03F13003 		add	r3, r3, #48
 928 002a FA68     		ldr	r2, [r7, #12]
 929 002c 1A60     		str	r2, [r3, #0]
 844:C:/StellarisWare/driverlib\uart.c **** }
 930              		.loc 1 844 0
 931 002e 07F11407 		add	r7, r7, #20
 932 0032 BD46     		mov	sp, r7
 933 0034 80BC     		pop	{r7}
 934 0036 7047     		bx	lr
 935              		.cfi_endproc
 936              	.LFE16:
 938              		.section	.text.UARTModemControlGet,"ax",%progbits
 939              		.align	2
 940              		.global	UARTModemControlGet
 941              		.thumb
 942              		.thumb_func
 944              	UARTModemControlGet:
 945              	.LFB17:
 845:C:/StellarisWare/driverlib\uart.c **** 
 846:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 847:C:/StellarisWare/driverlib\uart.c **** //
 848:C:/StellarisWare/driverlib\uart.c **** //! Gets the states of the DTR and RTS modem control signals.
 849:C:/StellarisWare/driverlib\uart.c **** //!
 850:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 851:C:/StellarisWare/driverlib\uart.c **** //!
 852:C:/StellarisWare/driverlib\uart.c **** //! This function returns the current states of each of the two UART modem
 853:C:/StellarisWare/driverlib\uart.c **** //! control signals, DTR and RTS.
 854:C:/StellarisWare/driverlib\uart.c **** //!
 855:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of hardware modem handshake signals varies with the
 856:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part and UART in use.  Please consult the datasheet for the part
 857:C:/StellarisWare/driverlib\uart.c **** //! you are using to determine whether this support is available.
 858:C:/StellarisWare/driverlib\uart.c **** //!
 859:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the states of the handshake output signals.  This value is
 860:C:/StellarisWare/driverlib\uart.c **** //! a logical OR combination of values \b UART_OUTPUT_RTS and
 861:C:/StellarisWare/driverlib\uart.c **** //! \b UART_OUTPUT_DTR where the presence of each flag indicates that the
 862:C:/StellarisWare/driverlib\uart.c **** //! associated signal is asserted.
 863:C:/StellarisWare/driverlib\uart.c **** //
 864:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 865:C:/StellarisWare/driverlib\uart.c **** unsigned long
 866:C:/StellarisWare/driverlib\uart.c **** UARTModemControlGet(unsigned long ulBase)
 867:C:/StellarisWare/driverlib\uart.c **** {
 946              		.loc 1 867 0
 947              		.cfi_startproc
 948              		@ args = 0, pretend = 0, frame = 8
 949              		@ frame_needed = 1, uses_anonymous_args = 0
 950              		@ link register save eliminated.
 951 0000 80B4     		push	{r7}
 952              	.LCFI51:
 953              		.cfi_def_cfa_offset 4
 954              		.cfi_offset 7, -4
 955 0002 83B0     		sub	sp, sp, #12
 956              	.LCFI52:
 957              		.cfi_def_cfa_offset 16
 958 0004 00AF     		add	r7, sp, #0
 959              	.LCFI53:
 960              		.cfi_def_cfa_register 7
 961 0006 7860     		str	r0, [r7, #4]
 868:C:/StellarisWare/driverlib\uart.c ****     //
 869:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 870:C:/StellarisWare/driverlib\uart.c ****     //
 871:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 872:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulBase == UART1_BASE);
 873:C:/StellarisWare/driverlib\uart.c **** 
 874:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_CTL) & (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
 962              		.loc 1 874 0
 963 0008 7B68     		ldr	r3, [r7, #4]
 964 000a 03F13003 		add	r3, r3, #48
 965 000e 1B68     		ldr	r3, [r3, #0]
 966 0010 03F44063 		and	r3, r3, #3072
 875:C:/StellarisWare/driverlib\uart.c **** }
 967              		.loc 1 875 0
 968 0014 1846     		mov	r0, r3
 969 0016 07F10C07 		add	r7, r7, #12
 970 001a BD46     		mov	sp, r7
 971 001c 80BC     		pop	{r7}
 972 001e 7047     		bx	lr
 973              		.cfi_endproc
 974              	.LFE17:
 976              		.section	.text.UARTModemStatusGet,"ax",%progbits
 977              		.align	2
 978              		.global	UARTModemStatusGet
 979              		.thumb
 980              		.thumb_func
 982              	UARTModemStatusGet:
 983              	.LFB18:
 876:C:/StellarisWare/driverlib\uart.c **** 
 877:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 878:C:/StellarisWare/driverlib\uart.c **** //
 879:C:/StellarisWare/driverlib\uart.c **** //! Gets the states of the RI, DCD, DSR and CTS modem status signals.
 880:C:/StellarisWare/driverlib\uart.c **** //!
 881:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 882:C:/StellarisWare/driverlib\uart.c **** //!
 883:C:/StellarisWare/driverlib\uart.c **** //! This function returns the current states of each of the four UART modem
 884:C:/StellarisWare/driverlib\uart.c **** //! status signals, RI, DCD, DSR and CTS.
 885:C:/StellarisWare/driverlib\uart.c **** //!
 886:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of hardware modem handshake signals varies with the
 887:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part and UART in use.  Please consult the datasheet for the part
 888:C:/StellarisWare/driverlib\uart.c **** //! you are using to determine whether this support is available.
 889:C:/StellarisWare/driverlib\uart.c **** //!
 890:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the states of the handshake output signals.  This value
 891:C:/StellarisWare/driverlib\uart.c **** //! is a logical OR combination of values \b UART_INPUT_RI,
 892:C:/StellarisWare/driverlib\uart.c **** //! \b UART_INPUT_DCD, \b UART_INPUT_CTS and \b UART_INPUT_DSR where the
 893:C:/StellarisWare/driverlib\uart.c **** //! presence of each flag indicates that the associated signal is asserted.
 894:C:/StellarisWare/driverlib\uart.c **** //
 895:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 896:C:/StellarisWare/driverlib\uart.c **** unsigned long
 897:C:/StellarisWare/driverlib\uart.c **** UARTModemStatusGet(unsigned long ulBase)
 898:C:/StellarisWare/driverlib\uart.c **** {
 984              		.loc 1 898 0
 985              		.cfi_startproc
 986              		@ args = 0, pretend = 0, frame = 8
 987              		@ frame_needed = 1, uses_anonymous_args = 0
 988              		@ link register save eliminated.
 989 0000 80B4     		push	{r7}
 990              	.LCFI54:
 991              		.cfi_def_cfa_offset 4
 992              		.cfi_offset 7, -4
 993 0002 83B0     		sub	sp, sp, #12
 994              	.LCFI55:
 995              		.cfi_def_cfa_offset 16
 996 0004 00AF     		add	r7, sp, #0
 997              	.LCFI56:
 998              		.cfi_def_cfa_register 7
 999 0006 7860     		str	r0, [r7, #4]
 899:C:/StellarisWare/driverlib\uart.c ****     //
 900:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 901:C:/StellarisWare/driverlib\uart.c ****     //
 902:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 903:C:/StellarisWare/driverlib\uart.c ****     ASSERT(ulBase == UART1_BASE);
 904:C:/StellarisWare/driverlib\uart.c **** 
 905:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_FR) & (UART_INPUT_RI | UART_INPUT_DCD |
 1000              		.loc 1 905 0
 1001 0008 7B68     		ldr	r3, [r7, #4]
 1002 000a 03F11803 		add	r3, r3, #24
 1003 000e 1A68     		ldr	r2, [r3, #0]
 1004 0010 40F20713 		movw	r3, #263
 1005 0014 1340     		ands	r3, r3, r2
 906:C:/StellarisWare/driverlib\uart.c ****            UART_INPUT_CTS | UART_INPUT_DSR));
 907:C:/StellarisWare/driverlib\uart.c **** }
 1006              		.loc 1 907 0
 1007 0016 1846     		mov	r0, r3
 1008 0018 07F10C07 		add	r7, r7, #12
 1009 001c BD46     		mov	sp, r7
 1010 001e 80BC     		pop	{r7}
 1011 0020 7047     		bx	lr
 1012              		.cfi_endproc
 1013              	.LFE18:
 1015 0022 00BF     		.section	.text.UARTFlowControlSet,"ax",%progbits
 1016              		.align	2
 1017              		.global	UARTFlowControlSet
 1018              		.thumb
 1019              		.thumb_func
 1021              	UARTFlowControlSet:
 1022              	.LFB19:
 908:C:/StellarisWare/driverlib\uart.c **** 
 909:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 910:C:/StellarisWare/driverlib\uart.c **** //
 911:C:/StellarisWare/driverlib\uart.c **** //! Sets the UART hardware flow control mode to be used.
 912:C:/StellarisWare/driverlib\uart.c **** //!
 913:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 914:C:/StellarisWare/driverlib\uart.c **** //! \param ulMode indicates the flow control modes to be used.  This parameter
 915:C:/StellarisWare/driverlib\uart.c **** //! is a logical OR combination of values \b UART_FLOWCONTROL_TX and
 916:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FLOWCONTROL_RX to enable hardware transmit (CTS) and receive (RTS)
 917:C:/StellarisWare/driverlib\uart.c **** //! flow control or \b UART_FLOWCONTROL_NONE to disable hardware flow control.
 918:C:/StellarisWare/driverlib\uart.c **** //!
 919:C:/StellarisWare/driverlib\uart.c **** //! This function configures the required hardware flow control modes.  If
 920:C:/StellarisWare/driverlib\uart.c **** //! \e ulMode contains flag \b UART_FLOWCONTROL_TX, data is only transmitted
 921:C:/StellarisWare/driverlib\uart.c **** //! if the incoming CTS signal is asserted. If \e ulMode contains flag
 922:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FLOWCONTROL_RX, the RTS output is controlled by the hardware and is
 923:C:/StellarisWare/driverlib\uart.c **** //! asserted only when there is space available in the receive FIFO.  If no
 924:C:/StellarisWare/driverlib\uart.c **** //! hardware flow control is required, \b UART_FLOWCONTROL_NONE should be
 925:C:/StellarisWare/driverlib\uart.c **** //! passed.
 926:C:/StellarisWare/driverlib\uart.c **** //!
 927:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of hardware flow control varies with the Stellaris
 928:C:/StellarisWare/driverlib\uart.c **** //! part and UART in use.  Please consult the datasheet for the part you are
 929:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
 930:C:/StellarisWare/driverlib\uart.c **** //!
 931:C:/StellarisWare/driverlib\uart.c **** //! \return None.
 932:C:/StellarisWare/driverlib\uart.c **** //
 933:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 934:C:/StellarisWare/driverlib\uart.c **** void
 935:C:/StellarisWare/driverlib\uart.c **** UARTFlowControlSet(unsigned long ulBase, unsigned long ulMode)
 936:C:/StellarisWare/driverlib\uart.c **** {
 1023              		.loc 1 936 0
 1024              		.cfi_startproc
 1025              		@ args = 0, pretend = 0, frame = 8
 1026              		@ frame_needed = 1, uses_anonymous_args = 0
 1027              		@ link register save eliminated.
 1028 0000 80B4     		push	{r7}
 1029              	.LCFI57:
 1030              		.cfi_def_cfa_offset 4
 1031              		.cfi_offset 7, -4
 1032 0002 83B0     		sub	sp, sp, #12
 1033              	.LCFI58:
 1034              		.cfi_def_cfa_offset 16
 1035 0004 00AF     		add	r7, sp, #0
 1036              	.LCFI59:
 1037              		.cfi_def_cfa_register 7
 1038 0006 7860     		str	r0, [r7, #4]
 1039 0008 3960     		str	r1, [r7, #0]
 937:C:/StellarisWare/driverlib\uart.c ****     //
 938:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 939:C:/StellarisWare/driverlib\uart.c ****     //
 940:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 941:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 942:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulMode & ~(UART_FLOWCONTROL_TX | UART_FLOWCONTROL_RX)) == 0);
 943:C:/StellarisWare/driverlib\uart.c **** 
 944:C:/StellarisWare/driverlib\uart.c ****     //
 945:C:/StellarisWare/driverlib\uart.c ****     // Set the flow control mode as requested.
 946:C:/StellarisWare/driverlib\uart.c ****     //
 947:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &
 1040              		.loc 1 947 0
 1041 000a 7B68     		ldr	r3, [r7, #4]
 1042 000c 03F13003 		add	r3, r3, #48
 1043 0010 7A68     		ldr	r2, [r7, #4]
 1044 0012 02F13002 		add	r2, r2, #48
 1045 0016 1268     		ldr	r2, [r2, #0]
 1046 0018 22F44041 		bic	r1, r2, #49152
 948:C:/StellarisWare/driverlib\uart.c ****                                  ~(UART_FLOWCONTROL_TX |
 949:C:/StellarisWare/driverlib\uart.c ****                                    UART_FLOWCONTROL_RX)) | ulMode);
 1047              		.loc 1 949 0
 1048 001c 3A68     		ldr	r2, [r7, #0]
 1049 001e 0A43     		orrs	r2, r2, r1
 947:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &
 1050              		.loc 1 947 0
 1051 0020 1A60     		str	r2, [r3, #0]
 950:C:/StellarisWare/driverlib\uart.c **** }
 1052              		.loc 1 950 0
 1053 0022 07F10C07 		add	r7, r7, #12
 1054 0026 BD46     		mov	sp, r7
 1055 0028 80BC     		pop	{r7}
 1056 002a 7047     		bx	lr
 1057              		.cfi_endproc
 1058              	.LFE19:
 1060              		.section	.text.UARTFlowControlGet,"ax",%progbits
 1061              		.align	2
 1062              		.global	UARTFlowControlGet
 1063              		.thumb
 1064              		.thumb_func
 1066              	UARTFlowControlGet:
 1067              	.LFB20:
 951:C:/StellarisWare/driverlib\uart.c **** 
 952:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 953:C:/StellarisWare/driverlib\uart.c **** //
 954:C:/StellarisWare/driverlib\uart.c **** //! Returns the UART hardware flow control mode currently in use.
 955:C:/StellarisWare/driverlib\uart.c **** //!
 956:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 957:C:/StellarisWare/driverlib\uart.c **** //!
 958:C:/StellarisWare/driverlib\uart.c **** //! This function returns the current hardware flow control mode.
 959:C:/StellarisWare/driverlib\uart.c **** //!
 960:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of hardware flow control varies with the Stellaris
 961:C:/StellarisWare/driverlib\uart.c **** //! part and UART in use.  Please consult the datasheet for the part you are
 962:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
 963:C:/StellarisWare/driverlib\uart.c **** //!
 964:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the current flow control mode in use.  This value is a
 965:C:/StellarisWare/driverlib\uart.c **** //! logical OR combination of values \b UART_FLOWCONTROL_TX if transmit
 966:C:/StellarisWare/driverlib\uart.c **** //! (CTS) flow control is enabled and \b UART_FLOWCONTROL_RX if receive (RTS)
 967:C:/StellarisWare/driverlib\uart.c **** //! flow control is in use.  If hardware flow control is disabled,
 968:C:/StellarisWare/driverlib\uart.c **** //! \b UART_FLOWCONTROL_NONE is returned.
 969:C:/StellarisWare/driverlib\uart.c **** //
 970:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 971:C:/StellarisWare/driverlib\uart.c **** unsigned long
 972:C:/StellarisWare/driverlib\uart.c **** UARTFlowControlGet(unsigned long ulBase)
 973:C:/StellarisWare/driverlib\uart.c **** {
 1068              		.loc 1 973 0
 1069              		.cfi_startproc
 1070              		@ args = 0, pretend = 0, frame = 8
 1071              		@ frame_needed = 1, uses_anonymous_args = 0
 1072              		@ link register save eliminated.
 1073 0000 80B4     		push	{r7}
 1074              	.LCFI60:
 1075              		.cfi_def_cfa_offset 4
 1076              		.cfi_offset 7, -4
 1077 0002 83B0     		sub	sp, sp, #12
 1078              	.LCFI61:
 1079              		.cfi_def_cfa_offset 16
 1080 0004 00AF     		add	r7, sp, #0
 1081              	.LCFI62:
 1082              		.cfi_def_cfa_register 7
 1083 0006 7860     		str	r0, [r7, #4]
 974:C:/StellarisWare/driverlib\uart.c ****     //
 975:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
 976:C:/StellarisWare/driverlib\uart.c ****     //
 977:C:/StellarisWare/driverlib\uart.c ****     ASSERT(!CLASS_IS_SANDSTORM && !CLASS_IS_FURY && !CLASS_IS_DUSTDEVIL);
 978:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
 979:C:/StellarisWare/driverlib\uart.c **** 
 980:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_CTL) & (UART_FLOWCONTROL_TX |
 1084              		.loc 1 980 0
 1085 0008 7B68     		ldr	r3, [r7, #4]
 1086 000a 03F13003 		add	r3, r3, #48
 1087 000e 1B68     		ldr	r3, [r3, #0]
 1088 0010 03F44043 		and	r3, r3, #49152
 981:C:/StellarisWare/driverlib\uart.c ****                                          UART_FLOWCONTROL_RX));
 982:C:/StellarisWare/driverlib\uart.c **** }
 1089              		.loc 1 982 0
 1090 0014 1846     		mov	r0, r3
 1091 0016 07F10C07 		add	r7, r7, #12
 1092 001a BD46     		mov	sp, r7
 1093 001c 80BC     		pop	{r7}
 1094 001e 7047     		bx	lr
 1095              		.cfi_endproc
 1096              	.LFE20:
 1098              		.section	.text.UARTTxIntModeSet,"ax",%progbits
 1099              		.align	2
 1100              		.global	UARTTxIntModeSet
 1101              		.thumb
 1102              		.thumb_func
 1104              	UARTTxIntModeSet:
 1105              	.LFB21:
 983:C:/StellarisWare/driverlib\uart.c **** 
 984:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
 985:C:/StellarisWare/driverlib\uart.c **** //
 986:C:/StellarisWare/driverlib\uart.c **** //! Sets the operating mode for the UART transmit interrupt.
 987:C:/StellarisWare/driverlib\uart.c **** //!
 988:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
 989:C:/StellarisWare/driverlib\uart.c **** //! \param ulMode is the operating mode for the transmit interrupt.  It may be
 990:C:/StellarisWare/driverlib\uart.c **** //! \b UART_TXINT_MODE_EOT to trigger interrupts when the transmitter is idle
 991:C:/StellarisWare/driverlib\uart.c **** //! or \b UART_TXINT_MODE_FIFO to trigger based on the current transmit FIFO
 992:C:/StellarisWare/driverlib\uart.c **** //! level.
 993:C:/StellarisWare/driverlib\uart.c **** //!
 994:C:/StellarisWare/driverlib\uart.c **** //! This function allows the mode of the UART transmit interrupt to be set.  By
 995:C:/StellarisWare/driverlib\uart.c **** //! default, the transmit interrupt is asserted when the FIFO level falls past
 996:C:/StellarisWare/driverlib\uart.c **** //! a threshold set via a call to UARTFIFOLevelSet().  Alternatively, if this
 997:C:/StellarisWare/driverlib\uart.c **** //! function is called with \e ulMode set to \b UART_TXINT_MODE_EOT, the
 998:C:/StellarisWare/driverlib\uart.c **** //! transmit interrupt is asserted once the transmitter is completely idle -
 999:C:/StellarisWare/driverlib\uart.c **** //! the transmit FIFO is empty and all bits, including any stop bits, have
1000:C:/StellarisWare/driverlib\uart.c **** //! cleared the transmitter.
1001:C:/StellarisWare/driverlib\uart.c **** //!
1002:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of end-of-transmission mode varies with the
1003:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
1004:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
1005:C:/StellarisWare/driverlib\uart.c **** //!
1006:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1007:C:/StellarisWare/driverlib\uart.c **** //
1008:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1009:C:/StellarisWare/driverlib\uart.c **** void
1010:C:/StellarisWare/driverlib\uart.c **** UARTTxIntModeSet(unsigned long ulBase, unsigned long ulMode)
1011:C:/StellarisWare/driverlib\uart.c **** {
 1106              		.loc 1 1011 0
 1107              		.cfi_startproc
 1108              		@ args = 0, pretend = 0, frame = 8
 1109              		@ frame_needed = 1, uses_anonymous_args = 0
 1110              		@ link register save eliminated.
 1111 0000 80B4     		push	{r7}
 1112              	.LCFI63:
 1113              		.cfi_def_cfa_offset 4
 1114              		.cfi_offset 7, -4
 1115 0002 83B0     		sub	sp, sp, #12
 1116              	.LCFI64:
 1117              		.cfi_def_cfa_offset 16
 1118 0004 00AF     		add	r7, sp, #0
 1119              	.LCFI65:
 1120              		.cfi_def_cfa_register 7
 1121 0006 7860     		str	r0, [r7, #4]
 1122 0008 3960     		str	r1, [r7, #0]
1012:C:/StellarisWare/driverlib\uart.c ****     //
1013:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1014:C:/StellarisWare/driverlib\uart.c ****     //
1015:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1016:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulMode == UART_TXINT_MODE_EOT) ||
1017:C:/StellarisWare/driverlib\uart.c ****            (ulMode == UART_TXINT_MODE_FIFO));
1018:C:/StellarisWare/driverlib\uart.c **** 
1019:C:/StellarisWare/driverlib\uart.c ****     //
1020:C:/StellarisWare/driverlib\uart.c ****     // Set or clear the EOT bit of the UART control register as appropriate.
1021:C:/StellarisWare/driverlib\uart.c ****     //
1022:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &
 1123              		.loc 1 1022 0
 1124 000a 7B68     		ldr	r3, [r7, #4]
 1125 000c 03F13003 		add	r3, r3, #48
 1126 0010 7A68     		ldr	r2, [r7, #4]
 1127 0012 02F13002 		add	r2, r2, #48
 1128 0016 1268     		ldr	r2, [r2, #0]
 1129 0018 22F01001 		bic	r1, r2, #16
1023:C:/StellarisWare/driverlib\uart.c ****                                  ~(UART_TXINT_MODE_EOT |
1024:C:/StellarisWare/driverlib\uart.c ****                                    UART_TXINT_MODE_FIFO)) | ulMode);
 1130              		.loc 1 1024 0
 1131 001c 3A68     		ldr	r2, [r7, #0]
 1132 001e 0A43     		orrs	r2, r2, r1
1022:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &
 1133              		.loc 1 1022 0
 1134 0020 1A60     		str	r2, [r3, #0]
1025:C:/StellarisWare/driverlib\uart.c **** }
 1135              		.loc 1 1025 0
 1136 0022 07F10C07 		add	r7, r7, #12
 1137 0026 BD46     		mov	sp, r7
 1138 0028 80BC     		pop	{r7}
 1139 002a 7047     		bx	lr
 1140              		.cfi_endproc
 1141              	.LFE21:
 1143              		.section	.text.UARTTxIntModeGet,"ax",%progbits
 1144              		.align	2
 1145              		.global	UARTTxIntModeGet
 1146              		.thumb
 1147              		.thumb_func
 1149              	UARTTxIntModeGet:
 1150              	.LFB22:
1026:C:/StellarisWare/driverlib\uart.c **** 
1027:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1028:C:/StellarisWare/driverlib\uart.c **** //
1029:C:/StellarisWare/driverlib\uart.c **** //! Returns the current operating mode for the UART transmit interrupt.
1030:C:/StellarisWare/driverlib\uart.c **** //!
1031:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1032:C:/StellarisWare/driverlib\uart.c **** //!
1033:C:/StellarisWare/driverlib\uart.c **** //! This function returns the current operating mode for the UART transmit
1034:C:/StellarisWare/driverlib\uart.c **** //! interrupt.  The return value is \b UART_TXINT_MODE_EOT if the transmit
1035:C:/StellarisWare/driverlib\uart.c **** //! interrupt is currently configured to be asserted once the transmitter is
1036:C:/StellarisWare/driverlib\uart.c **** //! completely idle - the transmit FIFO is empty and all bits, including any
1037:C:/StellarisWare/driverlib\uart.c **** //! stop bits, have cleared the transmitter.  The return value is
1038:C:/StellarisWare/driverlib\uart.c **** //! \b UART_TXINT_MODE_FIFO if the interrupt is configured to be asserted based
1039:C:/StellarisWare/driverlib\uart.c **** //! on the level of the transmit FIFO.
1040:C:/StellarisWare/driverlib\uart.c **** //!
1041:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of end-of-transmission mode varies with the
1042:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
1043:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
1044:C:/StellarisWare/driverlib\uart.c **** //!
1045:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b UART_TXINT_MODE_FIFO or \b UART_TXINT_MODE_EOT.
1046:C:/StellarisWare/driverlib\uart.c **** //
1047:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1048:C:/StellarisWare/driverlib\uart.c **** unsigned long
1049:C:/StellarisWare/driverlib\uart.c **** UARTTxIntModeGet(unsigned long ulBase)
1050:C:/StellarisWare/driverlib\uart.c **** {
 1151              		.loc 1 1050 0
 1152              		.cfi_startproc
 1153              		@ args = 0, pretend = 0, frame = 8
 1154              		@ frame_needed = 1, uses_anonymous_args = 0
 1155              		@ link register save eliminated.
 1156 0000 80B4     		push	{r7}
 1157              	.LCFI66:
 1158              		.cfi_def_cfa_offset 4
 1159              		.cfi_offset 7, -4
 1160 0002 83B0     		sub	sp, sp, #12
 1161              	.LCFI67:
 1162              		.cfi_def_cfa_offset 16
 1163 0004 00AF     		add	r7, sp, #0
 1164              	.LCFI68:
 1165              		.cfi_def_cfa_register 7
 1166 0006 7860     		str	r0, [r7, #4]
1051:C:/StellarisWare/driverlib\uart.c ****     //
1052:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1053:C:/StellarisWare/driverlib\uart.c ****     //
1054:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1055:C:/StellarisWare/driverlib\uart.c **** 
1056:C:/StellarisWare/driverlib\uart.c ****     //
1057:C:/StellarisWare/driverlib\uart.c ****     // Return the current transmit interrupt mode.
1058:C:/StellarisWare/driverlib\uart.c ****     //
1059:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_CTL) & (UART_TXINT_MODE_EOT |
 1167              		.loc 1 1059 0
 1168 0008 7B68     		ldr	r3, [r7, #4]
 1169 000a 03F13003 		add	r3, r3, #48
 1170 000e 1B68     		ldr	r3, [r3, #0]
 1171 0010 03F01003 		and	r3, r3, #16
1060:C:/StellarisWare/driverlib\uart.c ****                                          UART_TXINT_MODE_FIFO));
1061:C:/StellarisWare/driverlib\uart.c **** }
 1172              		.loc 1 1061 0
 1173 0014 1846     		mov	r0, r3
 1174 0016 07F10C07 		add	r7, r7, #12
 1175 001a BD46     		mov	sp, r7
 1176 001c 80BC     		pop	{r7}
 1177 001e 7047     		bx	lr
 1178              		.cfi_endproc
 1179              	.LFE22:
 1181              		.section	.text.UARTCharsAvail,"ax",%progbits
 1182              		.align	2
 1183              		.global	UARTCharsAvail
 1184              		.thumb
 1185              		.thumb_func
 1187              	UARTCharsAvail:
 1188              	.LFB23:
1062:C:/StellarisWare/driverlib\uart.c **** 
1063:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1064:C:/StellarisWare/driverlib\uart.c **** //
1065:C:/StellarisWare/driverlib\uart.c **** //! Determines if there are any characters in the receive FIFO.
1066:C:/StellarisWare/driverlib\uart.c **** //!
1067:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1068:C:/StellarisWare/driverlib\uart.c **** //!
1069:C:/StellarisWare/driverlib\uart.c **** //! This function returns a flag indicating whether or not there is data
1070:C:/StellarisWare/driverlib\uart.c **** //! available in the receive FIFO.
1071:C:/StellarisWare/driverlib\uart.c **** //!
1072:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b true if there is data in the receive FIFO or \b false
1073:C:/StellarisWare/driverlib\uart.c **** //! if there is no data in the receive FIFO.
1074:C:/StellarisWare/driverlib\uart.c **** //
1075:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1076:C:/StellarisWare/driverlib\uart.c **** tBoolean
1077:C:/StellarisWare/driverlib\uart.c **** UARTCharsAvail(unsigned long ulBase)
1078:C:/StellarisWare/driverlib\uart.c **** {
 1189              		.loc 1 1078 0
 1190              		.cfi_startproc
 1191              		@ args = 0, pretend = 0, frame = 8
 1192              		@ frame_needed = 1, uses_anonymous_args = 0
 1193              		@ link register save eliminated.
 1194 0000 80B4     		push	{r7}
 1195              	.LCFI69:
 1196              		.cfi_def_cfa_offset 4
 1197              		.cfi_offset 7, -4
 1198 0002 83B0     		sub	sp, sp, #12
 1199              	.LCFI70:
 1200              		.cfi_def_cfa_offset 16
 1201 0004 00AF     		add	r7, sp, #0
 1202              	.LCFI71:
 1203              		.cfi_def_cfa_register 7
 1204 0006 7860     		str	r0, [r7, #4]
1079:C:/StellarisWare/driverlib\uart.c ****     //
1080:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1081:C:/StellarisWare/driverlib\uart.c ****     //
1082:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1083:C:/StellarisWare/driverlib\uart.c **** 
1084:C:/StellarisWare/driverlib\uart.c ****     //
1085:C:/StellarisWare/driverlib\uart.c ****     // Return the availability of characters.
1086:C:/StellarisWare/driverlib\uart.c ****     //
1087:C:/StellarisWare/driverlib\uart.c ****     return((HWREG(ulBase + UART_O_FR) & UART_FR_RXFE) ? false : true);
 1205              		.loc 1 1087 0
 1206 0008 7B68     		ldr	r3, [r7, #4]
 1207 000a 03F11803 		add	r3, r3, #24
 1208 000e 1B68     		ldr	r3, [r3, #0]
 1209 0010 03F01003 		and	r3, r3, #16
 1210 0014 002B     		cmp	r3, #0
 1211 0016 14BF     		ite	ne
 1212 0018 0023     		movne	r3, #0
 1213 001a 0123     		moveq	r3, #1
 1214 001c DBB2     		uxtb	r3, r3
1088:C:/StellarisWare/driverlib\uart.c **** }
 1215              		.loc 1 1088 0
 1216 001e 1846     		mov	r0, r3
 1217 0020 07F10C07 		add	r7, r7, #12
 1218 0024 BD46     		mov	sp, r7
 1219 0026 80BC     		pop	{r7}
 1220 0028 7047     		bx	lr
 1221              		.cfi_endproc
 1222              	.LFE23:
 1224 002a 00BF     		.section	.text.UARTSpaceAvail,"ax",%progbits
 1225              		.align	2
 1226              		.global	UARTSpaceAvail
 1227              		.thumb
 1228              		.thumb_func
 1230              	UARTSpaceAvail:
 1231              	.LFB24:
1089:C:/StellarisWare/driverlib\uart.c **** 
1090:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1091:C:/StellarisWare/driverlib\uart.c **** //
1092:C:/StellarisWare/driverlib\uart.c **** //! Determines if there is any space in the transmit FIFO.
1093:C:/StellarisWare/driverlib\uart.c **** //!
1094:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1095:C:/StellarisWare/driverlib\uart.c **** //!
1096:C:/StellarisWare/driverlib\uart.c **** //! This function returns a flag indicating whether or not there is space
1097:C:/StellarisWare/driverlib\uart.c **** //! available in the transmit FIFO.
1098:C:/StellarisWare/driverlib\uart.c **** //!
1099:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b true if there is space available in the transmit FIFO
1100:C:/StellarisWare/driverlib\uart.c **** //! or \b false if there is no space available in the transmit FIFO.
1101:C:/StellarisWare/driverlib\uart.c **** //
1102:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1103:C:/StellarisWare/driverlib\uart.c **** tBoolean
1104:C:/StellarisWare/driverlib\uart.c **** UARTSpaceAvail(unsigned long ulBase)
1105:C:/StellarisWare/driverlib\uart.c **** {
 1232              		.loc 1 1105 0
 1233              		.cfi_startproc
 1234              		@ args = 0, pretend = 0, frame = 8
 1235              		@ frame_needed = 1, uses_anonymous_args = 0
 1236              		@ link register save eliminated.
 1237 0000 80B4     		push	{r7}
 1238              	.LCFI72:
 1239              		.cfi_def_cfa_offset 4
 1240              		.cfi_offset 7, -4
 1241 0002 83B0     		sub	sp, sp, #12
 1242              	.LCFI73:
 1243              		.cfi_def_cfa_offset 16
 1244 0004 00AF     		add	r7, sp, #0
 1245              	.LCFI74:
 1246              		.cfi_def_cfa_register 7
 1247 0006 7860     		str	r0, [r7, #4]
1106:C:/StellarisWare/driverlib\uart.c ****     //
1107:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1108:C:/StellarisWare/driverlib\uart.c ****     //
1109:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1110:C:/StellarisWare/driverlib\uart.c **** 
1111:C:/StellarisWare/driverlib\uart.c ****     //
1112:C:/StellarisWare/driverlib\uart.c ****     // Return the availability of space.
1113:C:/StellarisWare/driverlib\uart.c ****     //
1114:C:/StellarisWare/driverlib\uart.c ****     return((HWREG(ulBase + UART_O_FR) & UART_FR_TXFF) ? false : true);
 1248              		.loc 1 1114 0
 1249 0008 7B68     		ldr	r3, [r7, #4]
 1250 000a 03F11803 		add	r3, r3, #24
 1251 000e 1B68     		ldr	r3, [r3, #0]
 1252 0010 03F02003 		and	r3, r3, #32
 1253 0014 002B     		cmp	r3, #0
 1254 0016 14BF     		ite	ne
 1255 0018 0023     		movne	r3, #0
 1256 001a 0123     		moveq	r3, #1
 1257 001c DBB2     		uxtb	r3, r3
1115:C:/StellarisWare/driverlib\uart.c **** }
 1258              		.loc 1 1115 0
 1259 001e 1846     		mov	r0, r3
 1260 0020 07F10C07 		add	r7, r7, #12
 1261 0024 BD46     		mov	sp, r7
 1262 0026 80BC     		pop	{r7}
 1263 0028 7047     		bx	lr
 1264              		.cfi_endproc
 1265              	.LFE24:
 1267 002a 00BF     		.section	.text.UARTCharGetNonBlocking,"ax",%progbits
 1268              		.align	2
 1269              		.global	UARTCharGetNonBlocking
 1270              		.thumb
 1271              		.thumb_func
 1273              	UARTCharGetNonBlocking:
 1274              	.LFB25:
1116:C:/StellarisWare/driverlib\uart.c **** 
1117:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1118:C:/StellarisWare/driverlib\uart.c **** //
1119:C:/StellarisWare/driverlib\uart.c **** //! Receives a character from the specified port.
1120:C:/StellarisWare/driverlib\uart.c **** //!
1121:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1122:C:/StellarisWare/driverlib\uart.c **** //!
1123:C:/StellarisWare/driverlib\uart.c **** //! This function gets a character from the receive FIFO for the specified
1124:C:/StellarisWare/driverlib\uart.c **** //! port.
1125:C:/StellarisWare/driverlib\uart.c **** //!
1126:C:/StellarisWare/driverlib\uart.c **** //! This function replaces the original UARTCharNonBlockingGet() API and
1127:C:/StellarisWare/driverlib\uart.c **** //! performs the same actions.  A macro is provided in <tt>uart.h</tt> to map
1128:C:/StellarisWare/driverlib\uart.c **** //! the original API to this API.
1129:C:/StellarisWare/driverlib\uart.c **** //!
1130:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the character read from the specified port, cast as a
1131:C:/StellarisWare/driverlib\uart.c **** //! \e long.  A \b -1 is returned if there are no characters present in the
1132:C:/StellarisWare/driverlib\uart.c **** //! receive FIFO.  The UARTCharsAvail() function should be called before
1133:C:/StellarisWare/driverlib\uart.c **** //! attempting to call this function.
1134:C:/StellarisWare/driverlib\uart.c **** //
1135:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1136:C:/StellarisWare/driverlib\uart.c **** long
1137:C:/StellarisWare/driverlib\uart.c **** UARTCharGetNonBlocking(unsigned long ulBase)
1138:C:/StellarisWare/driverlib\uart.c **** {
 1275              		.loc 1 1138 0
 1276              		.cfi_startproc
 1277              		@ args = 0, pretend = 0, frame = 8
 1278              		@ frame_needed = 1, uses_anonymous_args = 0
 1279              		@ link register save eliminated.
 1280 0000 80B4     		push	{r7}
 1281              	.LCFI75:
 1282              		.cfi_def_cfa_offset 4
 1283              		.cfi_offset 7, -4
 1284 0002 83B0     		sub	sp, sp, #12
 1285              	.LCFI76:
 1286              		.cfi_def_cfa_offset 16
 1287 0004 00AF     		add	r7, sp, #0
 1288              	.LCFI77:
 1289              		.cfi_def_cfa_register 7
 1290 0006 7860     		str	r0, [r7, #4]
1139:C:/StellarisWare/driverlib\uart.c ****     //
1140:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1141:C:/StellarisWare/driverlib\uart.c ****     //
1142:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1143:C:/StellarisWare/driverlib\uart.c **** 
1144:C:/StellarisWare/driverlib\uart.c ****     //
1145:C:/StellarisWare/driverlib\uart.c ****     // See if there are any characters in the receive FIFO.
1146:C:/StellarisWare/driverlib\uart.c ****     //
1147:C:/StellarisWare/driverlib\uart.c ****     if(!(HWREG(ulBase + UART_O_FR) & UART_FR_RXFE))
 1291              		.loc 1 1147 0
 1292 0008 7B68     		ldr	r3, [r7, #4]
 1293 000a 03F11803 		add	r3, r3, #24
 1294 000e 1B68     		ldr	r3, [r3, #0]
 1295 0010 03F01003 		and	r3, r3, #16
 1296 0014 002B     		cmp	r3, #0
 1297 0016 02D1     		bne	.L37
1148:C:/StellarisWare/driverlib\uart.c ****     {
1149:C:/StellarisWare/driverlib\uart.c ****         //
1150:C:/StellarisWare/driverlib\uart.c ****         // Read and return the next character.
1151:C:/StellarisWare/driverlib\uart.c ****         //
1152:C:/StellarisWare/driverlib\uart.c ****         return(HWREG(ulBase + UART_O_DR));
 1298              		.loc 1 1152 0
 1299 0018 7B68     		ldr	r3, [r7, #4]
 1300 001a 1B68     		ldr	r3, [r3, #0]
 1301 001c 01E0     		b	.L38
 1302              	.L37:
1153:C:/StellarisWare/driverlib\uart.c ****     }
1154:C:/StellarisWare/driverlib\uart.c ****     else
1155:C:/StellarisWare/driverlib\uart.c ****     {
1156:C:/StellarisWare/driverlib\uart.c ****         //
1157:C:/StellarisWare/driverlib\uart.c ****         // There are no characters, so return a failure.
1158:C:/StellarisWare/driverlib\uart.c ****         //
1159:C:/StellarisWare/driverlib\uart.c ****         return(-1);
 1303              		.loc 1 1159 0
 1304 001e 4FF0FF33 		mov	r3, #-1
 1305              	.L38:
1160:C:/StellarisWare/driverlib\uart.c ****     }
1161:C:/StellarisWare/driverlib\uart.c **** }
 1306              		.loc 1 1161 0
 1307 0022 1846     		mov	r0, r3
 1308 0024 07F10C07 		add	r7, r7, #12
 1309 0028 BD46     		mov	sp, r7
 1310 002a 80BC     		pop	{r7}
 1311 002c 7047     		bx	lr
 1312              		.cfi_endproc
 1313              	.LFE25:
 1315 002e 00BF     		.section	.text.UARTCharGet,"ax",%progbits
 1316              		.align	2
 1317              		.global	UARTCharGet
 1318              		.thumb
 1319              		.thumb_func
 1321              	UARTCharGet:
 1322              	.LFB26:
1162:C:/StellarisWare/driverlib\uart.c **** 
1163:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1164:C:/StellarisWare/driverlib\uart.c **** //
1165:C:/StellarisWare/driverlib\uart.c **** //! Waits for a character from the specified port.
1166:C:/StellarisWare/driverlib\uart.c **** //!
1167:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1168:C:/StellarisWare/driverlib\uart.c **** //!
1169:C:/StellarisWare/driverlib\uart.c **** //! This function gets a character from the receive FIFO for the specified
1170:C:/StellarisWare/driverlib\uart.c **** //! port.  If there are no characters available, this function waits until a
1171:C:/StellarisWare/driverlib\uart.c **** //! character is received before returning.
1172:C:/StellarisWare/driverlib\uart.c **** //!
1173:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the character read from the specified port, cast as a
1174:C:/StellarisWare/driverlib\uart.c **** //! \e long.
1175:C:/StellarisWare/driverlib\uart.c **** //
1176:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1177:C:/StellarisWare/driverlib\uart.c **** long
1178:C:/StellarisWare/driverlib\uart.c **** UARTCharGet(unsigned long ulBase)
1179:C:/StellarisWare/driverlib\uart.c **** {
 1323              		.loc 1 1179 0
 1324              		.cfi_startproc
 1325              		@ args = 0, pretend = 0, frame = 8
 1326              		@ frame_needed = 1, uses_anonymous_args = 0
 1327              		@ link register save eliminated.
 1328 0000 80B4     		push	{r7}
 1329              	.LCFI78:
 1330              		.cfi_def_cfa_offset 4
 1331              		.cfi_offset 7, -4
 1332 0002 83B0     		sub	sp, sp, #12
 1333              	.LCFI79:
 1334              		.cfi_def_cfa_offset 16
 1335 0004 00AF     		add	r7, sp, #0
 1336              	.LCFI80:
 1337              		.cfi_def_cfa_register 7
 1338 0006 7860     		str	r0, [r7, #4]
1180:C:/StellarisWare/driverlib\uart.c ****     //
1181:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1182:C:/StellarisWare/driverlib\uart.c ****     //
1183:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1184:C:/StellarisWare/driverlib\uart.c **** 
1185:C:/StellarisWare/driverlib\uart.c ****     //
1186:C:/StellarisWare/driverlib\uart.c ****     // Wait until a char is available.
1187:C:/StellarisWare/driverlib\uart.c ****     //
1188:C:/StellarisWare/driverlib\uart.c ****     while(HWREG(ulBase + UART_O_FR) & UART_FR_RXFE)
 1339              		.loc 1 1188 0
 1340 0008 00BF     		nop
 1341              	.L40:
 1342              		.loc 1 1188 0 is_stmt 0 discriminator 1
 1343 000a 7B68     		ldr	r3, [r7, #4]
 1344 000c 03F11803 		add	r3, r3, #24
 1345 0010 1B68     		ldr	r3, [r3, #0]
 1346 0012 03F01003 		and	r3, r3, #16
 1347 0016 002B     		cmp	r3, #0
 1348 0018 F7D1     		bne	.L40
1189:C:/StellarisWare/driverlib\uart.c ****     {
1190:C:/StellarisWare/driverlib\uart.c ****     }
1191:C:/StellarisWare/driverlib\uart.c **** 
1192:C:/StellarisWare/driverlib\uart.c ****     //
1193:C:/StellarisWare/driverlib\uart.c ****     // Now get the char.
1194:C:/StellarisWare/driverlib\uart.c ****     //
1195:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_DR));
 1349              		.loc 1 1195 0 is_stmt 1
 1350 001a 7B68     		ldr	r3, [r7, #4]
 1351 001c 1B68     		ldr	r3, [r3, #0]
1196:C:/StellarisWare/driverlib\uart.c **** }
 1352              		.loc 1 1196 0
 1353 001e 1846     		mov	r0, r3
 1354 0020 07F10C07 		add	r7, r7, #12
 1355 0024 BD46     		mov	sp, r7
 1356 0026 80BC     		pop	{r7}
 1357 0028 7047     		bx	lr
 1358              		.cfi_endproc
 1359              	.LFE26:
 1361 002a 00BF     		.section	.text.UARTCharPutNonBlocking,"ax",%progbits
 1362              		.align	2
 1363              		.global	UARTCharPutNonBlocking
 1364              		.thumb
 1365              		.thumb_func
 1367              	UARTCharPutNonBlocking:
 1368              	.LFB27:
1197:C:/StellarisWare/driverlib\uart.c **** 
1198:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1199:C:/StellarisWare/driverlib\uart.c **** //
1200:C:/StellarisWare/driverlib\uart.c **** //! Sends a character to the specified port.
1201:C:/StellarisWare/driverlib\uart.c **** //!
1202:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1203:C:/StellarisWare/driverlib\uart.c **** //! \param ucData is the character to be transmitted.
1204:C:/StellarisWare/driverlib\uart.c **** //!
1205:C:/StellarisWare/driverlib\uart.c **** //! This function writes the character \e ucData to the transmit FIFO for the
1206:C:/StellarisWare/driverlib\uart.c **** //! specified port.  This function does not block, so if there is no space
1207:C:/StellarisWare/driverlib\uart.c **** //! available, then a \b false is returned and the application must retry the
1208:C:/StellarisWare/driverlib\uart.c **** //! function later.
1209:C:/StellarisWare/driverlib\uart.c **** //!
1210:C:/StellarisWare/driverlib\uart.c **** //! This function replaces the original UARTCharNonBlockingPut() API and
1211:C:/StellarisWare/driverlib\uart.c **** //! performs the same actions.  A macro is provided in <tt>uart.h</tt> to map
1212:C:/StellarisWare/driverlib\uart.c **** //! the original API to this API.
1213:C:/StellarisWare/driverlib\uart.c **** //!
1214:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b true if the character was successfully placed in the
1215:C:/StellarisWare/driverlib\uart.c **** //! transmit FIFO or \b false if there was no space available in the transmit
1216:C:/StellarisWare/driverlib\uart.c **** //! FIFO.
1217:C:/StellarisWare/driverlib\uart.c **** //
1218:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1219:C:/StellarisWare/driverlib\uart.c **** tBoolean
1220:C:/StellarisWare/driverlib\uart.c **** UARTCharPutNonBlocking(unsigned long ulBase, unsigned char ucData)
1221:C:/StellarisWare/driverlib\uart.c **** {
 1369              		.loc 1 1221 0
 1370              		.cfi_startproc
 1371              		@ args = 0, pretend = 0, frame = 8
 1372              		@ frame_needed = 1, uses_anonymous_args = 0
 1373              		@ link register save eliminated.
 1374 0000 80B4     		push	{r7}
 1375              	.LCFI81:
 1376              		.cfi_def_cfa_offset 4
 1377              		.cfi_offset 7, -4
 1378 0002 83B0     		sub	sp, sp, #12
 1379              	.LCFI82:
 1380              		.cfi_def_cfa_offset 16
 1381 0004 00AF     		add	r7, sp, #0
 1382              	.LCFI83:
 1383              		.cfi_def_cfa_register 7
 1384 0006 7860     		str	r0, [r7, #4]
 1385 0008 0B46     		mov	r3, r1
 1386 000a FB70     		strb	r3, [r7, #3]
1222:C:/StellarisWare/driverlib\uart.c ****     //
1223:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1224:C:/StellarisWare/driverlib\uart.c ****     //
1225:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1226:C:/StellarisWare/driverlib\uart.c **** 
1227:C:/StellarisWare/driverlib\uart.c ****     //
1228:C:/StellarisWare/driverlib\uart.c ****     // See if there is space in the transmit FIFO.
1229:C:/StellarisWare/driverlib\uart.c ****     //
1230:C:/StellarisWare/driverlib\uart.c ****     if(!(HWREG(ulBase + UART_O_FR) & UART_FR_TXFF))
 1387              		.loc 1 1230 0
 1388 000c 7B68     		ldr	r3, [r7, #4]
 1389 000e 03F11803 		add	r3, r3, #24
 1390 0012 1B68     		ldr	r3, [r3, #0]
 1391 0014 03F02003 		and	r3, r3, #32
 1392 0018 002B     		cmp	r3, #0
 1393 001a 05D1     		bne	.L42
1231:C:/StellarisWare/driverlib\uart.c ****     {
1232:C:/StellarisWare/driverlib\uart.c ****         //
1233:C:/StellarisWare/driverlib\uart.c ****         // Write this character to the transmit FIFO.
1234:C:/StellarisWare/driverlib\uart.c ****         //
1235:C:/StellarisWare/driverlib\uart.c ****         HWREG(ulBase + UART_O_DR) = ucData;
 1394              		.loc 1 1235 0
 1395 001c 7B68     		ldr	r3, [r7, #4]
 1396 001e FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1397 0020 1A60     		str	r2, [r3, #0]
1236:C:/StellarisWare/driverlib\uart.c **** 
1237:C:/StellarisWare/driverlib\uart.c ****         //
1238:C:/StellarisWare/driverlib\uart.c ****         // Success.
1239:C:/StellarisWare/driverlib\uart.c ****         //
1240:C:/StellarisWare/driverlib\uart.c ****         return(true);
 1398              		.loc 1 1240 0
 1399 0022 4FF00103 		mov	r3, #1
 1400 0026 01E0     		b	.L43
 1401              	.L42:
1241:C:/StellarisWare/driverlib\uart.c ****     }
1242:C:/StellarisWare/driverlib\uart.c ****     else
1243:C:/StellarisWare/driverlib\uart.c ****     {
1244:C:/StellarisWare/driverlib\uart.c ****         //
1245:C:/StellarisWare/driverlib\uart.c ****         // There is no space in the transmit FIFO, so return a failure.
1246:C:/StellarisWare/driverlib\uart.c ****         //
1247:C:/StellarisWare/driverlib\uart.c ****         return(false);
 1402              		.loc 1 1247 0
 1403 0028 4FF00003 		mov	r3, #0
 1404              	.L43:
1248:C:/StellarisWare/driverlib\uart.c ****     }
1249:C:/StellarisWare/driverlib\uart.c **** }
 1405              		.loc 1 1249 0
 1406 002c 1846     		mov	r0, r3
 1407 002e 07F10C07 		add	r7, r7, #12
 1408 0032 BD46     		mov	sp, r7
 1409 0034 80BC     		pop	{r7}
 1410 0036 7047     		bx	lr
 1411              		.cfi_endproc
 1412              	.LFE27:
 1414              		.section	.text.UARTCharPut,"ax",%progbits
 1415              		.align	2
 1416              		.global	UARTCharPut
 1417              		.thumb
 1418              		.thumb_func
 1420              	UARTCharPut:
 1421              	.LFB28:
1250:C:/StellarisWare/driverlib\uart.c **** 
1251:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1252:C:/StellarisWare/driverlib\uart.c **** //
1253:C:/StellarisWare/driverlib\uart.c **** //! Waits to send a character from the specified port.
1254:C:/StellarisWare/driverlib\uart.c **** //!
1255:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1256:C:/StellarisWare/driverlib\uart.c **** //! \param ucData is the character to be transmitted.
1257:C:/StellarisWare/driverlib\uart.c **** //!
1258:C:/StellarisWare/driverlib\uart.c **** //! This function sends the character \e ucData to the transmit FIFO for the
1259:C:/StellarisWare/driverlib\uart.c **** //! specified port.  If there is no space available in the transmit FIFO, this
1260:C:/StellarisWare/driverlib\uart.c **** //! function waits until there is space available before returning.
1261:C:/StellarisWare/driverlib\uart.c **** //!
1262:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1263:C:/StellarisWare/driverlib\uart.c **** //
1264:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1265:C:/StellarisWare/driverlib\uart.c **** void
1266:C:/StellarisWare/driverlib\uart.c **** UARTCharPut(unsigned long ulBase, unsigned char ucData)
1267:C:/StellarisWare/driverlib\uart.c **** {
 1422              		.loc 1 1267 0
 1423              		.cfi_startproc
 1424              		@ args = 0, pretend = 0, frame = 8
 1425              		@ frame_needed = 1, uses_anonymous_args = 0
 1426              		@ link register save eliminated.
 1427 0000 80B4     		push	{r7}
 1428              	.LCFI84:
 1429              		.cfi_def_cfa_offset 4
 1430              		.cfi_offset 7, -4
 1431 0002 83B0     		sub	sp, sp, #12
 1432              	.LCFI85:
 1433              		.cfi_def_cfa_offset 16
 1434 0004 00AF     		add	r7, sp, #0
 1435              	.LCFI86:
 1436              		.cfi_def_cfa_register 7
 1437 0006 7860     		str	r0, [r7, #4]
 1438 0008 0B46     		mov	r3, r1
 1439 000a FB70     		strb	r3, [r7, #3]
1268:C:/StellarisWare/driverlib\uart.c ****     //
1269:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1270:C:/StellarisWare/driverlib\uart.c ****     //
1271:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1272:C:/StellarisWare/driverlib\uart.c **** 
1273:C:/StellarisWare/driverlib\uart.c ****     //
1274:C:/StellarisWare/driverlib\uart.c ****     // Wait until space is available.
1275:C:/StellarisWare/driverlib\uart.c ****     //
1276:C:/StellarisWare/driverlib\uart.c ****     while(HWREG(ulBase + UART_O_FR) & UART_FR_TXFF)
 1440              		.loc 1 1276 0
 1441 000c 00BF     		nop
 1442              	.L45:
 1443              		.loc 1 1276 0 is_stmt 0 discriminator 1
 1444 000e 7B68     		ldr	r3, [r7, #4]
 1445 0010 03F11803 		add	r3, r3, #24
 1446 0014 1B68     		ldr	r3, [r3, #0]
 1447 0016 03F02003 		and	r3, r3, #32
 1448 001a 002B     		cmp	r3, #0
 1449 001c F7D1     		bne	.L45
1277:C:/StellarisWare/driverlib\uart.c ****     {
1278:C:/StellarisWare/driverlib\uart.c ****     }
1279:C:/StellarisWare/driverlib\uart.c **** 
1280:C:/StellarisWare/driverlib\uart.c ****     //
1281:C:/StellarisWare/driverlib\uart.c ****     // Send the char.
1282:C:/StellarisWare/driverlib\uart.c ****     //
1283:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_DR) = ucData;
 1450              		.loc 1 1283 0 is_stmt 1
 1451 001e 7B68     		ldr	r3, [r7, #4]
 1452 0020 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1453 0022 1A60     		str	r2, [r3, #0]
1284:C:/StellarisWare/driverlib\uart.c **** }
 1454              		.loc 1 1284 0
 1455 0024 07F10C07 		add	r7, r7, #12
 1456 0028 BD46     		mov	sp, r7
 1457 002a 80BC     		pop	{r7}
 1458 002c 7047     		bx	lr
 1459              		.cfi_endproc
 1460              	.LFE28:
 1462 002e 00BF     		.section	.text.UARTBreakCtl,"ax",%progbits
 1463              		.align	2
 1464              		.global	UARTBreakCtl
 1465              		.thumb
 1466              		.thumb_func
 1468              	UARTBreakCtl:
 1469              	.LFB29:
1285:C:/StellarisWare/driverlib\uart.c **** 
1286:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1287:C:/StellarisWare/driverlib\uart.c **** //
1288:C:/StellarisWare/driverlib\uart.c **** //! Causes a BREAK to be sent.
1289:C:/StellarisWare/driverlib\uart.c **** //!
1290:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1291:C:/StellarisWare/driverlib\uart.c **** //! \param bBreakState controls the output level.
1292:C:/StellarisWare/driverlib\uart.c **** //!
1293:C:/StellarisWare/driverlib\uart.c **** //! Calling this function with \e bBreakState set to \b true asserts a break
1294:C:/StellarisWare/driverlib\uart.c **** //! condition on the UART.  Calling this function with \e bBreakState set to
1295:C:/StellarisWare/driverlib\uart.c **** //! \b false removes the break condition.  For proper transmission of a break
1296:C:/StellarisWare/driverlib\uart.c **** //! command, the break must be asserted for at least two complete frames.
1297:C:/StellarisWare/driverlib\uart.c **** //!
1298:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1299:C:/StellarisWare/driverlib\uart.c **** //
1300:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1301:C:/StellarisWare/driverlib\uart.c **** void
1302:C:/StellarisWare/driverlib\uart.c **** UARTBreakCtl(unsigned long ulBase, tBoolean bBreakState)
1303:C:/StellarisWare/driverlib\uart.c **** {
 1470              		.loc 1 1303 0
 1471              		.cfi_startproc
 1472              		@ args = 0, pretend = 0, frame = 8
 1473              		@ frame_needed = 1, uses_anonymous_args = 0
 1474              		@ link register save eliminated.
 1475 0000 80B4     		push	{r7}
 1476              	.LCFI87:
 1477              		.cfi_def_cfa_offset 4
 1478              		.cfi_offset 7, -4
 1479 0002 83B0     		sub	sp, sp, #12
 1480              	.LCFI88:
 1481              		.cfi_def_cfa_offset 16
 1482 0004 00AF     		add	r7, sp, #0
 1483              	.LCFI89:
 1484              		.cfi_def_cfa_register 7
 1485 0006 7860     		str	r0, [r7, #4]
 1486 0008 0B46     		mov	r3, r1
 1487 000a FB70     		strb	r3, [r7, #3]
1304:C:/StellarisWare/driverlib\uart.c ****     //
1305:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1306:C:/StellarisWare/driverlib\uart.c ****     //
1307:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1308:C:/StellarisWare/driverlib\uart.c **** 
1309:C:/StellarisWare/driverlib\uart.c ****     //
1310:C:/StellarisWare/driverlib\uart.c ****     // Set the break condition as requested.
1311:C:/StellarisWare/driverlib\uart.c ****     //
1312:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) =
 1488              		.loc 1 1312 0
 1489 000c 7B68     		ldr	r3, [r7, #4]
 1490 000e 03F12C03 		add	r3, r3, #44
 1491 0012 1A46     		mov	r2, r3
1313:C:/StellarisWare/driverlib\uart.c ****         (bBreakState ?
1314:C:/StellarisWare/driverlib\uart.c ****          (HWREG(ulBase + UART_O_LCRH) | UART_LCRH_BRK) :
 1492              		.loc 1 1314 0
 1493 0014 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1494 0016 002B     		cmp	r3, #0
 1495 0018 06D0     		beq	.L47
 1496              		.loc 1 1314 0 is_stmt 0 discriminator 1
 1497 001a 7B68     		ldr	r3, [r7, #4]
 1498 001c 03F12C03 		add	r3, r3, #44
 1499 0020 1B68     		ldr	r3, [r3, #0]
 1500 0022 43F00103 		orr	r3, r3, #1
 1501 0026 05E0     		b	.L48
 1502              	.L47:
1315:C:/StellarisWare/driverlib\uart.c ****          (HWREG(ulBase + UART_O_LCRH) & ~(UART_LCRH_BRK)));
 1503              		.loc 1 1315 0 is_stmt 1 discriminator 2
 1504 0028 7B68     		ldr	r3, [r7, #4]
 1505 002a 03F12C03 		add	r3, r3, #44
 1506 002e 1B68     		ldr	r3, [r3, #0]
1314:C:/StellarisWare/driverlib\uart.c ****          (HWREG(ulBase + UART_O_LCRH) | UART_LCRH_BRK) :
 1507              		.loc 1 1314 0 discriminator 2
 1508 0030 23F00103 		bic	r3, r3, #1
 1509              	.L48:
1312:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) =
 1510              		.loc 1 1312 0
 1511 0034 1360     		str	r3, [r2, #0]
1316:C:/StellarisWare/driverlib\uart.c **** }
 1512              		.loc 1 1316 0
 1513 0036 07F10C07 		add	r7, r7, #12
 1514 003a BD46     		mov	sp, r7
 1515 003c 80BC     		pop	{r7}
 1516 003e 7047     		bx	lr
 1517              		.cfi_endproc
 1518              	.LFE29:
 1520              		.section	.text.UARTBusy,"ax",%progbits
 1521              		.align	2
 1522              		.global	UARTBusy
 1523              		.thumb
 1524              		.thumb_func
 1526              	UARTBusy:
 1527              	.LFB30:
1317:C:/StellarisWare/driverlib\uart.c **** 
1318:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1319:C:/StellarisWare/driverlib\uart.c **** //
1320:C:/StellarisWare/driverlib\uart.c **** //! Determines whether the UART transmitter is busy or not.
1321:C:/StellarisWare/driverlib\uart.c **** //!
1322:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1323:C:/StellarisWare/driverlib\uart.c **** //!
1324:C:/StellarisWare/driverlib\uart.c **** //! This function allows the caller to determine whether all transmitted bytes
1325:C:/StellarisWare/driverlib\uart.c **** //! have cleared the transmitter hardware.  If \b false is returned, the
1326:C:/StellarisWare/driverlib\uart.c **** //! transmit FIFO is empty and all bits of the last transmitted character,
1327:C:/StellarisWare/driverlib\uart.c **** //! including all stop bits, have left the hardware shift register.
1328:C:/StellarisWare/driverlib\uart.c **** //!
1329:C:/StellarisWare/driverlib\uart.c **** //! \return Returns \b true if the UART is transmitting or \b false if all
1330:C:/StellarisWare/driverlib\uart.c **** //! transmissions are complete.
1331:C:/StellarisWare/driverlib\uart.c **** //
1332:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1333:C:/StellarisWare/driverlib\uart.c **** tBoolean
1334:C:/StellarisWare/driverlib\uart.c **** UARTBusy(unsigned long ulBase)
1335:C:/StellarisWare/driverlib\uart.c **** {
 1528              		.loc 1 1335 0
 1529              		.cfi_startproc
 1530              		@ args = 0, pretend = 0, frame = 8
 1531              		@ frame_needed = 1, uses_anonymous_args = 0
 1532              		@ link register save eliminated.
 1533 0000 80B4     		push	{r7}
 1534              	.LCFI90:
 1535              		.cfi_def_cfa_offset 4
 1536              		.cfi_offset 7, -4
 1537 0002 83B0     		sub	sp, sp, #12
 1538              	.LCFI91:
 1539              		.cfi_def_cfa_offset 16
 1540 0004 00AF     		add	r7, sp, #0
 1541              	.LCFI92:
 1542              		.cfi_def_cfa_register 7
 1543 0006 7860     		str	r0, [r7, #4]
1336:C:/StellarisWare/driverlib\uart.c ****     //
1337:C:/StellarisWare/driverlib\uart.c ****     // Check the argument.
1338:C:/StellarisWare/driverlib\uart.c ****     //
1339:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1340:C:/StellarisWare/driverlib\uart.c **** 
1341:C:/StellarisWare/driverlib\uart.c ****     //
1342:C:/StellarisWare/driverlib\uart.c ****     // Determine if the UART is busy.
1343:C:/StellarisWare/driverlib\uart.c ****     //
1344:C:/StellarisWare/driverlib\uart.c ****     return((HWREG(ulBase + UART_O_FR) & UART_FR_BUSY) ? true : false);
 1544              		.loc 1 1344 0
 1545 0008 7B68     		ldr	r3, [r7, #4]
 1546 000a 03F11803 		add	r3, r3, #24
 1547 000e 1B68     		ldr	r3, [r3, #0]
 1548 0010 03F00803 		and	r3, r3, #8
 1549 0014 002B     		cmp	r3, #0
 1550 0016 0CBF     		ite	eq
 1551 0018 0023     		moveq	r3, #0
 1552 001a 0123     		movne	r3, #1
 1553 001c DBB2     		uxtb	r3, r3
1345:C:/StellarisWare/driverlib\uart.c **** }
 1554              		.loc 1 1345 0
 1555 001e 1846     		mov	r0, r3
 1556 0020 07F10C07 		add	r7, r7, #12
 1557 0024 BD46     		mov	sp, r7
 1558 0026 80BC     		pop	{r7}
 1559 0028 7047     		bx	lr
 1560              		.cfi_endproc
 1561              	.LFE30:
 1563 002a 00BF     		.section	.text.UARTIntRegister,"ax",%progbits
 1564              		.align	2
 1565              		.global	UARTIntRegister
 1566              		.thumb
 1567              		.thumb_func
 1569              	UARTIntRegister:
 1570              	.LFB31:
1346:C:/StellarisWare/driverlib\uart.c **** 
1347:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1348:C:/StellarisWare/driverlib\uart.c **** //
1349:C:/StellarisWare/driverlib\uart.c **** //! Registers an interrupt handler for a UART interrupt.
1350:C:/StellarisWare/driverlib\uart.c **** //!
1351:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1352:C:/StellarisWare/driverlib\uart.c **** //! \param pfnHandler is a pointer to the function to be called when the
1353:C:/StellarisWare/driverlib\uart.c **** //! UART interrupt occurs.
1354:C:/StellarisWare/driverlib\uart.c **** //!
1355:C:/StellarisWare/driverlib\uart.c **** //! This function does the actual registering of the interrupt handler.  This
1356:C:/StellarisWare/driverlib\uart.c **** //! function enables the global interrupt in the interrupt controller; specific
1357:C:/StellarisWare/driverlib\uart.c **** //! UART interrupts must be enabled via UARTIntEnable().  It is the interrupt
1358:C:/StellarisWare/driverlib\uart.c **** //! handler's responsibility to clear the interrupt source.
1359:C:/StellarisWare/driverlib\uart.c **** //!
1360:C:/StellarisWare/driverlib\uart.c **** //! \sa IntRegister() for important information about registering interrupt
1361:C:/StellarisWare/driverlib\uart.c **** //! handlers.
1362:C:/StellarisWare/driverlib\uart.c **** //!
1363:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1364:C:/StellarisWare/driverlib\uart.c **** //
1365:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1366:C:/StellarisWare/driverlib\uart.c **** void
1367:C:/StellarisWare/driverlib\uart.c **** UARTIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
1368:C:/StellarisWare/driverlib\uart.c **** {
 1571              		.loc 1 1368 0
 1572              		.cfi_startproc
 1573              		@ args = 0, pretend = 0, frame = 16
 1574              		@ frame_needed = 1, uses_anonymous_args = 0
 1575 0000 80B5     		push	{r7, lr}
 1576              	.LCFI93:
 1577              		.cfi_def_cfa_offset 8
 1578              		.cfi_offset 14, -4
 1579              		.cfi_offset 7, -8
 1580 0002 84B0     		sub	sp, sp, #16
 1581              	.LCFI94:
 1582              		.cfi_def_cfa_offset 24
 1583 0004 00AF     		add	r7, sp, #0
 1584              	.LCFI95:
 1585              		.cfi_def_cfa_register 7
 1586 0006 7860     		str	r0, [r7, #4]
 1587 0008 3960     		str	r1, [r7, #0]
1369:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulInt;
1370:C:/StellarisWare/driverlib\uart.c **** 
1371:C:/StellarisWare/driverlib\uart.c ****     //
1372:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1373:C:/StellarisWare/driverlib\uart.c ****     //
1374:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1375:C:/StellarisWare/driverlib\uart.c **** 
1376:C:/StellarisWare/driverlib\uart.c ****     //
1377:C:/StellarisWare/driverlib\uart.c ****     // Determine the interrupt number based on the UART port.
1378:C:/StellarisWare/driverlib\uart.c ****     //
1379:C:/StellarisWare/driverlib\uart.c ****     ulInt = UARTIntNumberGet(ulBase);
 1588              		.loc 1 1379 0
 1589 000a 7868     		ldr	r0, [r7, #4]
 1590 000c FFF7FEFF 		bl	UARTIntNumberGet
 1591 0010 0346     		mov	r3, r0
 1592 0012 FB60     		str	r3, [r7, #12]
1380:C:/StellarisWare/driverlib\uart.c **** 
1381:C:/StellarisWare/driverlib\uart.c ****     //
1382:C:/StellarisWare/driverlib\uart.c ****     // Register the interrupt handler.
1383:C:/StellarisWare/driverlib\uart.c ****     //
1384:C:/StellarisWare/driverlib\uart.c ****     IntRegister(ulInt, pfnHandler);
 1593              		.loc 1 1384 0
 1594 0014 F868     		ldr	r0, [r7, #12]
 1595 0016 3968     		ldr	r1, [r7, #0]
 1596 0018 FFF7FEFF 		bl	IntRegister
1385:C:/StellarisWare/driverlib\uart.c **** 
1386:C:/StellarisWare/driverlib\uart.c ****     //
1387:C:/StellarisWare/driverlib\uart.c ****     // Enable the UART interrupt.
1388:C:/StellarisWare/driverlib\uart.c ****     //
1389:C:/StellarisWare/driverlib\uart.c ****     IntEnable(ulInt);
 1597              		.loc 1 1389 0
 1598 001c F868     		ldr	r0, [r7, #12]
 1599 001e FFF7FEFF 		bl	IntEnable
1390:C:/StellarisWare/driverlib\uart.c **** }
 1600              		.loc 1 1390 0
 1601 0022 07F11007 		add	r7, r7, #16
 1602 0026 BD46     		mov	sp, r7
 1603 0028 80BD     		pop	{r7, pc}
 1604              		.cfi_endproc
 1605              	.LFE31:
 1607 002a 00BF     		.section	.text.UARTIntUnregister,"ax",%progbits
 1608              		.align	2
 1609              		.global	UARTIntUnregister
 1610              		.thumb
 1611              		.thumb_func
 1613              	UARTIntUnregister:
 1614              	.LFB32:
1391:C:/StellarisWare/driverlib\uart.c **** 
1392:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1393:C:/StellarisWare/driverlib\uart.c **** //
1394:C:/StellarisWare/driverlib\uart.c **** //! Unregisters an interrupt handler for a UART interrupt.
1395:C:/StellarisWare/driverlib\uart.c **** //!
1396:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1397:C:/StellarisWare/driverlib\uart.c **** //!
1398:C:/StellarisWare/driverlib\uart.c **** //! This function does the actual unregistering of the interrupt handler.  It
1399:C:/StellarisWare/driverlib\uart.c **** //! clears the handler to be called when a UART interrupt occurs.  This
1400:C:/StellarisWare/driverlib\uart.c **** //! function also masks off the interrupt in the interrupt controller so that
1401:C:/StellarisWare/driverlib\uart.c **** //! the interrupt handler no longer is called.
1402:C:/StellarisWare/driverlib\uart.c **** //!
1403:C:/StellarisWare/driverlib\uart.c **** //! \sa IntRegister() for important information about registering interrupt
1404:C:/StellarisWare/driverlib\uart.c **** //! handlers.
1405:C:/StellarisWare/driverlib\uart.c **** //!
1406:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1407:C:/StellarisWare/driverlib\uart.c **** //
1408:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1409:C:/StellarisWare/driverlib\uart.c **** void
1410:C:/StellarisWare/driverlib\uart.c **** UARTIntUnregister(unsigned long ulBase)
1411:C:/StellarisWare/driverlib\uart.c **** {
 1615              		.loc 1 1411 0
 1616              		.cfi_startproc
 1617              		@ args = 0, pretend = 0, frame = 16
 1618              		@ frame_needed = 1, uses_anonymous_args = 0
 1619 0000 80B5     		push	{r7, lr}
 1620              	.LCFI96:
 1621              		.cfi_def_cfa_offset 8
 1622              		.cfi_offset 14, -4
 1623              		.cfi_offset 7, -8
 1624 0002 84B0     		sub	sp, sp, #16
 1625              	.LCFI97:
 1626              		.cfi_def_cfa_offset 24
 1627 0004 00AF     		add	r7, sp, #0
 1628              	.LCFI98:
 1629              		.cfi_def_cfa_register 7
 1630 0006 7860     		str	r0, [r7, #4]
1412:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulInt;
1413:C:/StellarisWare/driverlib\uart.c **** 
1414:C:/StellarisWare/driverlib\uart.c ****     //
1415:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1416:C:/StellarisWare/driverlib\uart.c ****     //
1417:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1418:C:/StellarisWare/driverlib\uart.c **** 
1419:C:/StellarisWare/driverlib\uart.c ****     //
1420:C:/StellarisWare/driverlib\uart.c ****     // Determine the interrupt number based on the UART port.
1421:C:/StellarisWare/driverlib\uart.c ****     //
1422:C:/StellarisWare/driverlib\uart.c ****     ulInt = UARTIntNumberGet(ulBase);
 1631              		.loc 1 1422 0
 1632 0008 7868     		ldr	r0, [r7, #4]
 1633 000a FFF7FEFF 		bl	UARTIntNumberGet
 1634 000e 0346     		mov	r3, r0
 1635 0010 FB60     		str	r3, [r7, #12]
1423:C:/StellarisWare/driverlib\uart.c **** 
1424:C:/StellarisWare/driverlib\uart.c ****     //
1425:C:/StellarisWare/driverlib\uart.c ****     // Disable the interrupt.
1426:C:/StellarisWare/driverlib\uart.c ****     //
1427:C:/StellarisWare/driverlib\uart.c ****     IntDisable(ulInt);
 1636              		.loc 1 1427 0
 1637 0012 F868     		ldr	r0, [r7, #12]
 1638 0014 FFF7FEFF 		bl	IntDisable
1428:C:/StellarisWare/driverlib\uart.c **** 
1429:C:/StellarisWare/driverlib\uart.c ****     //
1430:C:/StellarisWare/driverlib\uart.c ****     // Unregister the interrupt handler.
1431:C:/StellarisWare/driverlib\uart.c ****     //
1432:C:/StellarisWare/driverlib\uart.c ****     IntUnregister(ulInt);
 1639              		.loc 1 1432 0
 1640 0018 F868     		ldr	r0, [r7, #12]
 1641 001a FFF7FEFF 		bl	IntUnregister
1433:C:/StellarisWare/driverlib\uart.c **** }
 1642              		.loc 1 1433 0
 1643 001e 07F11007 		add	r7, r7, #16
 1644 0022 BD46     		mov	sp, r7
 1645 0024 80BD     		pop	{r7, pc}
 1646              		.cfi_endproc
 1647              	.LFE32:
 1649 0026 00BF     		.section	.text.UARTIntEnable,"ax",%progbits
 1650              		.align	2
 1651              		.global	UARTIntEnable
 1652              		.thumb
 1653              		.thumb_func
 1655              	UARTIntEnable:
 1656              	.LFB33:
1434:C:/StellarisWare/driverlib\uart.c **** 
1435:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1436:C:/StellarisWare/driverlib\uart.c **** //
1437:C:/StellarisWare/driverlib\uart.c **** //! Enables individual UART interrupt sources.
1438:C:/StellarisWare/driverlib\uart.c **** //!
1439:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1440:C:/StellarisWare/driverlib\uart.c **** //! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
1441:C:/StellarisWare/driverlib\uart.c **** //!
1442:C:/StellarisWare/driverlib\uart.c **** //! This function enables the indicated UART interrupt sources.  Only the
1443:C:/StellarisWare/driverlib\uart.c **** //! sources that are enabled can be reflected to the processor interrupt;
1444:C:/StellarisWare/driverlib\uart.c **** //! disabled sources have no effect on the processor.
1445:C:/StellarisWare/driverlib\uart.c **** //!
1446:C:/StellarisWare/driverlib\uart.c **** //! The \e ulIntFlags parameter is the logical OR of any of the following:
1447:C:/StellarisWare/driverlib\uart.c **** //!
1448:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_9BIT - 9-bit Address Match interrupt
1449:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_OE - Overrun Error interrupt
1450:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_BE - Break Error interrupt
1451:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_PE - Parity Error interrupt
1452:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_FE - Framing Error interrupt
1453:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_RT - Receive Timeout interrupt
1454:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_TX - Transmit interrupt
1455:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_RX - Receive interrupt
1456:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_DSR - DSR interrupt
1457:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_DCD - DCD interrupt
1458:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_CTS - CTS interrupt
1459:C:/StellarisWare/driverlib\uart.c **** //! - \b UART_INT_RI - RI interrupt
1460:C:/StellarisWare/driverlib\uart.c **** //!
1461:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1462:C:/StellarisWare/driverlib\uart.c **** //
1463:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1464:C:/StellarisWare/driverlib\uart.c **** void
1465:C:/StellarisWare/driverlib\uart.c **** UARTIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
1466:C:/StellarisWare/driverlib\uart.c **** {
 1657              		.loc 1 1466 0
 1658              		.cfi_startproc
 1659              		@ args = 0, pretend = 0, frame = 8
 1660              		@ frame_needed = 1, uses_anonymous_args = 0
 1661              		@ link register save eliminated.
 1662 0000 80B4     		push	{r7}
 1663              	.LCFI99:
 1664              		.cfi_def_cfa_offset 4
 1665              		.cfi_offset 7, -4
 1666 0002 83B0     		sub	sp, sp, #12
 1667              	.LCFI100:
 1668              		.cfi_def_cfa_offset 16
 1669 0004 00AF     		add	r7, sp, #0
 1670              	.LCFI101:
 1671              		.cfi_def_cfa_register 7
 1672 0006 7860     		str	r0, [r7, #4]
 1673 0008 3960     		str	r1, [r7, #0]
1467:C:/StellarisWare/driverlib\uart.c ****     //
1468:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1469:C:/StellarisWare/driverlib\uart.c ****     //
1470:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1471:C:/StellarisWare/driverlib\uart.c **** 
1472:C:/StellarisWare/driverlib\uart.c ****     //
1473:C:/StellarisWare/driverlib\uart.c ****     // Enable the specified interrupts.
1474:C:/StellarisWare/driverlib\uart.c ****     //
1475:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_IM) |= ulIntFlags;
 1674              		.loc 1 1475 0
 1675 000a 7B68     		ldr	r3, [r7, #4]
 1676 000c 03F13803 		add	r3, r3, #56
 1677 0010 7A68     		ldr	r2, [r7, #4]
 1678 0012 02F13802 		add	r2, r2, #56
 1679 0016 1168     		ldr	r1, [r2, #0]
 1680 0018 3A68     		ldr	r2, [r7, #0]
 1681 001a 0A43     		orrs	r2, r2, r1
 1682 001c 1A60     		str	r2, [r3, #0]
1476:C:/StellarisWare/driverlib\uart.c **** }
 1683              		.loc 1 1476 0
 1684 001e 07F10C07 		add	r7, r7, #12
 1685 0022 BD46     		mov	sp, r7
 1686 0024 80BC     		pop	{r7}
 1687 0026 7047     		bx	lr
 1688              		.cfi_endproc
 1689              	.LFE33:
 1691              		.section	.text.UARTIntDisable,"ax",%progbits
 1692              		.align	2
 1693              		.global	UARTIntDisable
 1694              		.thumb
 1695              		.thumb_func
 1697              	UARTIntDisable:
 1698              	.LFB34:
1477:C:/StellarisWare/driverlib\uart.c **** 
1478:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1479:C:/StellarisWare/driverlib\uart.c **** //
1480:C:/StellarisWare/driverlib\uart.c **** //! Disables individual UART interrupt sources.
1481:C:/StellarisWare/driverlib\uart.c **** //!
1482:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1483:C:/StellarisWare/driverlib\uart.c **** //! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
1484:C:/StellarisWare/driverlib\uart.c **** //!
1485:C:/StellarisWare/driverlib\uart.c **** //! This function disables the indicated UART interrupt sources.  Only the
1486:C:/StellarisWare/driverlib\uart.c **** //! sources that are enabled can be reflected to the processor interrupt;
1487:C:/StellarisWare/driverlib\uart.c **** //! disabled sources have no effect on the processor.
1488:C:/StellarisWare/driverlib\uart.c **** //!
1489:C:/StellarisWare/driverlib\uart.c **** //! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
1490:C:/StellarisWare/driverlib\uart.c **** //! parameter to UARTIntEnable().
1491:C:/StellarisWare/driverlib\uart.c **** //!
1492:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1493:C:/StellarisWare/driverlib\uart.c **** //
1494:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1495:C:/StellarisWare/driverlib\uart.c **** void
1496:C:/StellarisWare/driverlib\uart.c **** UARTIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
1497:C:/StellarisWare/driverlib\uart.c **** {
 1699              		.loc 1 1497 0
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 8
 1702              		@ frame_needed = 1, uses_anonymous_args = 0
 1703              		@ link register save eliminated.
 1704 0000 80B4     		push	{r7}
 1705              	.LCFI102:
 1706              		.cfi_def_cfa_offset 4
 1707              		.cfi_offset 7, -4
 1708 0002 83B0     		sub	sp, sp, #12
 1709              	.LCFI103:
 1710              		.cfi_def_cfa_offset 16
 1711 0004 00AF     		add	r7, sp, #0
 1712              	.LCFI104:
 1713              		.cfi_def_cfa_register 7
 1714 0006 7860     		str	r0, [r7, #4]
 1715 0008 3960     		str	r1, [r7, #0]
1498:C:/StellarisWare/driverlib\uart.c ****     //
1499:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1500:C:/StellarisWare/driverlib\uart.c ****     //
1501:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1502:C:/StellarisWare/driverlib\uart.c **** 
1503:C:/StellarisWare/driverlib\uart.c ****     //
1504:C:/StellarisWare/driverlib\uart.c ****     // Disable the specified interrupts.
1505:C:/StellarisWare/driverlib\uart.c ****     //
1506:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_IM) &= ~(ulIntFlags);
 1716              		.loc 1 1506 0
 1717 000a 7B68     		ldr	r3, [r7, #4]
 1718 000c 03F13803 		add	r3, r3, #56
 1719 0010 7A68     		ldr	r2, [r7, #4]
 1720 0012 02F13802 		add	r2, r2, #56
 1721 0016 1168     		ldr	r1, [r2, #0]
 1722 0018 3A68     		ldr	r2, [r7, #0]
 1723 001a 6FEA0202 		mvn	r2, r2
 1724 001e 0A40     		ands	r2, r2, r1
 1725 0020 1A60     		str	r2, [r3, #0]
1507:C:/StellarisWare/driverlib\uart.c **** }
 1726              		.loc 1 1507 0
 1727 0022 07F10C07 		add	r7, r7, #12
 1728 0026 BD46     		mov	sp, r7
 1729 0028 80BC     		pop	{r7}
 1730 002a 7047     		bx	lr
 1731              		.cfi_endproc
 1732              	.LFE34:
 1734              		.section	.text.UARTIntStatus,"ax",%progbits
 1735              		.align	2
 1736              		.global	UARTIntStatus
 1737              		.thumb
 1738              		.thumb_func
 1740              	UARTIntStatus:
 1741              	.LFB35:
1508:C:/StellarisWare/driverlib\uart.c **** 
1509:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1510:C:/StellarisWare/driverlib\uart.c **** //
1511:C:/StellarisWare/driverlib\uart.c **** //! Gets the current interrupt status.
1512:C:/StellarisWare/driverlib\uart.c **** //!
1513:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1514:C:/StellarisWare/driverlib\uart.c **** //! \param bMasked is \b false if the raw interrupt status is required and
1515:C:/StellarisWare/driverlib\uart.c **** //! \b true if the masked interrupt status is required.
1516:C:/StellarisWare/driverlib\uart.c **** //!
1517:C:/StellarisWare/driverlib\uart.c **** //! This function returns the interrupt status for the specified UART.  Either
1518:C:/StellarisWare/driverlib\uart.c **** //! the raw interrupt status or the status of interrupts that are allowed to
1519:C:/StellarisWare/driverlib\uart.c **** //! reflect to the processor can be returned.
1520:C:/StellarisWare/driverlib\uart.c **** //!
1521:C:/StellarisWare/driverlib\uart.c **** //! \return Returns the current interrupt status, enumerated as a bit field of
1522:C:/StellarisWare/driverlib\uart.c **** //! values described in UARTIntEnable().
1523:C:/StellarisWare/driverlib\uart.c **** //
1524:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1525:C:/StellarisWare/driverlib\uart.c **** unsigned long
1526:C:/StellarisWare/driverlib\uart.c **** UARTIntStatus(unsigned long ulBase, tBoolean bMasked)
1527:C:/StellarisWare/driverlib\uart.c **** {
 1742              		.loc 1 1527 0
 1743              		.cfi_startproc
 1744              		@ args = 0, pretend = 0, frame = 8
 1745              		@ frame_needed = 1, uses_anonymous_args = 0
 1746              		@ link register save eliminated.
 1747 0000 80B4     		push	{r7}
 1748              	.LCFI105:
 1749              		.cfi_def_cfa_offset 4
 1750              		.cfi_offset 7, -4
 1751 0002 83B0     		sub	sp, sp, #12
 1752              	.LCFI106:
 1753              		.cfi_def_cfa_offset 16
 1754 0004 00AF     		add	r7, sp, #0
 1755              	.LCFI107:
 1756              		.cfi_def_cfa_register 7
 1757 0006 7860     		str	r0, [r7, #4]
 1758 0008 0B46     		mov	r3, r1
 1759 000a FB70     		strb	r3, [r7, #3]
1528:C:/StellarisWare/driverlib\uart.c ****     //
1529:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1530:C:/StellarisWare/driverlib\uart.c ****     //
1531:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1532:C:/StellarisWare/driverlib\uart.c **** 
1533:C:/StellarisWare/driverlib\uart.c ****     //
1534:C:/StellarisWare/driverlib\uart.c ****     // Return either the interrupt status or the raw interrupt status as
1535:C:/StellarisWare/driverlib\uart.c ****     // requested.
1536:C:/StellarisWare/driverlib\uart.c ****     //
1537:C:/StellarisWare/driverlib\uart.c ****     if(bMasked)
 1760              		.loc 1 1537 0
 1761 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1762 000e 002B     		cmp	r3, #0
 1763 0010 04D0     		beq	.L55
1538:C:/StellarisWare/driverlib\uart.c ****     {
1539:C:/StellarisWare/driverlib\uart.c ****         return(HWREG(ulBase + UART_O_MIS));
 1764              		.loc 1 1539 0
 1765 0012 7B68     		ldr	r3, [r7, #4]
 1766 0014 03F14003 		add	r3, r3, #64
 1767 0018 1B68     		ldr	r3, [r3, #0]
 1768 001a 03E0     		b	.L56
 1769              	.L55:
1540:C:/StellarisWare/driverlib\uart.c ****     }
1541:C:/StellarisWare/driverlib\uart.c ****     else
1542:C:/StellarisWare/driverlib\uart.c ****     {
1543:C:/StellarisWare/driverlib\uart.c ****         return(HWREG(ulBase + UART_O_RIS));
 1770              		.loc 1 1543 0
 1771 001c 7B68     		ldr	r3, [r7, #4]
 1772 001e 03F13C03 		add	r3, r3, #60
 1773 0022 1B68     		ldr	r3, [r3, #0]
 1774              	.L56:
1544:C:/StellarisWare/driverlib\uart.c ****     }
1545:C:/StellarisWare/driverlib\uart.c **** }
 1775              		.loc 1 1545 0
 1776 0024 1846     		mov	r0, r3
 1777 0026 07F10C07 		add	r7, r7, #12
 1778 002a BD46     		mov	sp, r7
 1779 002c 80BC     		pop	{r7}
 1780 002e 7047     		bx	lr
 1781              		.cfi_endproc
 1782              	.LFE35:
 1784              		.section	.text.UARTIntClear,"ax",%progbits
 1785              		.align	2
 1786              		.global	UARTIntClear
 1787              		.thumb
 1788              		.thumb_func
 1790              	UARTIntClear:
 1791              	.LFB36:
1546:C:/StellarisWare/driverlib\uart.c **** 
1547:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1548:C:/StellarisWare/driverlib\uart.c **** //
1549:C:/StellarisWare/driverlib\uart.c **** //! Clears UART interrupt sources.
1550:C:/StellarisWare/driverlib\uart.c **** //!
1551:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1552:C:/StellarisWare/driverlib\uart.c **** //! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
1553:C:/StellarisWare/driverlib\uart.c **** //!
1554:C:/StellarisWare/driverlib\uart.c **** //! The specified UART interrupt sources are cleared, so that they no longer
1555:C:/StellarisWare/driverlib\uart.c **** //! assert.  This function must be called in the interrupt handler to keep the
1556:C:/StellarisWare/driverlib\uart.c **** //! interrupt from being triggered again immediately upon exit.
1557:C:/StellarisWare/driverlib\uart.c **** //!
1558:C:/StellarisWare/driverlib\uart.c **** //! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
1559:C:/StellarisWare/driverlib\uart.c **** //! parameter to UARTIntEnable().
1560:C:/StellarisWare/driverlib\uart.c **** //!
1561:C:/StellarisWare/driverlib\uart.c **** //! \note Because there is a write buffer in the Cortex-M processor, it may
1562:C:/StellarisWare/driverlib\uart.c **** //! take several clock cycles before the interrupt source is actually cleared.
1563:C:/StellarisWare/driverlib\uart.c **** //! Therefore, it is recommended that the interrupt source be cleared early in
1564:C:/StellarisWare/driverlib\uart.c **** //! the interrupt handler (as opposed to the very last action) to avoid
1565:C:/StellarisWare/driverlib\uart.c **** //! returning from the interrupt handler before the interrupt source is
1566:C:/StellarisWare/driverlib\uart.c **** //! actually cleared.  Failure to do so may result in the interrupt handler
1567:C:/StellarisWare/driverlib\uart.c **** //! being immediately reentered (because the interrupt controller still sees
1568:C:/StellarisWare/driverlib\uart.c **** //! the interrupt source asserted).
1569:C:/StellarisWare/driverlib\uart.c **** //!
1570:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1571:C:/StellarisWare/driverlib\uart.c **** //
1572:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1573:C:/StellarisWare/driverlib\uart.c **** void
1574:C:/StellarisWare/driverlib\uart.c **** UARTIntClear(unsigned long ulBase, unsigned long ulIntFlags)
1575:C:/StellarisWare/driverlib\uart.c **** {
 1792              		.loc 1 1575 0
 1793              		.cfi_startproc
 1794              		@ args = 0, pretend = 0, frame = 8
 1795              		@ frame_needed = 1, uses_anonymous_args = 0
 1796              		@ link register save eliminated.
 1797 0000 80B4     		push	{r7}
 1798              	.LCFI108:
 1799              		.cfi_def_cfa_offset 4
 1800              		.cfi_offset 7, -4
 1801 0002 83B0     		sub	sp, sp, #12
 1802              	.LCFI109:
 1803              		.cfi_def_cfa_offset 16
 1804 0004 00AF     		add	r7, sp, #0
 1805              	.LCFI110:
 1806              		.cfi_def_cfa_register 7
 1807 0006 7860     		str	r0, [r7, #4]
 1808 0008 3960     		str	r1, [r7, #0]
1576:C:/StellarisWare/driverlib\uart.c ****     //
1577:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1578:C:/StellarisWare/driverlib\uart.c ****     //
1579:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1580:C:/StellarisWare/driverlib\uart.c **** 
1581:C:/StellarisWare/driverlib\uart.c ****     //
1582:C:/StellarisWare/driverlib\uart.c ****     // Clear the requested interrupt sources.
1583:C:/StellarisWare/driverlib\uart.c ****     //
1584:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_ICR) = ulIntFlags;
 1809              		.loc 1 1584 0
 1810 000a 7B68     		ldr	r3, [r7, #4]
 1811 000c 03F14403 		add	r3, r3, #68
 1812 0010 3A68     		ldr	r2, [r7, #0]
 1813 0012 1A60     		str	r2, [r3, #0]
1585:C:/StellarisWare/driverlib\uart.c **** }
 1814              		.loc 1 1585 0
 1815 0014 07F10C07 		add	r7, r7, #12
 1816 0018 BD46     		mov	sp, r7
 1817 001a 80BC     		pop	{r7}
 1818 001c 7047     		bx	lr
 1819              		.cfi_endproc
 1820              	.LFE36:
 1822 001e 00BF     		.section	.text.UARTDMAEnable,"ax",%progbits
 1823              		.align	2
 1824              		.global	UARTDMAEnable
 1825              		.thumb
 1826              		.thumb_func
 1828              	UARTDMAEnable:
 1829              	.LFB37:
1586:C:/StellarisWare/driverlib\uart.c **** 
1587:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1588:C:/StellarisWare/driverlib\uart.c **** //
1589:C:/StellarisWare/driverlib\uart.c **** //! Enable UART DMA operation.
1590:C:/StellarisWare/driverlib\uart.c **** //!
1591:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1592:C:/StellarisWare/driverlib\uart.c **** //! \param ulDMAFlags is a bit mask of the DMA features to enable.
1593:C:/StellarisWare/driverlib\uart.c **** //!
1594:C:/StellarisWare/driverlib\uart.c **** //! The specified UART DMA features are enabled.  The UART can be
1595:C:/StellarisWare/driverlib\uart.c **** //! configured to use DMA for transmit or receive and to disable
1596:C:/StellarisWare/driverlib\uart.c **** //! receive if an error occurs.  The \e ulDMAFlags parameter is the
1597:C:/StellarisWare/driverlib\uart.c **** //! logical OR of any of the following values:
1598:C:/StellarisWare/driverlib\uart.c **** //!
1599:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_RX - enable DMA for receive
1600:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_TX - enable DMA for transmit
1601:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_ERR_RXSTOP - disable DMA receive on UART error
1602:C:/StellarisWare/driverlib\uart.c **** //!
1603:C:/StellarisWare/driverlib\uart.c **** //! \note The uDMA controller must also be set up before DMA can be used
1604:C:/StellarisWare/driverlib\uart.c **** //! with the UART.
1605:C:/StellarisWare/driverlib\uart.c **** //!
1606:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1607:C:/StellarisWare/driverlib\uart.c **** //
1608:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1609:C:/StellarisWare/driverlib\uart.c **** void
1610:C:/StellarisWare/driverlib\uart.c **** UARTDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags)
1611:C:/StellarisWare/driverlib\uart.c **** {
 1830              		.loc 1 1611 0
 1831              		.cfi_startproc
 1832              		@ args = 0, pretend = 0, frame = 8
 1833              		@ frame_needed = 1, uses_anonymous_args = 0
 1834              		@ link register save eliminated.
 1835 0000 80B4     		push	{r7}
 1836              	.LCFI111:
 1837              		.cfi_def_cfa_offset 4
 1838              		.cfi_offset 7, -4
 1839 0002 83B0     		sub	sp, sp, #12
 1840              	.LCFI112:
 1841              		.cfi_def_cfa_offset 16
 1842 0004 00AF     		add	r7, sp, #0
 1843              	.LCFI113:
 1844              		.cfi_def_cfa_register 7
 1845 0006 7860     		str	r0, [r7, #4]
 1846 0008 3960     		str	r1, [r7, #0]
1612:C:/StellarisWare/driverlib\uart.c ****     //
1613:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1614:C:/StellarisWare/driverlib\uart.c ****     //
1615:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1616:C:/StellarisWare/driverlib\uart.c **** 
1617:C:/StellarisWare/driverlib\uart.c ****     //
1618:C:/StellarisWare/driverlib\uart.c ****     // Set the requested bits in the UART DMA control register.
1619:C:/StellarisWare/driverlib\uart.c ****     //
1620:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_DMACTL) |= ulDMAFlags;
 1847              		.loc 1 1620 0
 1848 000a 7B68     		ldr	r3, [r7, #4]
 1849 000c 03F14803 		add	r3, r3, #72
 1850 0010 7A68     		ldr	r2, [r7, #4]
 1851 0012 02F14802 		add	r2, r2, #72
 1852 0016 1168     		ldr	r1, [r2, #0]
 1853 0018 3A68     		ldr	r2, [r7, #0]
 1854 001a 0A43     		orrs	r2, r2, r1
 1855 001c 1A60     		str	r2, [r3, #0]
1621:C:/StellarisWare/driverlib\uart.c **** }
 1856              		.loc 1 1621 0
 1857 001e 07F10C07 		add	r7, r7, #12
 1858 0022 BD46     		mov	sp, r7
 1859 0024 80BC     		pop	{r7}
 1860 0026 7047     		bx	lr
 1861              		.cfi_endproc
 1862              	.LFE37:
 1864              		.section	.text.UARTDMADisable,"ax",%progbits
 1865              		.align	2
 1866              		.global	UARTDMADisable
 1867              		.thumb
 1868              		.thumb_func
 1870              	UARTDMADisable:
 1871              	.LFB38:
1622:C:/StellarisWare/driverlib\uart.c **** 
1623:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1624:C:/StellarisWare/driverlib\uart.c **** //
1625:C:/StellarisWare/driverlib\uart.c **** //! Disable UART DMA operation.
1626:C:/StellarisWare/driverlib\uart.c **** //!
1627:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1628:C:/StellarisWare/driverlib\uart.c **** //! \param ulDMAFlags is a bit mask of the DMA features to disable.
1629:C:/StellarisWare/driverlib\uart.c **** //!
1630:C:/StellarisWare/driverlib\uart.c **** //! This function is used to disable UART DMA features that were enabled
1631:C:/StellarisWare/driverlib\uart.c **** //! by UARTDMAEnable().  The specified UART DMA features are disabled.  The
1632:C:/StellarisWare/driverlib\uart.c **** //! \e ulDMAFlags parameter is the logical OR of any of the following values:
1633:C:/StellarisWare/driverlib\uart.c **** //!
1634:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_RX - disable DMA for receive
1635:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_TX - disable DMA for transmit
1636:C:/StellarisWare/driverlib\uart.c **** //! - UART_DMA_ERR_RXSTOP - do not disable DMA receive on UART error
1637:C:/StellarisWare/driverlib\uart.c **** //!
1638:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1639:C:/StellarisWare/driverlib\uart.c **** //
1640:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1641:C:/StellarisWare/driverlib\uart.c **** void
1642:C:/StellarisWare/driverlib\uart.c **** UARTDMADisable(unsigned long ulBase, unsigned long ulDMAFlags)
1643:C:/StellarisWare/driverlib\uart.c **** {
 1872              		.loc 1 1643 0
 1873              		.cfi_startproc
 1874              		@ args = 0, pretend = 0, frame = 8
 1875              		@ frame_needed = 1, uses_anonymous_args = 0
 1876              		@ link register save eliminated.
 1877 0000 80B4     		push	{r7}
 1878              	.LCFI114:
 1879              		.cfi_def_cfa_offset 4
 1880              		.cfi_offset 7, -4
 1881 0002 83B0     		sub	sp, sp, #12
 1882              	.LCFI115:
 1883              		.cfi_def_cfa_offset 16
 1884 0004 00AF     		add	r7, sp, #0
 1885              	.LCFI116:
 1886              		.cfi_def_cfa_register 7
 1887 0006 7860     		str	r0, [r7, #4]
 1888 0008 3960     		str	r1, [r7, #0]
1644:C:/StellarisWare/driverlib\uart.c ****     //
1645:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1646:C:/StellarisWare/driverlib\uart.c ****     //
1647:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1648:C:/StellarisWare/driverlib\uart.c **** 
1649:C:/StellarisWare/driverlib\uart.c ****     //
1650:C:/StellarisWare/driverlib\uart.c ****     // Clear the requested bits in the UART DMA control register.
1651:C:/StellarisWare/driverlib\uart.c ****     //
1652:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_DMACTL) &= ~ulDMAFlags;
 1889              		.loc 1 1652 0
 1890 000a 7B68     		ldr	r3, [r7, #4]
 1891 000c 03F14803 		add	r3, r3, #72
 1892 0010 7A68     		ldr	r2, [r7, #4]
 1893 0012 02F14802 		add	r2, r2, #72
 1894 0016 1168     		ldr	r1, [r2, #0]
 1895 0018 3A68     		ldr	r2, [r7, #0]
 1896 001a 6FEA0202 		mvn	r2, r2
 1897 001e 0A40     		ands	r2, r2, r1
 1898 0020 1A60     		str	r2, [r3, #0]
1653:C:/StellarisWare/driverlib\uart.c **** }
 1899              		.loc 1 1653 0
 1900 0022 07F10C07 		add	r7, r7, #12
 1901 0026 BD46     		mov	sp, r7
 1902 0028 80BC     		pop	{r7}
 1903 002a 7047     		bx	lr
 1904              		.cfi_endproc
 1905              	.LFE38:
 1907              		.section	.text.UARTRxErrorGet,"ax",%progbits
 1908              		.align	2
 1909              		.global	UARTRxErrorGet
 1910              		.thumb
 1911              		.thumb_func
 1913              	UARTRxErrorGet:
 1914              	.LFB39:
1654:C:/StellarisWare/driverlib\uart.c **** 
1655:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1656:C:/StellarisWare/driverlib\uart.c **** //
1657:C:/StellarisWare/driverlib\uart.c **** //! Gets current receiver errors.
1658:C:/StellarisWare/driverlib\uart.c **** //!
1659:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1660:C:/StellarisWare/driverlib\uart.c **** //!
1661:C:/StellarisWare/driverlib\uart.c **** //! This function returns the current state of each of the 4 receiver error
1662:C:/StellarisWare/driverlib\uart.c **** //! sources.  The returned errors are equivalent to the four error bits
1663:C:/StellarisWare/driverlib\uart.c **** //! returned via the previous call to UARTCharGet() or UARTCharGetNonBlocking()
1664:C:/StellarisWare/driverlib\uart.c **** //! with the exception that the overrun error is set immediately when the
1665:C:/StellarisWare/driverlib\uart.c **** //! overrun occurs rather than when a character is next read.
1666:C:/StellarisWare/driverlib\uart.c **** //!
1667:C:/StellarisWare/driverlib\uart.c **** //! \return Returns a logical OR combination of the receiver error flags,
1668:C:/StellarisWare/driverlib\uart.c **** //! \b UART_RXERROR_FRAMING, \b UART_RXERROR_PARITY, \b UART_RXERROR_BREAK
1669:C:/StellarisWare/driverlib\uart.c **** //! and \b UART_RXERROR_OVERRUN.
1670:C:/StellarisWare/driverlib\uart.c **** //
1671:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1672:C:/StellarisWare/driverlib\uart.c **** unsigned long
1673:C:/StellarisWare/driverlib\uart.c **** UARTRxErrorGet(unsigned long ulBase)
1674:C:/StellarisWare/driverlib\uart.c **** {
 1915              		.loc 1 1674 0
 1916              		.cfi_startproc
 1917              		@ args = 0, pretend = 0, frame = 8
 1918              		@ frame_needed = 1, uses_anonymous_args = 0
 1919              		@ link register save eliminated.
 1920 0000 80B4     		push	{r7}
 1921              	.LCFI117:
 1922              		.cfi_def_cfa_offset 4
 1923              		.cfi_offset 7, -4
 1924 0002 83B0     		sub	sp, sp, #12
 1925              	.LCFI118:
 1926              		.cfi_def_cfa_offset 16
 1927 0004 00AF     		add	r7, sp, #0
 1928              	.LCFI119:
 1929              		.cfi_def_cfa_register 7
 1930 0006 7860     		str	r0, [r7, #4]
1675:C:/StellarisWare/driverlib\uart.c ****     //
1676:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1677:C:/StellarisWare/driverlib\uart.c ****     //
1678:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1679:C:/StellarisWare/driverlib\uart.c **** 
1680:C:/StellarisWare/driverlib\uart.c ****     //
1681:C:/StellarisWare/driverlib\uart.c ****     // Return the current value of the receive status register.
1682:C:/StellarisWare/driverlib\uart.c ****     //
1683:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_RSR) & 0x0000000F);
 1931              		.loc 1 1683 0
 1932 0008 7B68     		ldr	r3, [r7, #4]
 1933 000a 03F10403 		add	r3, r3, #4
 1934 000e 1B68     		ldr	r3, [r3, #0]
 1935 0010 03F00F03 		and	r3, r3, #15
1684:C:/StellarisWare/driverlib\uart.c **** }
 1936              		.loc 1 1684 0
 1937 0014 1846     		mov	r0, r3
 1938 0016 07F10C07 		add	r7, r7, #12
 1939 001a BD46     		mov	sp, r7
 1940 001c 80BC     		pop	{r7}
 1941 001e 7047     		bx	lr
 1942              		.cfi_endproc
 1943              	.LFE39:
 1945              		.section	.text.UARTRxErrorClear,"ax",%progbits
 1946              		.align	2
 1947              		.global	UARTRxErrorClear
 1948              		.thumb
 1949              		.thumb_func
 1951              	UARTRxErrorClear:
 1952              	.LFB40:
1685:C:/StellarisWare/driverlib\uart.c **** 
1686:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1687:C:/StellarisWare/driverlib\uart.c **** //
1688:C:/StellarisWare/driverlib\uart.c **** //! Clears all reported receiver errors.
1689:C:/StellarisWare/driverlib\uart.c **** //!
1690:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1691:C:/StellarisWare/driverlib\uart.c **** //!
1692:C:/StellarisWare/driverlib\uart.c **** //! This function is used to clear all receiver error conditions reported via
1693:C:/StellarisWare/driverlib\uart.c **** //! UARTRxErrorGet().  If using the overrun, framing error, parity error or
1694:C:/StellarisWare/driverlib\uart.c **** //! break interrupts, this function must be called after clearing the interrupt
1695:C:/StellarisWare/driverlib\uart.c **** //! to ensure that later errors of the same type trigger another interrupt.
1696:C:/StellarisWare/driverlib\uart.c **** //!
1697:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1698:C:/StellarisWare/driverlib\uart.c **** //
1699:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1700:C:/StellarisWare/driverlib\uart.c **** void
1701:C:/StellarisWare/driverlib\uart.c **** UARTRxErrorClear(unsigned long ulBase)
1702:C:/StellarisWare/driverlib\uart.c **** {
 1953              		.loc 1 1702 0
 1954              		.cfi_startproc
 1955              		@ args = 0, pretend = 0, frame = 8
 1956              		@ frame_needed = 1, uses_anonymous_args = 0
 1957              		@ link register save eliminated.
 1958 0000 80B4     		push	{r7}
 1959              	.LCFI120:
 1960              		.cfi_def_cfa_offset 4
 1961              		.cfi_offset 7, -4
 1962 0002 83B0     		sub	sp, sp, #12
 1963              	.LCFI121:
 1964              		.cfi_def_cfa_offset 16
 1965 0004 00AF     		add	r7, sp, #0
 1966              	.LCFI122:
 1967              		.cfi_def_cfa_register 7
 1968 0006 7860     		str	r0, [r7, #4]
1703:C:/StellarisWare/driverlib\uart.c ****     //
1704:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1705:C:/StellarisWare/driverlib\uart.c ****     //
1706:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1707:C:/StellarisWare/driverlib\uart.c **** 
1708:C:/StellarisWare/driverlib\uart.c ****     //
1709:C:/StellarisWare/driverlib\uart.c ****     // Any write to the Error Clear Register clears all bits which are
1710:C:/StellarisWare/driverlib\uart.c ****     // currently set.
1711:C:/StellarisWare/driverlib\uart.c ****     //
1712:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_ECR) = 0;
 1969              		.loc 1 1712 0
 1970 0008 7B68     		ldr	r3, [r7, #4]
 1971 000a 03F10403 		add	r3, r3, #4
 1972 000e 4FF00002 		mov	r2, #0
 1973 0012 1A60     		str	r2, [r3, #0]
1713:C:/StellarisWare/driverlib\uart.c **** }
 1974              		.loc 1 1713 0
 1975 0014 07F10C07 		add	r7, r7, #12
 1976 0018 BD46     		mov	sp, r7
 1977 001a 80BC     		pop	{r7}
 1978 001c 7047     		bx	lr
 1979              		.cfi_endproc
 1980              	.LFE40:
 1982 001e 00BF     		.section	.text.UARTClockSourceSet,"ax",%progbits
 1983              		.align	2
 1984              		.global	UARTClockSourceSet
 1985              		.thumb
 1986              		.thumb_func
 1988              	UARTClockSourceSet:
 1989              	.LFB41:
1714:C:/StellarisWare/driverlib\uart.c **** 
1715:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1716:C:/StellarisWare/driverlib\uart.c **** //
1717:C:/StellarisWare/driverlib\uart.c **** //! Sets the baud clock source for the specified UART.
1718:C:/StellarisWare/driverlib\uart.c **** //!
1719:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1720:C:/StellarisWare/driverlib\uart.c **** //! \param ulSource is the baud clock source for the UART.
1721:C:/StellarisWare/driverlib\uart.c **** //!
1722:C:/StellarisWare/driverlib\uart.c **** //! This function allows the baud clock source for the UART to be selected.
1723:C:/StellarisWare/driverlib\uart.c **** //! The possible clock source are the system clock (\b UART_CLOCK_SYSTEM) or
1724:C:/StellarisWare/driverlib\uart.c **** //! the precision internal oscillator (\b UART_CLOCK_PIOSC).
1725:C:/StellarisWare/driverlib\uart.c **** //!
1726:C:/StellarisWare/driverlib\uart.c **** //! Changing the baud clock source changes the baud rate generated by the
1727:C:/StellarisWare/driverlib\uart.c **** //! UART.  Therefore, the baud rate should be reconfigured after any change to
1728:C:/StellarisWare/driverlib\uart.c **** //! the baud clock source.
1729:C:/StellarisWare/driverlib\uart.c **** //!
1730:C:/StellarisWare/driverlib\uart.c **** //! \note The ability to specify the UART baud clock source varies with the
1731:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
1732:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
1733:C:/StellarisWare/driverlib\uart.c **** //!
1734:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1735:C:/StellarisWare/driverlib\uart.c **** //
1736:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1737:C:/StellarisWare/driverlib\uart.c **** void
1738:C:/StellarisWare/driverlib\uart.c **** UARTClockSourceSet(unsigned long ulBase, unsigned long ulSource)
1739:C:/StellarisWare/driverlib\uart.c **** {
 1990              		.loc 1 1739 0
 1991              		.cfi_startproc
 1992              		@ args = 0, pretend = 0, frame = 8
 1993              		@ frame_needed = 1, uses_anonymous_args = 0
 1994              		@ link register save eliminated.
 1995 0000 80B4     		push	{r7}
 1996              	.LCFI123:
 1997              		.cfi_def_cfa_offset 4
 1998              		.cfi_offset 7, -4
 1999 0002 83B0     		sub	sp, sp, #12
 2000              	.LCFI124:
 2001              		.cfi_def_cfa_offset 16
 2002 0004 00AF     		add	r7, sp, #0
 2003              	.LCFI125:
 2004              		.cfi_def_cfa_register 7
 2005 0006 7860     		str	r0, [r7, #4]
 2006 0008 3960     		str	r1, [r7, #0]
1740:C:/StellarisWare/driverlib\uart.c ****     //
1741:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1742:C:/StellarisWare/driverlib\uart.c ****     //
1743:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1744:C:/StellarisWare/driverlib\uart.c ****     ASSERT((ulSource == UART_CLOCK_SYSTEM) || (ulSource == UART_CLOCK_PIOSC));
1745:C:/StellarisWare/driverlib\uart.c **** 
1746:C:/StellarisWare/driverlib\uart.c ****     //
1747:C:/StellarisWare/driverlib\uart.c ****     // Set the UART clock source.
1748:C:/StellarisWare/driverlib\uart.c ****     //
1749:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_CC) = ulSource;
 2007              		.loc 1 1749 0
 2008 000a 7B68     		ldr	r3, [r7, #4]
 2009 000c 03F57C63 		add	r3, r3, #4032
 2010 0010 03F10803 		add	r3, r3, #8
 2011 0014 3A68     		ldr	r2, [r7, #0]
 2012 0016 1A60     		str	r2, [r3, #0]
1750:C:/StellarisWare/driverlib\uart.c **** }
 2013              		.loc 1 1750 0
 2014 0018 07F10C07 		add	r7, r7, #12
 2015 001c BD46     		mov	sp, r7
 2016 001e 80BC     		pop	{r7}
 2017 0020 7047     		bx	lr
 2018              		.cfi_endproc
 2019              	.LFE41:
 2021 0022 00BF     		.section	.text.UARTClockSourceGet,"ax",%progbits
 2022              		.align	2
 2023              		.global	UARTClockSourceGet
 2024              		.thumb
 2025              		.thumb_func
 2027              	UARTClockSourceGet:
 2028              	.LFB42:
1751:C:/StellarisWare/driverlib\uart.c **** 
1752:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1753:C:/StellarisWare/driverlib\uart.c **** //
1754:C:/StellarisWare/driverlib\uart.c **** //! Gets the baud clock source for the specified UART.
1755:C:/StellarisWare/driverlib\uart.c **** //!
1756:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1757:C:/StellarisWare/driverlib\uart.c **** //!
1758:C:/StellarisWare/driverlib\uart.c **** //! This function returns the baud clock source for the specified UART.  The
1759:C:/StellarisWare/driverlib\uart.c **** //! possible baud clock source are the system clock (\b UART_CLOCK_SYSTEM) or
1760:C:/StellarisWare/driverlib\uart.c **** //! the precision internal oscillator (\b UART_CLOCK_PIOSC).
1761:C:/StellarisWare/driverlib\uart.c **** //!
1762:C:/StellarisWare/driverlib\uart.c **** //! \note The ability to specify the UART baud clock source varies with the
1763:C:/StellarisWare/driverlib\uart.c **** //! Stellaris part in use.  Please consult the datasheet for the part you are
1764:C:/StellarisWare/driverlib\uart.c **** //! using to determine whether this support is available.
1765:C:/StellarisWare/driverlib\uart.c **** //!
1766:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1767:C:/StellarisWare/driverlib\uart.c **** //
1768:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1769:C:/StellarisWare/driverlib\uart.c **** unsigned long
1770:C:/StellarisWare/driverlib\uart.c **** UARTClockSourceGet(unsigned long ulBase)
1771:C:/StellarisWare/driverlib\uart.c **** {
 2029              		.loc 1 1771 0
 2030              		.cfi_startproc
 2031              		@ args = 0, pretend = 0, frame = 8
 2032              		@ frame_needed = 1, uses_anonymous_args = 0
 2033              		@ link register save eliminated.
 2034 0000 80B4     		push	{r7}
 2035              	.LCFI126:
 2036              		.cfi_def_cfa_offset 4
 2037              		.cfi_offset 7, -4
 2038 0002 83B0     		sub	sp, sp, #12
 2039              	.LCFI127:
 2040              		.cfi_def_cfa_offset 16
 2041 0004 00AF     		add	r7, sp, #0
 2042              	.LCFI128:
 2043              		.cfi_def_cfa_register 7
 2044 0006 7860     		str	r0, [r7, #4]
1772:C:/StellarisWare/driverlib\uart.c ****     //
1773:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1774:C:/StellarisWare/driverlib\uart.c ****     //
1775:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1776:C:/StellarisWare/driverlib\uart.c **** 
1777:C:/StellarisWare/driverlib\uart.c ****     //
1778:C:/StellarisWare/driverlib\uart.c ****     // Return the UART clock source.
1779:C:/StellarisWare/driverlib\uart.c ****     //
1780:C:/StellarisWare/driverlib\uart.c ****     return(HWREG(ulBase + UART_O_CC));
 2045              		.loc 1 1780 0
 2046 0008 7B68     		ldr	r3, [r7, #4]
 2047 000a 03F57C63 		add	r3, r3, #4032
 2048 000e 03F10803 		add	r3, r3, #8
 2049 0012 1B68     		ldr	r3, [r3, #0]
1781:C:/StellarisWare/driverlib\uart.c **** }
 2050              		.loc 1 1781 0
 2051 0014 1846     		mov	r0, r3
 2052 0016 07F10C07 		add	r7, r7, #12
 2053 001a BD46     		mov	sp, r7
 2054 001c 80BC     		pop	{r7}
 2055 001e 7047     		bx	lr
 2056              		.cfi_endproc
 2057              	.LFE42:
 2059              		.section	.text.UART9BitEnable,"ax",%progbits
 2060              		.align	2
 2061              		.global	UART9BitEnable
 2062              		.thumb
 2063              		.thumb_func
 2065              	UART9BitEnable:
 2066              	.LFB43:
1782:C:/StellarisWare/driverlib\uart.c **** 
1783:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1784:C:/StellarisWare/driverlib\uart.c **** //
1785:C:/StellarisWare/driverlib\uart.c **** //! Enables 9-bit mode on the specified UART.
1786:C:/StellarisWare/driverlib\uart.c **** //!
1787:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1788:C:/StellarisWare/driverlib\uart.c **** //!
1789:C:/StellarisWare/driverlib\uart.c **** //! This function enables the 9-bit operational mode of the UART.
1790:C:/StellarisWare/driverlib\uart.c **** //!
1791:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of 9-bit mode varies with the Stellaris part in use.
1792:C:/StellarisWare/driverlib\uart.c **** //! Please consult the datasheet for the part you are using to determine
1793:C:/StellarisWare/driverlib\uart.c **** //! whether this support is available.
1794:C:/StellarisWare/driverlib\uart.c **** //!
1795:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1796:C:/StellarisWare/driverlib\uart.c **** //
1797:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1798:C:/StellarisWare/driverlib\uart.c **** void
1799:C:/StellarisWare/driverlib\uart.c **** UART9BitEnable(unsigned long ulBase)
1800:C:/StellarisWare/driverlib\uart.c **** {
 2067              		.loc 1 1800 0
 2068              		.cfi_startproc
 2069              		@ args = 0, pretend = 0, frame = 8
 2070              		@ frame_needed = 1, uses_anonymous_args = 0
 2071              		@ link register save eliminated.
 2072 0000 80B4     		push	{r7}
 2073              	.LCFI129:
 2074              		.cfi_def_cfa_offset 4
 2075              		.cfi_offset 7, -4
 2076 0002 83B0     		sub	sp, sp, #12
 2077              	.LCFI130:
 2078              		.cfi_def_cfa_offset 16
 2079 0004 00AF     		add	r7, sp, #0
 2080              	.LCFI131:
 2081              		.cfi_def_cfa_register 7
 2082 0006 7860     		str	r0, [r7, #4]
1801:C:/StellarisWare/driverlib\uart.c ****     //
1802:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1803:C:/StellarisWare/driverlib\uart.c ****     //
1804:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1805:C:/StellarisWare/driverlib\uart.c **** 
1806:C:/StellarisWare/driverlib\uart.c ****     //
1807:C:/StellarisWare/driverlib\uart.c ****     // Enable 9-bit mode.
1808:C:/StellarisWare/driverlib\uart.c ****     //
1809:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_9BITADDR) |= UART_9BITADDR_9BITEN;
 2083              		.loc 1 1809 0
 2084 0008 7B68     		ldr	r3, [r7, #4]
 2085 000a 03F1A403 		add	r3, r3, #164
 2086 000e 7A68     		ldr	r2, [r7, #4]
 2087 0010 02F1A402 		add	r2, r2, #164
 2088 0014 1268     		ldr	r2, [r2, #0]
 2089 0016 42F40042 		orr	r2, r2, #32768
 2090 001a 1A60     		str	r2, [r3, #0]
1810:C:/StellarisWare/driverlib\uart.c **** }
 2091              		.loc 1 1810 0
 2092 001c 07F10C07 		add	r7, r7, #12
 2093 0020 BD46     		mov	sp, r7
 2094 0022 80BC     		pop	{r7}
 2095 0024 7047     		bx	lr
 2096              		.cfi_endproc
 2097              	.LFE43:
 2099 0026 00BF     		.section	.text.UART9BitDisable,"ax",%progbits
 2100              		.align	2
 2101              		.global	UART9BitDisable
 2102              		.thumb
 2103              		.thumb_func
 2105              	UART9BitDisable:
 2106              	.LFB44:
1811:C:/StellarisWare/driverlib\uart.c **** 
1812:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1813:C:/StellarisWare/driverlib\uart.c **** //
1814:C:/StellarisWare/driverlib\uart.c **** //! Disables 9-bit mode on the specified UART.
1815:C:/StellarisWare/driverlib\uart.c **** //!
1816:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1817:C:/StellarisWare/driverlib\uart.c **** //!
1818:C:/StellarisWare/driverlib\uart.c **** //! This function disables the 9-bit operational mode of the UART.
1819:C:/StellarisWare/driverlib\uart.c **** //!
1820:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of 9-bit mode varies with the Stellaris part in use.
1821:C:/StellarisWare/driverlib\uart.c **** //! Please consult the datasheet for the part you are using to determine
1822:C:/StellarisWare/driverlib\uart.c **** //! whether this support is available.
1823:C:/StellarisWare/driverlib\uart.c **** //!
1824:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1825:C:/StellarisWare/driverlib\uart.c **** //
1826:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1827:C:/StellarisWare/driverlib\uart.c **** void
1828:C:/StellarisWare/driverlib\uart.c **** UART9BitDisable(unsigned long ulBase)
1829:C:/StellarisWare/driverlib\uart.c **** {
 2107              		.loc 1 1829 0
 2108              		.cfi_startproc
 2109              		@ args = 0, pretend = 0, frame = 8
 2110              		@ frame_needed = 1, uses_anonymous_args = 0
 2111              		@ link register save eliminated.
 2112 0000 80B4     		push	{r7}
 2113              	.LCFI132:
 2114              		.cfi_def_cfa_offset 4
 2115              		.cfi_offset 7, -4
 2116 0002 83B0     		sub	sp, sp, #12
 2117              	.LCFI133:
 2118              		.cfi_def_cfa_offset 16
 2119 0004 00AF     		add	r7, sp, #0
 2120              	.LCFI134:
 2121              		.cfi_def_cfa_register 7
 2122 0006 7860     		str	r0, [r7, #4]
1830:C:/StellarisWare/driverlib\uart.c ****     //
1831:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1832:C:/StellarisWare/driverlib\uart.c ****     //
1833:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1834:C:/StellarisWare/driverlib\uart.c **** 
1835:C:/StellarisWare/driverlib\uart.c ****     //
1836:C:/StellarisWare/driverlib\uart.c ****     // Disable 9-bit mode.
1837:C:/StellarisWare/driverlib\uart.c ****     //
1838:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_9BITADDR) &= ~UART_9BITADDR_9BITEN;
 2123              		.loc 1 1838 0
 2124 0008 7B68     		ldr	r3, [r7, #4]
 2125 000a 03F1A403 		add	r3, r3, #164
 2126 000e 7A68     		ldr	r2, [r7, #4]
 2127 0010 02F1A402 		add	r2, r2, #164
 2128 0014 1268     		ldr	r2, [r2, #0]
 2129 0016 22F40042 		bic	r2, r2, #32768
 2130 001a 1A60     		str	r2, [r3, #0]
1839:C:/StellarisWare/driverlib\uart.c **** }
 2131              		.loc 1 1839 0
 2132 001c 07F10C07 		add	r7, r7, #12
 2133 0020 BD46     		mov	sp, r7
 2134 0022 80BC     		pop	{r7}
 2135 0024 7047     		bx	lr
 2136              		.cfi_endproc
 2137              	.LFE44:
 2139 0026 00BF     		.section	.text.UART9BitAddrSet,"ax",%progbits
 2140              		.align	2
 2141              		.global	UART9BitAddrSet
 2142              		.thumb
 2143              		.thumb_func
 2145              	UART9BitAddrSet:
 2146              	.LFB45:
1840:C:/StellarisWare/driverlib\uart.c **** 
1841:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1842:C:/StellarisWare/driverlib\uart.c **** //
1843:C:/StellarisWare/driverlib\uart.c **** //! Sets the device address(es) for 9-bit mode.
1844:C:/StellarisWare/driverlib\uart.c **** //!
1845:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1846:C:/StellarisWare/driverlib\uart.c **** //! \param ucAddr is the device address.
1847:C:/StellarisWare/driverlib\uart.c **** //! \param ucMask is the device address mask.
1848:C:/StellarisWare/driverlib\uart.c **** //!
1849:C:/StellarisWare/driverlib\uart.c **** //! This function configures the device address or range of device addresses
1850:C:/StellarisWare/driverlib\uart.c **** //! that respond to requests on the 9-bit UART port.  The received address is
1851:C:/StellarisWare/driverlib\uart.c **** //! masked with the mask and then compared against the given address, allowing
1852:C:/StellarisWare/driverlib\uart.c **** //! either a single address (if \b ucMask is 0xff) or a set of addresses to be
1853:C:/StellarisWare/driverlib\uart.c **** //! matched.
1854:C:/StellarisWare/driverlib\uart.c **** //!
1855:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of 9-bit mode varies with the Stellaris part in use.
1856:C:/StellarisWare/driverlib\uart.c **** //! Please consult the datasheet for the part you are using to determine
1857:C:/StellarisWare/driverlib\uart.c **** //! whether this support is available.
1858:C:/StellarisWare/driverlib\uart.c **** //!
1859:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1860:C:/StellarisWare/driverlib\uart.c **** //
1861:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1862:C:/StellarisWare/driverlib\uart.c **** void
1863:C:/StellarisWare/driverlib\uart.c **** UART9BitAddrSet(unsigned long ulBase, unsigned char ucAddr,
1864:C:/StellarisWare/driverlib\uart.c ****                 unsigned char ucMask)
1865:C:/StellarisWare/driverlib\uart.c **** {
 2147              		.loc 1 1865 0
 2148              		.cfi_startproc
 2149              		@ args = 0, pretend = 0, frame = 8
 2150              		@ frame_needed = 1, uses_anonymous_args = 0
 2151              		@ link register save eliminated.
 2152 0000 80B4     		push	{r7}
 2153              	.LCFI135:
 2154              		.cfi_def_cfa_offset 4
 2155              		.cfi_offset 7, -4
 2156 0002 83B0     		sub	sp, sp, #12
 2157              	.LCFI136:
 2158              		.cfi_def_cfa_offset 16
 2159 0004 00AF     		add	r7, sp, #0
 2160              	.LCFI137:
 2161              		.cfi_def_cfa_register 7
 2162 0006 7860     		str	r0, [r7, #4]
 2163 0008 1346     		mov	r3, r2
 2164 000a 0A46     		mov	r2, r1
 2165 000c FA70     		strb	r2, [r7, #3]
 2166 000e BB70     		strb	r3, [r7, #2]
1866:C:/StellarisWare/driverlib\uart.c ****     //
1867:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1868:C:/StellarisWare/driverlib\uart.c ****     //
1869:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1870:C:/StellarisWare/driverlib\uart.c **** 
1871:C:/StellarisWare/driverlib\uart.c ****     //
1872:C:/StellarisWare/driverlib\uart.c ****     // Set the address and mask.
1873:C:/StellarisWare/driverlib\uart.c ****     //
1874:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_9BITADDR) = ucAddr << UART_9BITADDR_ADDR_S;
 2167              		.loc 1 1874 0
 2168 0010 7B68     		ldr	r3, [r7, #4]
 2169 0012 03F1A403 		add	r3, r3, #164
 2170 0016 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 2171 0018 1A60     		str	r2, [r3, #0]
1875:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_9BITAMASK) = ucMask << UART_9BITAMASK_MASK_S;
 2172              		.loc 1 1875 0
 2173 001a 7B68     		ldr	r3, [r7, #4]
 2174 001c 03F1A803 		add	r3, r3, #168
 2175 0020 BA78     		ldrb	r2, [r7, #2]	@ zero_extendqisi2
 2176 0022 1A60     		str	r2, [r3, #0]
1876:C:/StellarisWare/driverlib\uart.c **** }
 2177              		.loc 1 1876 0
 2178 0024 07F10C07 		add	r7, r7, #12
 2179 0028 BD46     		mov	sp, r7
 2180 002a 80BC     		pop	{r7}
 2181 002c 7047     		bx	lr
 2182              		.cfi_endproc
 2183              	.LFE45:
 2185 002e 00BF     		.section	.text.UART9BitAddrSend,"ax",%progbits
 2186              		.align	2
 2187              		.global	UART9BitAddrSend
 2188              		.thumb
 2189              		.thumb_func
 2191              	UART9BitAddrSend:
 2192              	.LFB46:
1877:C:/StellarisWare/driverlib\uart.c **** 
1878:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1879:C:/StellarisWare/driverlib\uart.c **** //
1880:C:/StellarisWare/driverlib\uart.c **** //! Sends an address character from the specified port when operating in 9-bit
1881:C:/StellarisWare/driverlib\uart.c **** //! mode.
1882:C:/StellarisWare/driverlib\uart.c **** //!
1883:C:/StellarisWare/driverlib\uart.c **** //! \param ulBase is the base address of the UART port.
1884:C:/StellarisWare/driverlib\uart.c **** //! \param ucAddr is the address to be transmitted.
1885:C:/StellarisWare/driverlib\uart.c **** //!
1886:C:/StellarisWare/driverlib\uart.c **** //! This function waits until all data has been sent from the specified port
1887:C:/StellarisWare/driverlib\uart.c **** //! and then sends the given address as an address byte.  It then waits until
1888:C:/StellarisWare/driverlib\uart.c **** //! the address byte has been transmitted before returning.
1889:C:/StellarisWare/driverlib\uart.c **** //!
1890:C:/StellarisWare/driverlib\uart.c **** //! The normal data functions (UARTCharPut(), UARTCharPutNonBlocking(),
1891:C:/StellarisWare/driverlib\uart.c **** //! UARTCharGet(), and UARTCharGetNonBlocking()) are used to send and receive
1892:C:/StellarisWare/driverlib\uart.c **** //! data characters in 9-bit mode.
1893:C:/StellarisWare/driverlib\uart.c **** //!
1894:C:/StellarisWare/driverlib\uart.c **** //! \note The availability of 9-bit mode varies with the Stellaris part in use.
1895:C:/StellarisWare/driverlib\uart.c **** //! Please consult the datasheet for the part you are using to determine
1896:C:/StellarisWare/driverlib\uart.c **** //! whether this support is available.
1897:C:/StellarisWare/driverlib\uart.c **** //!
1898:C:/StellarisWare/driverlib\uart.c **** //! \return None.
1899:C:/StellarisWare/driverlib\uart.c **** //
1900:C:/StellarisWare/driverlib\uart.c **** //*****************************************************************************
1901:C:/StellarisWare/driverlib\uart.c **** void
1902:C:/StellarisWare/driverlib\uart.c **** UART9BitAddrSend(unsigned long ulBase, unsigned char ucAddr)
1903:C:/StellarisWare/driverlib\uart.c **** {
 2193              		.loc 1 1903 0
 2194              		.cfi_startproc
 2195              		@ args = 0, pretend = 0, frame = 16
 2196              		@ frame_needed = 1, uses_anonymous_args = 0
 2197              		@ link register save eliminated.
 2198 0000 80B4     		push	{r7}
 2199              	.LCFI138:
 2200              		.cfi_def_cfa_offset 4
 2201              		.cfi_offset 7, -4
 2202 0002 85B0     		sub	sp, sp, #20
 2203              	.LCFI139:
 2204              		.cfi_def_cfa_offset 24
 2205 0004 00AF     		add	r7, sp, #0
 2206              	.LCFI140:
 2207              		.cfi_def_cfa_register 7
 2208 0006 7860     		str	r0, [r7, #4]
 2209 0008 0B46     		mov	r3, r1
 2210 000a FB70     		strb	r3, [r7, #3]
1904:C:/StellarisWare/driverlib\uart.c ****     unsigned long ulLCRH;
1905:C:/StellarisWare/driverlib\uart.c **** 
1906:C:/StellarisWare/driverlib\uart.c ****     //
1907:C:/StellarisWare/driverlib\uart.c ****     // Check the arguments.
1908:C:/StellarisWare/driverlib\uart.c ****     //
1909:C:/StellarisWare/driverlib\uart.c ****     ASSERT(UARTBaseValid(ulBase));
1910:C:/StellarisWare/driverlib\uart.c **** 
1911:C:/StellarisWare/driverlib\uart.c ****     //
1912:C:/StellarisWare/driverlib\uart.c ****     // Wait until the FIFO is empty and the UART is not busy.
1913:C:/StellarisWare/driverlib\uart.c ****     //
1914:C:/StellarisWare/driverlib\uart.c ****     while(HWREG(ulBase + UART_O_FR) & (UART_FR_TXFE | UART_FR_BUSY))
 2211              		.loc 1 1914 0
 2212 000c 00BF     		nop
 2213              	.L68:
 2214              		.loc 1 1914 0 is_stmt 0 discriminator 1
 2215 000e 7B68     		ldr	r3, [r7, #4]
 2216 0010 03F11803 		add	r3, r3, #24
 2217 0014 1B68     		ldr	r3, [r3, #0]
 2218 0016 03F08803 		and	r3, r3, #136
 2219 001a 002B     		cmp	r3, #0
 2220 001c F7D1     		bne	.L68
1915:C:/StellarisWare/driverlib\uart.c ****     {
1916:C:/StellarisWare/driverlib\uart.c ****     }
1917:C:/StellarisWare/driverlib\uart.c **** 
1918:C:/StellarisWare/driverlib\uart.c ****     //
1919:C:/StellarisWare/driverlib\uart.c ****     // Force the address/data bit to 1 to indicate this is an address byte.
1920:C:/StellarisWare/driverlib\uart.c ****     //
1921:C:/StellarisWare/driverlib\uart.c ****     ulLCRH = HWREG(ulBase + UART_O_LCRH);
 2221              		.loc 1 1921 0 is_stmt 1
 2222 001e 7B68     		ldr	r3, [r7, #4]
 2223 0020 03F12C03 		add	r3, r3, #44
 2224 0024 1B68     		ldr	r3, [r3, #0]
 2225 0026 FB60     		str	r3, [r7, #12]
1922:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ((ulLCRH & ~UART_LCRH_EPS) | UART_LCRH_SPS |
 2226              		.loc 1 1922 0
 2227 0028 7B68     		ldr	r3, [r7, #4]
 2228 002a 03F12C03 		add	r3, r3, #44
 2229 002e FA68     		ldr	r2, [r7, #12]
 2230 0030 22F08602 		bic	r2, r2, #134
 2231 0034 42F08202 		orr	r2, r2, #130
 2232 0038 1A60     		str	r2, [r3, #0]
1923:C:/StellarisWare/driverlib\uart.c ****                                    UART_LCRH_PEN);
1924:C:/StellarisWare/driverlib\uart.c **** 
1925:C:/StellarisWare/driverlib\uart.c ****     //
1926:C:/StellarisWare/driverlib\uart.c ****     // Send the address.
1927:C:/StellarisWare/driverlib\uart.c ****     //
1928:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_DR) = ucAddr;
 2233              		.loc 1 1928 0
 2234 003a 7B68     		ldr	r3, [r7, #4]
 2235 003c FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 2236 003e 1A60     		str	r2, [r3, #0]
1929:C:/StellarisWare/driverlib\uart.c **** 
1930:C:/StellarisWare/driverlib\uart.c ****     //
1931:C:/StellarisWare/driverlib\uart.c ****     // Wait until the address has been sent.
1932:C:/StellarisWare/driverlib\uart.c ****     //
1933:C:/StellarisWare/driverlib\uart.c ****     while(HWREG(ulBase + UART_O_FR) & (UART_FR_TXFE | UART_FR_BUSY))
 2237              		.loc 1 1933 0
 2238 0040 00BF     		nop
 2239              	.L69:
 2240              		.loc 1 1933 0 is_stmt 0 discriminator 1
 2241 0042 7B68     		ldr	r3, [r7, #4]
 2242 0044 03F11803 		add	r3, r3, #24
 2243 0048 1B68     		ldr	r3, [r3, #0]
 2244 004a 03F08803 		and	r3, r3, #136
 2245 004e 002B     		cmp	r3, #0
 2246 0050 F7D1     		bne	.L69
1934:C:/StellarisWare/driverlib\uart.c ****     {
1935:C:/StellarisWare/driverlib\uart.c ****     }
1936:C:/StellarisWare/driverlib\uart.c **** 
1937:C:/StellarisWare/driverlib\uart.c ****     //
1938:C:/StellarisWare/driverlib\uart.c ****     // Restore the address/data setting.
1939:C:/StellarisWare/driverlib\uart.c ****     //
1940:C:/StellarisWare/driverlib\uart.c ****     HWREG(ulBase + UART_O_LCRH) = ulLCRH;
 2247              		.loc 1 1940 0 is_stmt 1
 2248 0052 7B68     		ldr	r3, [r7, #4]
 2249 0054 03F12C03 		add	r3, r3, #44
 2250 0058 FA68     		ldr	r2, [r7, #12]
 2251 005a 1A60     		str	r2, [r3, #0]
1941:C:/StellarisWare/driverlib\uart.c **** }
 2252              		.loc 1 1941 0
 2253 005c 07F11407 		add	r7, r7, #20
 2254 0060 BD46     		mov	sp, r7
 2255 0062 80BC     		pop	{r7}
 2256 0064 7047     		bx	lr
 2257              		.cfi_endproc
 2258              	.LFE46:
 2260 0066 00BF     		.text
 2261              	.Letext0:
 2262              		.file 2 "C:\\StellarisWare/inc/hw_types.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:19     .rodata:00000000 $d
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:22     .rodata:00000000 g_ppulUARTIntMap
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:40     .text.UARTIntNumberGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:44     .text.UARTIntNumberGet:00000000 UARTIntNumberGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:107    .text.UARTParityModeSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:112    .text.UARTParityModeSet:00000000 UARTParityModeSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:152    .text.UARTParityModeGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:157    .text.UARTParityModeGet:00000000 UARTParityModeGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:190    .text.UARTFIFOLevelSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:195    .text.UARTFIFOLevelSet:00000000 UARTFIFOLevelSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:231    .text.UARTFIFOLevelGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:236    .text.UARTFIFOLevelGet:00000000 UARTFIFOLevelGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:280    .text.UARTConfigSetExpClk:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:285    .text.UARTConfigSetExpClk:00000000 UARTConfigSetExpClk
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:510    .text.UARTDisable:00000000 UARTDisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:460    .text.UARTEnable:00000000 UARTEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:379    .text.UARTConfigGetExpClk:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:384    .text.UARTConfigGetExpClk:00000000 UARTConfigGetExpClk
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:455    .text.UARTEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:505    .text.UARTDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:565    .text.UARTFIFOEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:570    .text.UARTFIFOEnable:00000000 UARTFIFOEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:605    .text.UARTFIFODisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:610    .text.UARTFIFODisable:00000000 UARTFIFODisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:645    .text.UARTEnableSIR:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:650    .text.UARTEnableSIR:00000000 UARTEnableSIR
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:702    .text.UARTDisableSIR:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:707    .text.UARTDisableSIR:00000000 UARTDisableSIR
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:742    .text.UARTSmartCardEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:747    .text.UARTSmartCardEnable:00000000 UARTSmartCardEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:800    .text.UARTSmartCardDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:805    .text.UARTSmartCardDisable:00000000 UARTSmartCardDisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:840    .text.UARTModemControlSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:845    .text.UARTModemControlSet:00000000 UARTModemControlSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:889    .text.UARTModemControlClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:894    .text.UARTModemControlClear:00000000 UARTModemControlClear
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:939    .text.UARTModemControlGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:944    .text.UARTModemControlGet:00000000 UARTModemControlGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:977    .text.UARTModemStatusGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:982    .text.UARTModemStatusGet:00000000 UARTModemStatusGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1016   .text.UARTFlowControlSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1021   .text.UARTFlowControlSet:00000000 UARTFlowControlSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1061   .text.UARTFlowControlGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1066   .text.UARTFlowControlGet:00000000 UARTFlowControlGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1099   .text.UARTTxIntModeSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1104   .text.UARTTxIntModeSet:00000000 UARTTxIntModeSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1144   .text.UARTTxIntModeGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1149   .text.UARTTxIntModeGet:00000000 UARTTxIntModeGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1182   .text.UARTCharsAvail:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1187   .text.UARTCharsAvail:00000000 UARTCharsAvail
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1225   .text.UARTSpaceAvail:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1230   .text.UARTSpaceAvail:00000000 UARTSpaceAvail
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1268   .text.UARTCharGetNonBlocking:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1273   .text.UARTCharGetNonBlocking:00000000 UARTCharGetNonBlocking
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1316   .text.UARTCharGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1321   .text.UARTCharGet:00000000 UARTCharGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1362   .text.UARTCharPutNonBlocking:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1367   .text.UARTCharPutNonBlocking:00000000 UARTCharPutNonBlocking
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1415   .text.UARTCharPut:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1420   .text.UARTCharPut:00000000 UARTCharPut
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1463   .text.UARTBreakCtl:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1468   .text.UARTBreakCtl:00000000 UARTBreakCtl
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1521   .text.UARTBusy:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1526   .text.UARTBusy:00000000 UARTBusy
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1564   .text.UARTIntRegister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1569   .text.UARTIntRegister:00000000 UARTIntRegister
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1608   .text.UARTIntUnregister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1613   .text.UARTIntUnregister:00000000 UARTIntUnregister
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1650   .text.UARTIntEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1655   .text.UARTIntEnable:00000000 UARTIntEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1692   .text.UARTIntDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1697   .text.UARTIntDisable:00000000 UARTIntDisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1735   .text.UARTIntStatus:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1740   .text.UARTIntStatus:00000000 UARTIntStatus
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1785   .text.UARTIntClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1790   .text.UARTIntClear:00000000 UARTIntClear
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1823   .text.UARTDMAEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1828   .text.UARTDMAEnable:00000000 UARTDMAEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1865   .text.UARTDMADisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1870   .text.UARTDMADisable:00000000 UARTDMADisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1908   .text.UARTRxErrorGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1913   .text.UARTRxErrorGet:00000000 UARTRxErrorGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1946   .text.UARTRxErrorClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1951   .text.UARTRxErrorClear:00000000 UARTRxErrorClear
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1983   .text.UARTClockSourceSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:1988   .text.UARTClockSourceSet:00000000 UARTClockSourceSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2022   .text.UARTClockSourceGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2027   .text.UARTClockSourceGet:00000000 UARTClockSourceGet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2060   .text.UART9BitEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2065   .text.UART9BitEnable:00000000 UART9BitEnable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2100   .text.UART9BitDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2105   .text.UART9BitDisable:00000000 UART9BitDisable
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2140   .text.UART9BitAddrSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2145   .text.UART9BitAddrSet:00000000 UART9BitAddrSet
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2186   .text.UART9BitAddrSend:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccEf9yRe.s:2191   .text.UART9BitAddrSend:00000000 UART9BitAddrSend
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
IntRegister
IntEnable
IntDisable
IntUnregister
