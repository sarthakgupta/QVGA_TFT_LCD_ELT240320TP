   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"pwm.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.PWMGenConfigure,"ax",%progbits
  19              		.align	2
  20              		.global	PWMGenConfigure
  21              		.thumb
  22              		.thumb_func
  24              	PWMGenConfigure:
  25              	.LFB0:
  26              		.file 1 "C:/StellarisWare/driverlib/pwm.c"
   1:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
   2:C:/StellarisWare/driverlib\pwm.c **** //
   3:C:/StellarisWare/driverlib\pwm.c **** // pwm.c - API for the PWM modules
   4:C:/StellarisWare/driverlib\pwm.c **** //
   5:C:/StellarisWare/driverlib\pwm.c **** // Copyright (c) 2005-2012 Texas Instruments Incorporated.  All rights reserved.
   6:C:/StellarisWare/driverlib\pwm.c **** // Software License Agreement
   7:C:/StellarisWare/driverlib\pwm.c **** // 
   8:C:/StellarisWare/driverlib\pwm.c **** //   Redistribution and use in source and binary forms, with or without
   9:C:/StellarisWare/driverlib\pwm.c **** //   modification, are permitted provided that the following conditions
  10:C:/StellarisWare/driverlib\pwm.c **** //   are met:
  11:C:/StellarisWare/driverlib\pwm.c **** // 
  12:C:/StellarisWare/driverlib\pwm.c **** //   Redistributions of source code must retain the above copyright
  13:C:/StellarisWare/driverlib\pwm.c **** //   notice, this list of conditions and the following disclaimer.
  14:C:/StellarisWare/driverlib\pwm.c **** // 
  15:C:/StellarisWare/driverlib\pwm.c **** //   Redistributions in binary form must reproduce the above copyright
  16:C:/StellarisWare/driverlib\pwm.c **** //   notice, this list of conditions and the following disclaimer in the
  17:C:/StellarisWare/driverlib\pwm.c **** //   documentation and/or other materials provided with the  
  18:C:/StellarisWare/driverlib\pwm.c **** //   distribution.
  19:C:/StellarisWare/driverlib\pwm.c **** // 
  20:C:/StellarisWare/driverlib\pwm.c **** //   Neither the name of Texas Instruments Incorporated nor the names of
  21:C:/StellarisWare/driverlib\pwm.c **** //   its contributors may be used to endorse or promote products derived
  22:C:/StellarisWare/driverlib\pwm.c **** //   from this software without specific prior written permission.
  23:C:/StellarisWare/driverlib\pwm.c **** // 
  24:C:/StellarisWare/driverlib\pwm.c **** // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  25:C:/StellarisWare/driverlib\pwm.c **** // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  26:C:/StellarisWare/driverlib\pwm.c **** // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  27:C:/StellarisWare/driverlib\pwm.c **** // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  28:C:/StellarisWare/driverlib\pwm.c **** // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  29:C:/StellarisWare/driverlib\pwm.c **** // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  30:C:/StellarisWare/driverlib\pwm.c **** // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  31:C:/StellarisWare/driverlib\pwm.c **** // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  32:C:/StellarisWare/driverlib\pwm.c **** // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  33:C:/StellarisWare/driverlib\pwm.c **** // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  34:C:/StellarisWare/driverlib\pwm.c **** // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:C:/StellarisWare/driverlib\pwm.c **** // 
  36:C:/StellarisWare/driverlib\pwm.c **** // This is part of revision 9107 of the Stellaris Peripheral Driver Library.
  37:C:/StellarisWare/driverlib\pwm.c **** //
  38:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  39:C:/StellarisWare/driverlib\pwm.c **** 
  40:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  41:C:/StellarisWare/driverlib\pwm.c **** //
  42:C:/StellarisWare/driverlib\pwm.c **** //! \addtogroup pwm_api
  43:C:/StellarisWare/driverlib\pwm.c **** //! @{
  44:C:/StellarisWare/driverlib\pwm.c **** //
  45:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  46:C:/StellarisWare/driverlib\pwm.c **** 
  47:C:/StellarisWare/driverlib\pwm.c **** #include "inc/hw_ints.h"
  48:C:/StellarisWare/driverlib\pwm.c **** #include "inc/hw_memmap.h"
  49:C:/StellarisWare/driverlib\pwm.c **** #include "inc/hw_pwm.h"
  50:C:/StellarisWare/driverlib\pwm.c **** #include "inc/hw_sysctl.h"
  51:C:/StellarisWare/driverlib\pwm.c **** #include "inc/hw_types.h"
  52:C:/StellarisWare/driverlib\pwm.c **** #include "driverlib/debug.h"
  53:C:/StellarisWare/driverlib\pwm.c **** #include "driverlib/interrupt.h"
  54:C:/StellarisWare/driverlib\pwm.c **** #include "driverlib/pwm.h"
  55:C:/StellarisWare/driverlib\pwm.c **** 
  56:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  57:C:/StellarisWare/driverlib\pwm.c **** //
  58:C:/StellarisWare/driverlib\pwm.c **** // Misc macros for manipulating the encoded generator and output defines used
  59:C:/StellarisWare/driverlib\pwm.c **** // by the API.
  60:C:/StellarisWare/driverlib\pwm.c **** //
  61:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  62:C:/StellarisWare/driverlib\pwm.c **** #define PWM_GEN_BADDR(_mod_, _gen_)                                           \
  63:C:/StellarisWare/driverlib\pwm.c ****                                 ((_mod_) + (_gen_))
  64:C:/StellarisWare/driverlib\pwm.c **** #define PWM_GEN_EXT_BADDR(_mod_, _gen_)                                       \
  65:C:/StellarisWare/driverlib\pwm.c ****                                 ((_mod_) + PWM_GEN_EXT_0 +                    \
  66:C:/StellarisWare/driverlib\pwm.c ****                                  ((_gen_) - PWM_GEN_0) * 2)
  67:C:/StellarisWare/driverlib\pwm.c **** #define PWM_OUT_BADDR(_mod_, _out_)                                           \
  68:C:/StellarisWare/driverlib\pwm.c ****                                 ((_mod_) + ((_out_) & 0xFFFFFFC0))
  69:C:/StellarisWare/driverlib\pwm.c **** #define PWM_IS_OUTPUT_ODD(_out_)                                              \
  70:C:/StellarisWare/driverlib\pwm.c ****                                 ((_out_) & 0x00000001)
  71:C:/StellarisWare/driverlib\pwm.c **** 
  72:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  73:C:/StellarisWare/driverlib\pwm.c **** //
  74:C:/StellarisWare/driverlib\pwm.c **** //! \internal
  75:C:/StellarisWare/driverlib\pwm.c **** //! Checks a PWM generator number.
  76:C:/StellarisWare/driverlib\pwm.c **** //!
  77:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the generator number.
  78:C:/StellarisWare/driverlib\pwm.c **** //!
  79:C:/StellarisWare/driverlib\pwm.c **** //! This function determines if a PWM generator number is valid.
  80:C:/StellarisWare/driverlib\pwm.c **** //!
  81:C:/StellarisWare/driverlib\pwm.c **** //! \return Returnes \b true if the generator number is valid and \b false
  82:C:/StellarisWare/driverlib\pwm.c **** //! otherwise.
  83:C:/StellarisWare/driverlib\pwm.c **** //
  84:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  85:C:/StellarisWare/driverlib\pwm.c **** #ifdef DEBUG
  86:C:/StellarisWare/driverlib\pwm.c **** static tBoolean
  87:C:/StellarisWare/driverlib\pwm.c **** PWMGenValid(unsigned long ulGen)
  88:C:/StellarisWare/driverlib\pwm.c **** {
  89:C:/StellarisWare/driverlib\pwm.c ****     return((ulGen == PWM_GEN_0) || (ulGen == PWM_GEN_1) ||
  90:C:/StellarisWare/driverlib\pwm.c ****            (ulGen == PWM_GEN_2) || (ulGen == PWM_GEN_3));
  91:C:/StellarisWare/driverlib\pwm.c **** }
  92:C:/StellarisWare/driverlib\pwm.c **** #endif
  93:C:/StellarisWare/driverlib\pwm.c **** 
  94:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
  95:C:/StellarisWare/driverlib\pwm.c **** //
  96:C:/StellarisWare/driverlib\pwm.c **** //! \internal
  97:C:/StellarisWare/driverlib\pwm.c **** //! Checks a PWM output number.
  98:C:/StellarisWare/driverlib\pwm.c **** //!
  99:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOut is the output number.
 100:C:/StellarisWare/driverlib\pwm.c **** //!
 101:C:/StellarisWare/driverlib\pwm.c **** //! This function determines if a PWM output number is valid.
 102:C:/StellarisWare/driverlib\pwm.c **** //!
 103:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns \b true if the output number is valid and \b false
 104:C:/StellarisWare/driverlib\pwm.c **** //! otherwise.
 105:C:/StellarisWare/driverlib\pwm.c **** //
 106:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 107:C:/StellarisWare/driverlib\pwm.c **** #ifdef DEBUG
 108:C:/StellarisWare/driverlib\pwm.c **** static tBoolean
 109:C:/StellarisWare/driverlib\pwm.c **** PWMOutValid(unsigned long ulPWMOut)
 110:C:/StellarisWare/driverlib\pwm.c **** {
 111:C:/StellarisWare/driverlib\pwm.c ****     return((ulPWMOut == PWM_OUT_0) || (ulPWMOut == PWM_OUT_1) ||
 112:C:/StellarisWare/driverlib\pwm.c ****            (ulPWMOut == PWM_OUT_2) || (ulPWMOut == PWM_OUT_3) ||
 113:C:/StellarisWare/driverlib\pwm.c ****            (ulPWMOut == PWM_OUT_4) || (ulPWMOut == PWM_OUT_5) ||
 114:C:/StellarisWare/driverlib\pwm.c ****            (ulPWMOut == PWM_OUT_6) || (ulPWMOut == PWM_OUT_7));
 115:C:/StellarisWare/driverlib\pwm.c **** }
 116:C:/StellarisWare/driverlib\pwm.c **** #endif
 117:C:/StellarisWare/driverlib\pwm.c **** 
 118:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 119:C:/StellarisWare/driverlib\pwm.c **** //
 120:C:/StellarisWare/driverlib\pwm.c **** //! Configures a PWM generator.
 121:C:/StellarisWare/driverlib\pwm.c **** //!
 122:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 123:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to configure.  This parameter must be one
 124:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 125:C:/StellarisWare/driverlib\pwm.c **** //! \param ulConfig is the configuration for the PWM generator.
 126:C:/StellarisWare/driverlib\pwm.c **** //!
 127:C:/StellarisWare/driverlib\pwm.c **** //! This function is used to set the mode of operation for a PWM generator.
 128:C:/StellarisWare/driverlib\pwm.c **** //! The counting mode, synchronization mode, and debug behavior are all
 129:C:/StellarisWare/driverlib\pwm.c **** //! configured.  After configuration, the generator is left in the disabled
 130:C:/StellarisWare/driverlib\pwm.c **** //! state.
 131:C:/StellarisWare/driverlib\pwm.c **** //!
 132:C:/StellarisWare/driverlib\pwm.c **** //! A PWM generator can count in two different modes:  count down mode or count
 133:C:/StellarisWare/driverlib\pwm.c **** //! up/down mode.  In count down mode, it counts from a value down to zero,
 134:C:/StellarisWare/driverlib\pwm.c **** //! and then resets to the preset value, producing left-aligned PWM
 135:C:/StellarisWare/driverlib\pwm.c **** //! signals (that is, the rising edge of the two PWM signals produced by the
 136:C:/StellarisWare/driverlib\pwm.c **** //! generator occur at the same time).  In count up/down mode, it counts up
 137:C:/StellarisWare/driverlib\pwm.c **** //! from zero to the preset value, counts back down to zero, and then repeats
 138:C:/StellarisWare/driverlib\pwm.c **** //! the process, producing center-aligned PWM signals (that is,
 139:C:/StellarisWare/driverlib\pwm.c **** //! the middle of the high/low period of the PWM signals produced by the
 140:C:/StellarisWare/driverlib\pwm.c **** //! generator occurs at the same time).
 141:C:/StellarisWare/driverlib\pwm.c **** //!
 142:C:/StellarisWare/driverlib\pwm.c **** //! When the PWM generator parameters (period and pulse width) are modified,
 143:C:/StellarisWare/driverlib\pwm.c **** //! their effect on the output PWM signals can be delayed.  In synchronous
 144:C:/StellarisWare/driverlib\pwm.c **** //! mode, the parameter updates are not applied until a synchronization event
 145:C:/StellarisWare/driverlib\pwm.c **** //! occurs.  This mode allows multiple parameters to be modified and take
 146:C:/StellarisWare/driverlib\pwm.c **** //! effect simultaneously, instead of one at a time.  Additionally, parameters
 147:C:/StellarisWare/driverlib\pwm.c **** //! to multiple PWM generators in synchronous mode can be updated
 148:C:/StellarisWare/driverlib\pwm.c **** //! simultaneously, allowing them to be treated as if they were a unified
 149:C:/StellarisWare/driverlib\pwm.c **** //! generator.  In non-synchronous mode, the parameter updates are not delayed
 150:C:/StellarisWare/driverlib\pwm.c **** //! until a synchronization event.  In either mode, the parameter updates only
 151:C:/StellarisWare/driverlib\pwm.c **** //! occur when the counter is at zero to help prevent oddly formed PWM signals
 152:C:/StellarisWare/driverlib\pwm.c **** //! during the update (that is, a PWM pulse that is too short or too long).
 153:C:/StellarisWare/driverlib\pwm.c **** //!
 154:C:/StellarisWare/driverlib\pwm.c **** //! The PWM generator can either pause or continue running when the processor
 155:C:/StellarisWare/driverlib\pwm.c **** //! is stopped via the debugger.  If configured to pause, it continues to
 156:C:/StellarisWare/driverlib\pwm.c **** //! count until it reaches zero, at which point it pauses until the
 157:C:/StellarisWare/driverlib\pwm.c **** //! processor is restarted.  If configured to continue running, it keeps
 158:C:/StellarisWare/driverlib\pwm.c **** //! counting as if nothing had happened.
 159:C:/StellarisWare/driverlib\pwm.c **** //!
 160:C:/StellarisWare/driverlib\pwm.c **** //! The \e ulConfig parameter contains the desired configuration.  It is the
 161:C:/StellarisWare/driverlib\pwm.c **** //! logical OR of the following:
 162:C:/StellarisWare/driverlib\pwm.c **** //!
 163:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_DOWN or \b PWM_GEN_MODE_UP_DOWN to specify the counting
 164:C:/StellarisWare/driverlib\pwm.c **** //!   mode
 165:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_SYNC or \b PWM_GEN_MODE_NO_SYNC to specify the counter
 166:C:/StellarisWare/driverlib\pwm.c **** //!   load and comparator update synchronization mode
 167:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_DBG_RUN or \b PWM_GEN_MODE_DBG_STOP to specify the debug
 168:C:/StellarisWare/driverlib\pwm.c **** //!   behavior
 169:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_GEN_NO_SYNC, \b PWM_GEN_MODE_GEN_SYNC_LOCAL, or
 170:C:/StellarisWare/driverlib\pwm.c **** //!   \b PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization
 171:C:/StellarisWare/driverlib\pwm.c **** //!   mode for generator counting mode changes
 172:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_DB_NO_SYNC, \b PWM_GEN_MODE_DB_SYNC_LOCAL, or
 173:C:/StellarisWare/driverlib\pwm.c **** //!   \b PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter
 174:C:/StellarisWare/driverlib\pwm.c **** //!   synchronization mode
 175:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_FAULT_LATCHED or \b PWM_GEN_MODE_FAULT_UNLATCHED to
 176:C:/StellarisWare/driverlib\pwm.c **** //!   specify whether fault conditions are latched or not
 177:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_FAULT_MINPER or \b PWM_GEN_MODE_FAULT_NO_MINPER to
 178:C:/StellarisWare/driverlib\pwm.c **** //!   specify whether minimum fault period support is required
 179:C:/StellarisWare/driverlib\pwm.c **** //! - \b PWM_GEN_MODE_FAULT_EXT or \b PWM_GEN_MODE_FAULT_LEGACY to specify
 180:C:/StellarisWare/driverlib\pwm.c **** //!   whether extended fault source selection support is enabled or not
 181:C:/StellarisWare/driverlib\pwm.c **** //!
 182:C:/StellarisWare/driverlib\pwm.c **** //! Setting \b PWM_GEN_MODE_FAULT_MINPER allows an application to set the
 183:C:/StellarisWare/driverlib\pwm.c **** //! minimum duration of a PWM fault signal.  Faults are signaled for at
 184:C:/StellarisWare/driverlib\pwm.c **** //! least this time even if the external fault pin deasserts earlier.  Care
 185:C:/StellarisWare/driverlib\pwm.c **** //! should be taken when using this mode because during the fault signal
 186:C:/StellarisWare/driverlib\pwm.c **** //! period, the fault interrupt from the PWM generator remains asserted.  The
 187:C:/StellarisWare/driverlib\pwm.c **** //! fault interrupt handler may, therefore, reenter immediately if it exits
 188:C:/StellarisWare/driverlib\pwm.c **** //! prior to expiration of the fault timer.
 189:C:/StellarisWare/driverlib\pwm.c **** //!
 190:C:/StellarisWare/driverlib\pwm.c **** //! \note Changes to the counter mode affect the period of the PWM signals
 191:C:/StellarisWare/driverlib\pwm.c **** //! produced.  PWMGenPeriodSet() and PWMPulseWidthSet() should be called after
 192:C:/StellarisWare/driverlib\pwm.c **** //! any changes to the counter mode of a generator.
 193:C:/StellarisWare/driverlib\pwm.c **** //!
 194:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 195:C:/StellarisWare/driverlib\pwm.c **** //
 196:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 197:C:/StellarisWare/driverlib\pwm.c **** void
 198:C:/StellarisWare/driverlib\pwm.c **** PWMGenConfigure(unsigned long ulBase, unsigned long ulGen,
 199:C:/StellarisWare/driverlib\pwm.c ****                 unsigned long ulConfig)
 200:C:/StellarisWare/driverlib\pwm.c **** {
  27              		.loc 1 200 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 80B4     		push	{r7}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 7, -4
  36 0002 85B0     		sub	sp, sp, #20
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 24
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 F860     		str	r0, [r7, #12]
  43 0008 B960     		str	r1, [r7, #8]
  44 000a 7A60     		str	r2, [r7, #4]
 201:C:/StellarisWare/driverlib\pwm.c ****     //
 202:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 203:C:/StellarisWare/driverlib\pwm.c ****     //
 204:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 205:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 206:C:/StellarisWare/driverlib\pwm.c **** 
 207:C:/StellarisWare/driverlib\pwm.c ****     //
 208:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 209:C:/StellarisWare/driverlib\pwm.c ****     //
 210:C:/StellarisWare/driverlib\pwm.c ****     ulGen = PWM_GEN_BADDR(ulBase, ulGen);
  45              		.loc 1 210 0
  46 000c BA68     		ldr	r2, [r7, #8]
  47 000e FB68     		ldr	r3, [r7, #12]
  48 0010 D318     		adds	r3, r2, r3
  49 0012 BB60     		str	r3, [r7, #8]
 211:C:/StellarisWare/driverlib\pwm.c **** 
 212:C:/StellarisWare/driverlib\pwm.c ****     //
 213:C:/StellarisWare/driverlib\pwm.c ****     // Change the global configuration of the generator.
 214:C:/StellarisWare/driverlib\pwm.c ****     //
 215:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulGen + PWM_O_X_CTL) = ((HWREG(ulGen + PWM_O_X_CTL) &
  50              		.loc 1 215 0
  51 0014 BA68     		ldr	r2, [r7, #8]
  52 0016 BB68     		ldr	r3, [r7, #8]
  53 0018 1968     		ldr	r1, [r3, #0]
  54 001a 4FF00103 		mov	r3, #1
  55 001e CFF6F873 		movt	r3, 65528
  56 0022 0B40     		ands	r3, r3, r1
 216:C:/StellarisWare/driverlib\pwm.c ****                                    ~(PWM_X_CTL_MODE | PWM_X_CTL_DEBUG |
 217:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_LATCH | PWM_X_CTL_MINFLTPER |
 218:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_FLTSRC | PWM_X_CTL_DBFALLUPD_M |
 219:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_DBRISEUPD_M |
 220:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_DBCTLUPD_M |
 221:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_GENBUPD_M |
 222:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_GENAUPD_M |
 223:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_LOADUPD | PWM_X_CTL_CMPAUPD |
 224:C:/StellarisWare/driverlib\pwm.c ****                                      PWM_X_CTL_CMPBUPD)) | ulConfig);
  57              		.loc 1 224 0
  58 0024 7968     		ldr	r1, [r7, #4]
  59 0026 0B43     		orrs	r3, r3, r1
 215:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulGen + PWM_O_X_CTL) = ((HWREG(ulGen + PWM_O_X_CTL) &
  60              		.loc 1 215 0
  61 0028 1360     		str	r3, [r2, #0]
 225:C:/StellarisWare/driverlib\pwm.c **** 
 226:C:/StellarisWare/driverlib\pwm.c ****     //
 227:C:/StellarisWare/driverlib\pwm.c ****     // Set the individual PWM generator controls.
 228:C:/StellarisWare/driverlib\pwm.c ****     //
 229:C:/StellarisWare/driverlib\pwm.c ****     if(ulConfig & PWM_X_CTL_MODE)
  62              		.loc 1 229 0
  63 002a 7B68     		ldr	r3, [r7, #4]
  64 002c 03F00203 		and	r3, r3, #2
  65 0030 002B     		cmp	r3, #0
  66 0032 0CD0     		beq	.L2
 230:C:/StellarisWare/driverlib\pwm.c ****     {
 231:C:/StellarisWare/driverlib\pwm.c ****         //
 232:C:/StellarisWare/driverlib\pwm.c ****         // In up/down count mode, set the signal high on up count comparison
 233:C:/StellarisWare/driverlib\pwm.c ****         // and low on down count comparison (that is, center align the
 234:C:/StellarisWare/driverlib\pwm.c ****         // signals).
 235:C:/StellarisWare/driverlib\pwm.c ****         //
 236:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTCMPAU_ONE |
  67              		.loc 1 236 0
  68 0034 BB68     		ldr	r3, [r7, #8]
  69 0036 03F12003 		add	r3, r3, #32
  70 003a 4FF0B002 		mov	r2, #176
  71 003e 1A60     		str	r2, [r3, #0]
 237:C:/StellarisWare/driverlib\pwm.c ****                                        PWM_X_GENA_ACTCMPAD_ZERO);
 238:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTCMPBU_ONE |
  72              		.loc 1 238 0
  73 0040 BB68     		ldr	r3, [r7, #8]
  74 0042 03F12403 		add	r3, r3, #36
  75 0046 4FF43062 		mov	r2, #2816
  76 004a 1A60     		str	r2, [r3, #0]
  77 004c 0BE0     		b	.L1
  78              	.L2:
 239:C:/StellarisWare/driverlib\pwm.c ****                                        PWM_X_GENB_ACTCMPBD_ZERO);
 240:C:/StellarisWare/driverlib\pwm.c ****     }
 241:C:/StellarisWare/driverlib\pwm.c ****     else
 242:C:/StellarisWare/driverlib\pwm.c ****     {
 243:C:/StellarisWare/driverlib\pwm.c ****         //
 244:C:/StellarisWare/driverlib\pwm.c ****         // In down count mode, set the signal high on load and low on count
 245:C:/StellarisWare/driverlib\pwm.c ****         // comparison (that is, left align the signals).
 246:C:/StellarisWare/driverlib\pwm.c ****         //
 247:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTLOAD_ONE |
  79              		.loc 1 247 0
  80 004e BB68     		ldr	r3, [r7, #8]
  81 0050 03F12003 		add	r3, r3, #32
  82 0054 4FF08C02 		mov	r2, #140
  83 0058 1A60     		str	r2, [r3, #0]
 248:C:/StellarisWare/driverlib\pwm.c ****                                        PWM_X_GENA_ACTCMPAD_ZERO);
 249:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTLOAD_ONE |
  84              		.loc 1 249 0
  85 005a BB68     		ldr	r3, [r7, #8]
  86 005c 03F12403 		add	r3, r3, #36
  87 0060 40F60C02 		movw	r2, #2060
  88 0064 1A60     		str	r2, [r3, #0]
  89              	.L1:
 250:C:/StellarisWare/driverlib\pwm.c ****                                        PWM_X_GENB_ACTCMPBD_ZERO);
 251:C:/StellarisWare/driverlib\pwm.c ****     }
 252:C:/StellarisWare/driverlib\pwm.c **** }
  90              		.loc 1 252 0
  91 0066 07F11407 		add	r7, r7, #20
  92 006a BD46     		mov	sp, r7
  93 006c 80BC     		pop	{r7}
  94 006e 7047     		bx	lr
  95              		.cfi_endproc
  96              	.LFE0:
  98              		.section	.text.PWMGenPeriodSet,"ax",%progbits
  99              		.align	2
 100              		.global	PWMGenPeriodSet
 101              		.thumb
 102              		.thumb_func
 104              	PWMGenPeriodSet:
 105              	.LFB1:
 253:C:/StellarisWare/driverlib\pwm.c **** 
 254:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 255:C:/StellarisWare/driverlib\pwm.c **** //
 256:C:/StellarisWare/driverlib\pwm.c **** //! Sets the period of a PWM generator.
 257:C:/StellarisWare/driverlib\pwm.c **** //!
 258:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 259:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to be modified.  This parameter must be
 260:C:/StellarisWare/driverlib\pwm.c **** //! one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 261:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPeriod specifies the period of PWM generator output, measured
 262:C:/StellarisWare/driverlib\pwm.c **** //! in clock ticks.
 263:C:/StellarisWare/driverlib\pwm.c **** //!
 264:C:/StellarisWare/driverlib\pwm.c **** //! This function sets the period of the specified PWM generator block, where
 265:C:/StellarisWare/driverlib\pwm.c **** //! the period of the generator block is defined as the number of PWM clock
 266:C:/StellarisWare/driverlib\pwm.c **** //! ticks between pulses on the generator block zero signal.
 267:C:/StellarisWare/driverlib\pwm.c **** //!
 268:C:/StellarisWare/driverlib\pwm.c **** //! \note Any subsequent calls made to this function before an update occurs
 269:C:/StellarisWare/driverlib\pwm.c **** //! cause the previous values to be overwritten.
 270:C:/StellarisWare/driverlib\pwm.c **** //!
 271:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 272:C:/StellarisWare/driverlib\pwm.c **** //
 273:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 274:C:/StellarisWare/driverlib\pwm.c **** void
 275:C:/StellarisWare/driverlib\pwm.c **** PWMGenPeriodSet(unsigned long ulBase, unsigned long ulGen,
 276:C:/StellarisWare/driverlib\pwm.c ****                 unsigned long ulPeriod)
 277:C:/StellarisWare/driverlib\pwm.c **** {
 106              		.loc 1 277 0
 107              		.cfi_startproc
 108              		@ args = 0, pretend = 0, frame = 16
 109              		@ frame_needed = 1, uses_anonymous_args = 0
 110              		@ link register save eliminated.
 111 0000 80B4     		push	{r7}
 112              	.LCFI3:
 113              		.cfi_def_cfa_offset 4
 114              		.cfi_offset 7, -4
 115 0002 85B0     		sub	sp, sp, #20
 116              	.LCFI4:
 117              		.cfi_def_cfa_offset 24
 118 0004 00AF     		add	r7, sp, #0
 119              	.LCFI5:
 120              		.cfi_def_cfa_register 7
 121 0006 F860     		str	r0, [r7, #12]
 122 0008 B960     		str	r1, [r7, #8]
 123 000a 7A60     		str	r2, [r7, #4]
 278:C:/StellarisWare/driverlib\pwm.c ****     //
 279:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 280:C:/StellarisWare/driverlib\pwm.c ****     //
 281:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 282:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 283:C:/StellarisWare/driverlib\pwm.c **** 
 284:C:/StellarisWare/driverlib\pwm.c ****     //
 285:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 286:C:/StellarisWare/driverlib\pwm.c ****     //
 287:C:/StellarisWare/driverlib\pwm.c ****     ulGen = PWM_GEN_BADDR(ulBase, ulGen);
 124              		.loc 1 287 0
 125 000c BA68     		ldr	r2, [r7, #8]
 126 000e FB68     		ldr	r3, [r7, #12]
 127 0010 D318     		adds	r3, r2, r3
 128 0012 BB60     		str	r3, [r7, #8]
 288:C:/StellarisWare/driverlib\pwm.c **** 
 289:C:/StellarisWare/driverlib\pwm.c ****     //
 290:C:/StellarisWare/driverlib\pwm.c ****     // Set the reload register based on the mode.
 291:C:/StellarisWare/driverlib\pwm.c ****     //
 292:C:/StellarisWare/driverlib\pwm.c ****     if(HWREG(ulGen + PWM_O_X_CTL) & PWM_X_CTL_MODE)
 129              		.loc 1 292 0
 130 0014 BB68     		ldr	r3, [r7, #8]
 131 0016 1B68     		ldr	r3, [r3, #0]
 132 0018 03F00203 		and	r3, r3, #2
 133 001c 002B     		cmp	r3, #0
 134 001e 07D0     		beq	.L5
 293:C:/StellarisWare/driverlib\pwm.c ****     {
 294:C:/StellarisWare/driverlib\pwm.c ****         //
 295:C:/StellarisWare/driverlib\pwm.c ****         // In up/down count mode, set the reload register to half the requested
 296:C:/StellarisWare/driverlib\pwm.c ****         // period.
 297:C:/StellarisWare/driverlib\pwm.c ****         //
 298:C:/StellarisWare/driverlib\pwm.c ****         ASSERT((ulPeriod / 2) < 65536);
 299:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod / 2;
 135              		.loc 1 299 0
 136 0020 BB68     		ldr	r3, [r7, #8]
 137 0022 03F11003 		add	r3, r3, #16
 138 0026 7A68     		ldr	r2, [r7, #4]
 139 0028 4FEA5202 		lsr	r2, r2, #1
 140 002c 1A60     		str	r2, [r3, #0]
 141 002e 06E0     		b	.L4
 142              	.L5:
 300:C:/StellarisWare/driverlib\pwm.c ****     }
 301:C:/StellarisWare/driverlib\pwm.c ****     else
 302:C:/StellarisWare/driverlib\pwm.c ****     {
 303:C:/StellarisWare/driverlib\pwm.c ****         //
 304:C:/StellarisWare/driverlib\pwm.c ****         // In down count mode, set the reload register to the requested period
 305:C:/StellarisWare/driverlib\pwm.c ****         // minus one.
 306:C:/StellarisWare/driverlib\pwm.c ****         //
 307:C:/StellarisWare/driverlib\pwm.c ****         ASSERT((ulPeriod <= 65536) && (ulPeriod != 0));
 308:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod - 1;
 143              		.loc 1 308 0
 144 0030 BB68     		ldr	r3, [r7, #8]
 145 0032 03F11003 		add	r3, r3, #16
 146 0036 7A68     		ldr	r2, [r7, #4]
 147 0038 02F1FF32 		add	r2, r2, #-1
 148 003c 1A60     		str	r2, [r3, #0]
 149              	.L4:
 309:C:/StellarisWare/driverlib\pwm.c ****     }
 310:C:/StellarisWare/driverlib\pwm.c **** }
 150              		.loc 1 310 0
 151 003e 07F11407 		add	r7, r7, #20
 152 0042 BD46     		mov	sp, r7
 153 0044 80BC     		pop	{r7}
 154 0046 7047     		bx	lr
 155              		.cfi_endproc
 156              	.LFE1:
 158              		.section	.text.PWMGenPeriodGet,"ax",%progbits
 159              		.align	2
 160              		.global	PWMGenPeriodGet
 161              		.thumb
 162              		.thumb_func
 164              	PWMGenPeriodGet:
 165              	.LFB2:
 311:C:/StellarisWare/driverlib\pwm.c **** 
 312:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 313:C:/StellarisWare/driverlib\pwm.c **** //
 314:C:/StellarisWare/driverlib\pwm.c **** //! Gets the period of a PWM generator block.
 315:C:/StellarisWare/driverlib\pwm.c **** //!
 316:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 317:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to query.  This parameter must be one of
 318:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 319:C:/StellarisWare/driverlib\pwm.c **** //!
 320:C:/StellarisWare/driverlib\pwm.c **** //! This function gets the period of the specified PWM generator block.  The
 321:C:/StellarisWare/driverlib\pwm.c **** //! period of the generator block is defined as the number of PWM clock ticks
 322:C:/StellarisWare/driverlib\pwm.c **** //! between pulses on the generator block zero signal.
 323:C:/StellarisWare/driverlib\pwm.c **** //!
 324:C:/StellarisWare/driverlib\pwm.c **** //! If the update of the counter for the specified PWM generator has yet
 325:C:/StellarisWare/driverlib\pwm.c **** //! to be completed, the value returned may not be the active period.  The
 326:C:/StellarisWare/driverlib\pwm.c **** //! value returned is the programmed period, measured in PWM clock ticks.
 327:C:/StellarisWare/driverlib\pwm.c **** //!
 328:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the programmed period of the specified generator block
 329:C:/StellarisWare/driverlib\pwm.c **** //! in PWM clock ticks.
 330:C:/StellarisWare/driverlib\pwm.c **** //
 331:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 332:C:/StellarisWare/driverlib\pwm.c **** unsigned long
 333:C:/StellarisWare/driverlib\pwm.c **** PWMGenPeriodGet(unsigned long ulBase, unsigned long ulGen)
 334:C:/StellarisWare/driverlib\pwm.c **** {
 166              		.loc 1 334 0
 167              		.cfi_startproc
 168              		@ args = 0, pretend = 0, frame = 8
 169              		@ frame_needed = 1, uses_anonymous_args = 0
 170              		@ link register save eliminated.
 171 0000 80B4     		push	{r7}
 172              	.LCFI6:
 173              		.cfi_def_cfa_offset 4
 174              		.cfi_offset 7, -4
 175 0002 83B0     		sub	sp, sp, #12
 176              	.LCFI7:
 177              		.cfi_def_cfa_offset 16
 178 0004 00AF     		add	r7, sp, #0
 179              	.LCFI8:
 180              		.cfi_def_cfa_register 7
 181 0006 7860     		str	r0, [r7, #4]
 182 0008 3960     		str	r1, [r7, #0]
 335:C:/StellarisWare/driverlib\pwm.c ****     //
 336:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 337:C:/StellarisWare/driverlib\pwm.c ****     //
 338:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 339:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 340:C:/StellarisWare/driverlib\pwm.c **** 
 341:C:/StellarisWare/driverlib\pwm.c ****     //
 342:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 343:C:/StellarisWare/driverlib\pwm.c ****     //
 344:C:/StellarisWare/driverlib\pwm.c ****     ulGen = PWM_GEN_BADDR(ulBase, ulGen);
 183              		.loc 1 344 0
 184 000a 3A68     		ldr	r2, [r7, #0]
 185 000c 7B68     		ldr	r3, [r7, #4]
 186 000e D318     		adds	r3, r2, r3
 187 0010 3B60     		str	r3, [r7, #0]
 345:C:/StellarisWare/driverlib\pwm.c **** 
 346:C:/StellarisWare/driverlib\pwm.c ****     //
 347:C:/StellarisWare/driverlib\pwm.c ****     // Figure out the counter mode.
 348:C:/StellarisWare/driverlib\pwm.c ****     //
 349:C:/StellarisWare/driverlib\pwm.c ****     if(HWREG(ulGen + PWM_O_X_CTL) & PWM_X_CTL_MODE)
 188              		.loc 1 349 0
 189 0012 3B68     		ldr	r3, [r7, #0]
 190 0014 1B68     		ldr	r3, [r3, #0]
 191 0016 03F00203 		and	r3, r3, #2
 192 001a 002B     		cmp	r3, #0
 193 001c 06D0     		beq	.L8
 350:C:/StellarisWare/driverlib\pwm.c ****     {
 351:C:/StellarisWare/driverlib\pwm.c ****         //
 352:C:/StellarisWare/driverlib\pwm.c ****         // The period is twice the reload register value.
 353:C:/StellarisWare/driverlib\pwm.c ****         //
 354:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulGen + PWM_O_X_LOAD) * 2);
 194              		.loc 1 354 0
 195 001e 3B68     		ldr	r3, [r7, #0]
 196 0020 03F11003 		add	r3, r3, #16
 197 0024 1B68     		ldr	r3, [r3, #0]
 198 0026 4FEA4303 		lsl	r3, r3, #1
 199 002a 05E0     		b	.L9
 200              	.L8:
 355:C:/StellarisWare/driverlib\pwm.c ****     }
 356:C:/StellarisWare/driverlib\pwm.c ****     else
 357:C:/StellarisWare/driverlib\pwm.c ****     {
 358:C:/StellarisWare/driverlib\pwm.c ****         //
 359:C:/StellarisWare/driverlib\pwm.c ****         // The period is the reload register value plus one.
 360:C:/StellarisWare/driverlib\pwm.c ****         //
 361:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulGen + PWM_O_X_LOAD) + 1);
 201              		.loc 1 361 0
 202 002c 3B68     		ldr	r3, [r7, #0]
 203 002e 03F11003 		add	r3, r3, #16
 204 0032 1B68     		ldr	r3, [r3, #0]
 205 0034 03F10103 		add	r3, r3, #1
 206              	.L9:
 362:C:/StellarisWare/driverlib\pwm.c ****     }
 363:C:/StellarisWare/driverlib\pwm.c **** }
 207              		.loc 1 363 0
 208 0038 1846     		mov	r0, r3
 209 003a 07F10C07 		add	r7, r7, #12
 210 003e BD46     		mov	sp, r7
 211 0040 80BC     		pop	{r7}
 212 0042 7047     		bx	lr
 213              		.cfi_endproc
 214              	.LFE2:
 216              		.section	.text.PWMGenEnable,"ax",%progbits
 217              		.align	2
 218              		.global	PWMGenEnable
 219              		.thumb
 220              		.thumb_func
 222              	PWMGenEnable:
 223              	.LFB3:
 364:C:/StellarisWare/driverlib\pwm.c **** 
 365:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 366:C:/StellarisWare/driverlib\pwm.c **** //
 367:C:/StellarisWare/driverlib\pwm.c **** //! Enables the timer/counter for a PWM generator block.
 368:C:/StellarisWare/driverlib\pwm.c **** //!
 369:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 370:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to be enabled.  This parameter must be
 371:C:/StellarisWare/driverlib\pwm.c **** //! one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 372:C:/StellarisWare/driverlib\pwm.c **** //!
 373:C:/StellarisWare/driverlib\pwm.c **** //! This function allows the PWM clock to drive the timer/counter for the
 374:C:/StellarisWare/driverlib\pwm.c **** //! specified generator block.
 375:C:/StellarisWare/driverlib\pwm.c **** //!
 376:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 377:C:/StellarisWare/driverlib\pwm.c **** //
 378:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 379:C:/StellarisWare/driverlib\pwm.c **** void
 380:C:/StellarisWare/driverlib\pwm.c **** PWMGenEnable(unsigned long ulBase, unsigned long ulGen)
 381:C:/StellarisWare/driverlib\pwm.c **** {
 224              		.loc 1 381 0
 225              		.cfi_startproc
 226              		@ args = 0, pretend = 0, frame = 8
 227              		@ frame_needed = 1, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229 0000 80B4     		push	{r7}
 230              	.LCFI9:
 231              		.cfi_def_cfa_offset 4
 232              		.cfi_offset 7, -4
 233 0002 83B0     		sub	sp, sp, #12
 234              	.LCFI10:
 235              		.cfi_def_cfa_offset 16
 236 0004 00AF     		add	r7, sp, #0
 237              	.LCFI11:
 238              		.cfi_def_cfa_register 7
 239 0006 7860     		str	r0, [r7, #4]
 240 0008 3960     		str	r1, [r7, #0]
 382:C:/StellarisWare/driverlib\pwm.c ****     //
 383:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 384:C:/StellarisWare/driverlib\pwm.c ****     //
 385:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 386:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 387:C:/StellarisWare/driverlib\pwm.c **** 
 388:C:/StellarisWare/driverlib\pwm.c ****     //
 389:C:/StellarisWare/driverlib\pwm.c ****     // Enable the PWM generator.
 390:C:/StellarisWare/driverlib\pwm.c ****     //
 391:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_CTL) |= PWM_X_CTL_ENABLE;
 241              		.loc 1 391 0
 242 000a 7A68     		ldr	r2, [r7, #4]
 243 000c 3B68     		ldr	r3, [r7, #0]
 244 000e D318     		adds	r3, r2, r3
 245 0010 7968     		ldr	r1, [r7, #4]
 246 0012 3A68     		ldr	r2, [r7, #0]
 247 0014 8A18     		adds	r2, r1, r2
 248 0016 1268     		ldr	r2, [r2, #0]
 249 0018 42F00102 		orr	r2, r2, #1
 250 001c 1A60     		str	r2, [r3, #0]
 392:C:/StellarisWare/driverlib\pwm.c **** }
 251              		.loc 1 392 0
 252 001e 07F10C07 		add	r7, r7, #12
 253 0022 BD46     		mov	sp, r7
 254 0024 80BC     		pop	{r7}
 255 0026 7047     		bx	lr
 256              		.cfi_endproc
 257              	.LFE3:
 259              		.section	.text.PWMGenDisable,"ax",%progbits
 260              		.align	2
 261              		.global	PWMGenDisable
 262              		.thumb
 263              		.thumb_func
 265              	PWMGenDisable:
 266              	.LFB4:
 393:C:/StellarisWare/driverlib\pwm.c **** 
 394:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 395:C:/StellarisWare/driverlib\pwm.c **** //
 396:C:/StellarisWare/driverlib\pwm.c **** //! Disables the timer/counter for a PWM generator block.
 397:C:/StellarisWare/driverlib\pwm.c **** //!
 398:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 399:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to be disabled.  This parameter must be
 400:C:/StellarisWare/driverlib\pwm.c **** //! one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 401:C:/StellarisWare/driverlib\pwm.c **** //!
 402:C:/StellarisWare/driverlib\pwm.c **** //! This function blocks the PWM clock from driving the timer/counter for the
 403:C:/StellarisWare/driverlib\pwm.c **** //! specified generator block.
 404:C:/StellarisWare/driverlib\pwm.c **** //!
 405:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 406:C:/StellarisWare/driverlib\pwm.c **** //
 407:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 408:C:/StellarisWare/driverlib\pwm.c **** void
 409:C:/StellarisWare/driverlib\pwm.c **** PWMGenDisable(unsigned long ulBase, unsigned long ulGen)
 410:C:/StellarisWare/driverlib\pwm.c **** {
 267              		.loc 1 410 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 8
 270              		@ frame_needed = 1, uses_anonymous_args = 0
 271              		@ link register save eliminated.
 272 0000 80B4     		push	{r7}
 273              	.LCFI12:
 274              		.cfi_def_cfa_offset 4
 275              		.cfi_offset 7, -4
 276 0002 83B0     		sub	sp, sp, #12
 277              	.LCFI13:
 278              		.cfi_def_cfa_offset 16
 279 0004 00AF     		add	r7, sp, #0
 280              	.LCFI14:
 281              		.cfi_def_cfa_register 7
 282 0006 7860     		str	r0, [r7, #4]
 283 0008 3960     		str	r1, [r7, #0]
 411:C:/StellarisWare/driverlib\pwm.c ****     //
 412:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 413:C:/StellarisWare/driverlib\pwm.c ****     //
 414:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 415:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 416:C:/StellarisWare/driverlib\pwm.c **** 
 417:C:/StellarisWare/driverlib\pwm.c ****     //
 418:C:/StellarisWare/driverlib\pwm.c ****     // Disable the PWM generator.
 419:C:/StellarisWare/driverlib\pwm.c ****     //
 420:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, + ulGen) + PWM_O_X_CTL) &= ~(PWM_X_CTL_ENABLE);
 284              		.loc 1 420 0
 285 000a 7A68     		ldr	r2, [r7, #4]
 286 000c 3B68     		ldr	r3, [r7, #0]
 287 000e D318     		adds	r3, r2, r3
 288 0010 7968     		ldr	r1, [r7, #4]
 289 0012 3A68     		ldr	r2, [r7, #0]
 290 0014 8A18     		adds	r2, r1, r2
 291 0016 1268     		ldr	r2, [r2, #0]
 292 0018 22F00102 		bic	r2, r2, #1
 293 001c 1A60     		str	r2, [r3, #0]
 421:C:/StellarisWare/driverlib\pwm.c **** }
 294              		.loc 1 421 0
 295 001e 07F10C07 		add	r7, r7, #12
 296 0022 BD46     		mov	sp, r7
 297 0024 80BC     		pop	{r7}
 298 0026 7047     		bx	lr
 299              		.cfi_endproc
 300              	.LFE4:
 302              		.section	.text.PWMPulseWidthSet,"ax",%progbits
 303              		.align	2
 304              		.global	PWMPulseWidthSet
 305              		.thumb
 306              		.thumb_func
 308              	PWMPulseWidthSet:
 309              	.LFB5:
 422:C:/StellarisWare/driverlib\pwm.c **** 
 423:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 424:C:/StellarisWare/driverlib\pwm.c **** //
 425:C:/StellarisWare/driverlib\pwm.c **** //! Sets the pulse width for the specified PWM output.
 426:C:/StellarisWare/driverlib\pwm.c **** //!
 427:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 428:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOut is the PWM output to modify.  This parameter must be one
 429:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_OUT_0, \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4,
 430:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_5, \b PWM_OUT_6, or \b PWM_OUT_7.
 431:C:/StellarisWare/driverlib\pwm.c **** //! \param ulWidth specifies the width of the positive portion of the pulse.
 432:C:/StellarisWare/driverlib\pwm.c **** //!
 433:C:/StellarisWare/driverlib\pwm.c **** //! This function sets the pulse width for the specified PWM output, where the
 434:C:/StellarisWare/driverlib\pwm.c **** //! pulse width is defined as the number of PWM clock ticks.
 435:C:/StellarisWare/driverlib\pwm.c **** //!
 436:C:/StellarisWare/driverlib\pwm.c **** //! \note Any subsequent calls made to this function before an update occurs
 437:C:/StellarisWare/driverlib\pwm.c **** //! cause the previous values to be overwritten.
 438:C:/StellarisWare/driverlib\pwm.c **** //!
 439:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 440:C:/StellarisWare/driverlib\pwm.c **** //
 441:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 442:C:/StellarisWare/driverlib\pwm.c **** void
 443:C:/StellarisWare/driverlib\pwm.c **** PWMPulseWidthSet(unsigned long ulBase, unsigned long ulPWMOut,
 444:C:/StellarisWare/driverlib\pwm.c ****                  unsigned long ulWidth)
 445:C:/StellarisWare/driverlib\pwm.c **** {
 310              		.loc 1 445 0
 311              		.cfi_startproc
 312              		@ args = 0, pretend = 0, frame = 24
 313              		@ frame_needed = 1, uses_anonymous_args = 0
 314              		@ link register save eliminated.
 315 0000 80B4     		push	{r7}
 316              	.LCFI15:
 317              		.cfi_def_cfa_offset 4
 318              		.cfi_offset 7, -4
 319 0002 87B0     		sub	sp, sp, #28
 320              	.LCFI16:
 321              		.cfi_def_cfa_offset 32
 322 0004 00AF     		add	r7, sp, #0
 323              	.LCFI17:
 324              		.cfi_def_cfa_register 7
 325 0006 F860     		str	r0, [r7, #12]
 326 0008 B960     		str	r1, [r7, #8]
 327 000a 7A60     		str	r2, [r7, #4]
 446:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulGenBase, ulReg;
 447:C:/StellarisWare/driverlib\pwm.c **** 
 448:C:/StellarisWare/driverlib\pwm.c ****     //
 449:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 450:C:/StellarisWare/driverlib\pwm.c ****     //
 451:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 452:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMOutValid(ulPWMOut));
 453:C:/StellarisWare/driverlib\pwm.c **** 
 454:C:/StellarisWare/driverlib\pwm.c ****     //
 455:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 456:C:/StellarisWare/driverlib\pwm.c ****     //
 457:C:/StellarisWare/driverlib\pwm.c ****     ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
 328              		.loc 1 457 0
 329 000c BB68     		ldr	r3, [r7, #8]
 330 000e 23F03F02 		bic	r2, r3, #63
 331 0012 FB68     		ldr	r3, [r7, #12]
 332 0014 D318     		adds	r3, r2, r3
 333 0016 7B61     		str	r3, [r7, #20]
 458:C:/StellarisWare/driverlib\pwm.c **** 
 459:C:/StellarisWare/driverlib\pwm.c ****     //
 460:C:/StellarisWare/driverlib\pwm.c ****     // If the counter is in up/down count mode, divide the width by two.
 461:C:/StellarisWare/driverlib\pwm.c ****     //
 462:C:/StellarisWare/driverlib\pwm.c ****     if(HWREG(ulGenBase + PWM_O_X_CTL) & PWM_X_CTL_MODE)
 334              		.loc 1 462 0
 335 0018 7B69     		ldr	r3, [r7, #20]
 336 001a 1B68     		ldr	r3, [r3, #0]
 337 001c 03F00203 		and	r3, r3, #2
 338 0020 002B     		cmp	r3, #0
 339 0022 03D0     		beq	.L13
 463:C:/StellarisWare/driverlib\pwm.c ****     {
 464:C:/StellarisWare/driverlib\pwm.c ****         ulWidth /= 2;
 340              		.loc 1 464 0
 341 0024 7B68     		ldr	r3, [r7, #4]
 342 0026 4FEA5303 		lsr	r3, r3, #1
 343 002a 7B60     		str	r3, [r7, #4]
 344              	.L13:
 465:C:/StellarisWare/driverlib\pwm.c ****     }
 466:C:/StellarisWare/driverlib\pwm.c **** 
 467:C:/StellarisWare/driverlib\pwm.c ****     //
 468:C:/StellarisWare/driverlib\pwm.c ****     // Get the period.
 469:C:/StellarisWare/driverlib\pwm.c ****     //
 470:C:/StellarisWare/driverlib\pwm.c ****     ulReg = HWREG(ulGenBase + PWM_O_X_LOAD);
 345              		.loc 1 470 0
 346 002c 7B69     		ldr	r3, [r7, #20]
 347 002e 03F11003 		add	r3, r3, #16
 348 0032 1B68     		ldr	r3, [r3, #0]
 349 0034 3B61     		str	r3, [r7, #16]
 471:C:/StellarisWare/driverlib\pwm.c **** 
 472:C:/StellarisWare/driverlib\pwm.c ****     //
 473:C:/StellarisWare/driverlib\pwm.c ****     // Make sure the width is not too large.
 474:C:/StellarisWare/driverlib\pwm.c ****     //
 475:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(ulWidth < ulReg);
 476:C:/StellarisWare/driverlib\pwm.c **** 
 477:C:/StellarisWare/driverlib\pwm.c ****     //
 478:C:/StellarisWare/driverlib\pwm.c ****     // Compute the compare value.
 479:C:/StellarisWare/driverlib\pwm.c ****     //
 480:C:/StellarisWare/driverlib\pwm.c ****     ulReg = ulReg - ulWidth;
 350              		.loc 1 480 0
 351 0036 3A69     		ldr	r2, [r7, #16]
 352 0038 7B68     		ldr	r3, [r7, #4]
 353 003a D31A     		subs	r3, r2, r3
 354 003c 3B61     		str	r3, [r7, #16]
 481:C:/StellarisWare/driverlib\pwm.c **** 
 482:C:/StellarisWare/driverlib\pwm.c ****     //
 483:C:/StellarisWare/driverlib\pwm.c ****     // Write to the appropriate registers.
 484:C:/StellarisWare/driverlib\pwm.c ****     //
 485:C:/StellarisWare/driverlib\pwm.c ****     if(PWM_IS_OUTPUT_ODD(ulPWMOut))
 355              		.loc 1 485 0
 356 003e BB68     		ldr	r3, [r7, #8]
 357 0040 03F00103 		and	r3, r3, #1
 358 0044 DBB2     		uxtb	r3, r3
 359 0046 002B     		cmp	r3, #0
 360 0048 05D0     		beq	.L14
 486:C:/StellarisWare/driverlib\pwm.c ****     {
 487:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGenBase + PWM_O_X_CMPB) = ulReg;
 361              		.loc 1 487 0
 362 004a 7B69     		ldr	r3, [r7, #20]
 363 004c 03F11C03 		add	r3, r3, #28
 364 0050 3A69     		ldr	r2, [r7, #16]
 365 0052 1A60     		str	r2, [r3, #0]
 366 0054 04E0     		b	.L12
 367              	.L14:
 488:C:/StellarisWare/driverlib\pwm.c ****     }
 489:C:/StellarisWare/driverlib\pwm.c ****     else
 490:C:/StellarisWare/driverlib\pwm.c ****     {
 491:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulGenBase + PWM_O_X_CMPA) = ulReg;
 368              		.loc 1 491 0
 369 0056 7B69     		ldr	r3, [r7, #20]
 370 0058 03F11803 		add	r3, r3, #24
 371 005c 3A69     		ldr	r2, [r7, #16]
 372 005e 1A60     		str	r2, [r3, #0]
 373              	.L12:
 492:C:/StellarisWare/driverlib\pwm.c ****     }
 493:C:/StellarisWare/driverlib\pwm.c **** }
 374              		.loc 1 493 0
 375 0060 07F11C07 		add	r7, r7, #28
 376 0064 BD46     		mov	sp, r7
 377 0066 80BC     		pop	{r7}
 378 0068 7047     		bx	lr
 379              		.cfi_endproc
 380              	.LFE5:
 382 006a 00BF     		.section	.text.PWMPulseWidthGet,"ax",%progbits
 383              		.align	2
 384              		.global	PWMPulseWidthGet
 385              		.thumb
 386              		.thumb_func
 388              	PWMPulseWidthGet:
 389              	.LFB6:
 494:C:/StellarisWare/driverlib\pwm.c **** 
 495:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 496:C:/StellarisWare/driverlib\pwm.c **** //
 497:C:/StellarisWare/driverlib\pwm.c **** //! Gets the pulse width of a PWM output.
 498:C:/StellarisWare/driverlib\pwm.c **** //!
 499:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 500:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOut is the PWM output to query.  This parameter must be one of
 501:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_0, \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4,
 502:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_5, \b PWM_OUT_6, or \b PWM_OUT_7.
 503:C:/StellarisWare/driverlib\pwm.c **** //!
 504:C:/StellarisWare/driverlib\pwm.c **** //! This function gets the currently programmed pulse width for the specified
 505:C:/StellarisWare/driverlib\pwm.c **** //! PWM output.  If the update of the comparator for the specified output has
 506:C:/StellarisWare/driverlib\pwm.c **** //! yet to be completed, the value returned may not be the active pulse width.
 507:C:/StellarisWare/driverlib\pwm.c **** //! The value returned is the programmed pulse width, measured in PWM clock
 508:C:/StellarisWare/driverlib\pwm.c **** //! ticks.
 509:C:/StellarisWare/driverlib\pwm.c **** //!
 510:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the width of the pulse in PWM clock ticks.
 511:C:/StellarisWare/driverlib\pwm.c **** //
 512:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 513:C:/StellarisWare/driverlib\pwm.c **** unsigned long
 514:C:/StellarisWare/driverlib\pwm.c **** PWMPulseWidthGet(unsigned long ulBase, unsigned long ulPWMOut)
 515:C:/StellarisWare/driverlib\pwm.c **** {
 390              		.loc 1 515 0
 391              		.cfi_startproc
 392              		@ args = 0, pretend = 0, frame = 24
 393              		@ frame_needed = 1, uses_anonymous_args = 0
 394              		@ link register save eliminated.
 395 0000 80B4     		push	{r7}
 396              	.LCFI18:
 397              		.cfi_def_cfa_offset 4
 398              		.cfi_offset 7, -4
 399 0002 87B0     		sub	sp, sp, #28
 400              	.LCFI19:
 401              		.cfi_def_cfa_offset 32
 402 0004 00AF     		add	r7, sp, #0
 403              	.LCFI20:
 404              		.cfi_def_cfa_register 7
 405 0006 7860     		str	r0, [r7, #4]
 406 0008 3960     		str	r1, [r7, #0]
 516:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulGenBase, ulReg, ulLoad;
 517:C:/StellarisWare/driverlib\pwm.c **** 
 518:C:/StellarisWare/driverlib\pwm.c ****     //
 519:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 520:C:/StellarisWare/driverlib\pwm.c ****     //
 521:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 522:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMOutValid(ulPWMOut));
 523:C:/StellarisWare/driverlib\pwm.c **** 
 524:C:/StellarisWare/driverlib\pwm.c ****     //
 525:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 526:C:/StellarisWare/driverlib\pwm.c ****     //
 527:C:/StellarisWare/driverlib\pwm.c ****     ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
 407              		.loc 1 527 0
 408 000a 3B68     		ldr	r3, [r7, #0]
 409 000c 23F03F02 		bic	r2, r3, #63
 410 0010 7B68     		ldr	r3, [r7, #4]
 411 0012 D318     		adds	r3, r2, r3
 412 0014 3B61     		str	r3, [r7, #16]
 528:C:/StellarisWare/driverlib\pwm.c **** 
 529:C:/StellarisWare/driverlib\pwm.c ****     //
 530:C:/StellarisWare/driverlib\pwm.c ****     // Then compute the pulse width.  If mode is UpDown, set
 531:C:/StellarisWare/driverlib\pwm.c ****     // width = (load - compare) * 2.  Otherwise, set width = load - compare.
 532:C:/StellarisWare/driverlib\pwm.c ****     //
 533:C:/StellarisWare/driverlib\pwm.c ****     ulLoad = HWREG(ulGenBase + PWM_O_X_LOAD);
 413              		.loc 1 533 0
 414 0016 3B69     		ldr	r3, [r7, #16]
 415 0018 03F11003 		add	r3, r3, #16
 416 001c 1B68     		ldr	r3, [r3, #0]
 417 001e FB60     		str	r3, [r7, #12]
 534:C:/StellarisWare/driverlib\pwm.c ****     if(PWM_IS_OUTPUT_ODD(ulPWMOut))
 418              		.loc 1 534 0
 419 0020 3B68     		ldr	r3, [r7, #0]
 420 0022 03F00103 		and	r3, r3, #1
 421 0026 DBB2     		uxtb	r3, r3
 422 0028 002B     		cmp	r3, #0
 423 002a 05D0     		beq	.L17
 535:C:/StellarisWare/driverlib\pwm.c ****     {
 536:C:/StellarisWare/driverlib\pwm.c ****         ulReg = HWREG(ulGenBase + PWM_O_X_CMPB);
 424              		.loc 1 536 0
 425 002c 3B69     		ldr	r3, [r7, #16]
 426 002e 03F11C03 		add	r3, r3, #28
 427 0032 1B68     		ldr	r3, [r3, #0]
 428 0034 7B61     		str	r3, [r7, #20]
 429 0036 04E0     		b	.L18
 430              	.L17:
 537:C:/StellarisWare/driverlib\pwm.c ****     }
 538:C:/StellarisWare/driverlib\pwm.c ****     else
 539:C:/StellarisWare/driverlib\pwm.c ****     {
 540:C:/StellarisWare/driverlib\pwm.c ****         ulReg = HWREG(ulGenBase + PWM_O_X_CMPA);
 431              		.loc 1 540 0
 432 0038 3B69     		ldr	r3, [r7, #16]
 433 003a 03F11803 		add	r3, r3, #24
 434 003e 1B68     		ldr	r3, [r3, #0]
 435 0040 7B61     		str	r3, [r7, #20]
 436              	.L18:
 541:C:/StellarisWare/driverlib\pwm.c ****     }
 542:C:/StellarisWare/driverlib\pwm.c ****     ulReg = ulLoad - ulReg;
 437              		.loc 1 542 0
 438 0042 FA68     		ldr	r2, [r7, #12]
 439 0044 7B69     		ldr	r3, [r7, #20]
 440 0046 D31A     		subs	r3, r2, r3
 441 0048 7B61     		str	r3, [r7, #20]
 543:C:/StellarisWare/driverlib\pwm.c **** 
 544:C:/StellarisWare/driverlib\pwm.c ****     //
 545:C:/StellarisWare/driverlib\pwm.c ****     // If in up/down count mode, double the pulse width.
 546:C:/StellarisWare/driverlib\pwm.c ****     //
 547:C:/StellarisWare/driverlib\pwm.c ****     if(HWREG(ulGenBase + PWM_O_X_CTL) & PWM_X_CTL_MODE)
 442              		.loc 1 547 0
 443 004a 3B69     		ldr	r3, [r7, #16]
 444 004c 1B68     		ldr	r3, [r3, #0]
 445 004e 03F00203 		and	r3, r3, #2
 446 0052 002B     		cmp	r3, #0
 447 0054 03D0     		beq	.L19
 548:C:/StellarisWare/driverlib\pwm.c ****     {
 549:C:/StellarisWare/driverlib\pwm.c ****         ulReg = ulReg * 2;
 448              		.loc 1 549 0
 449 0056 7B69     		ldr	r3, [r7, #20]
 450 0058 4FEA4303 		lsl	r3, r3, #1
 451 005c 7B61     		str	r3, [r7, #20]
 452              	.L19:
 550:C:/StellarisWare/driverlib\pwm.c ****     }
 551:C:/StellarisWare/driverlib\pwm.c **** 
 552:C:/StellarisWare/driverlib\pwm.c ****     //
 553:C:/StellarisWare/driverlib\pwm.c ****     // Return the pulse width.
 554:C:/StellarisWare/driverlib\pwm.c ****     //
 555:C:/StellarisWare/driverlib\pwm.c ****     return(ulReg);
 453              		.loc 1 555 0
 454 005e 7B69     		ldr	r3, [r7, #20]
 556:C:/StellarisWare/driverlib\pwm.c **** }
 455              		.loc 1 556 0
 456 0060 1846     		mov	r0, r3
 457 0062 07F11C07 		add	r7, r7, #28
 458 0066 BD46     		mov	sp, r7
 459 0068 80BC     		pop	{r7}
 460 006a 7047     		bx	lr
 461              		.cfi_endproc
 462              	.LFE6:
 464              		.section	.text.PWMDeadBandEnable,"ax",%progbits
 465              		.align	2
 466              		.global	PWMDeadBandEnable
 467              		.thumb
 468              		.thumb_func
 470              	PWMDeadBandEnable:
 471              	.LFB7:
 557:C:/StellarisWare/driverlib\pwm.c **** 
 558:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 559:C:/StellarisWare/driverlib\pwm.c **** //
 560:C:/StellarisWare/driverlib\pwm.c **** //! Enables the PWM dead band output and sets the dead band delays.
 561:C:/StellarisWare/driverlib\pwm.c **** //!
 562:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 563:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to modify.  This parameter must be one
 564:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 565:C:/StellarisWare/driverlib\pwm.c **** //! \param usRise specifies the width of delay from the rising edge.
 566:C:/StellarisWare/driverlib\pwm.c **** //! \param usFall specifies the width of delay from the falling edge.
 567:C:/StellarisWare/driverlib\pwm.c **** //!
 568:C:/StellarisWare/driverlib\pwm.c **** //! This function sets the dead bands for the specified PWM generator,
 569:C:/StellarisWare/driverlib\pwm.c **** //! where the dead bands are defined as the number of \b PWM clock ticks
 570:C:/StellarisWare/driverlib\pwm.c **** //! from the rising or falling edge of the generator's \b OutA signal.
 571:C:/StellarisWare/driverlib\pwm.c **** //! Note that this function causes the coupling of \b OutB to \b OutA.
 572:C:/StellarisWare/driverlib\pwm.c **** //!
 573:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 574:C:/StellarisWare/driverlib\pwm.c **** //
 575:C:/StellarisWare/driverlib\pwm.c **** //****************************************************************************
 576:C:/StellarisWare/driverlib\pwm.c **** void
 577:C:/StellarisWare/driverlib\pwm.c **** PWMDeadBandEnable(unsigned long ulBase, unsigned long ulGen,
 578:C:/StellarisWare/driverlib\pwm.c ****                   unsigned short usRise, unsigned short usFall)
 579:C:/StellarisWare/driverlib\pwm.c **** {
 472              		.loc 1 579 0
 473              		.cfi_startproc
 474              		@ args = 0, pretend = 0, frame = 16
 475              		@ frame_needed = 1, uses_anonymous_args = 0
 476              		@ link register save eliminated.
 477 0000 80B4     		push	{r7}
 478              	.LCFI21:
 479              		.cfi_def_cfa_offset 4
 480              		.cfi_offset 7, -4
 481 0002 85B0     		sub	sp, sp, #20
 482              	.LCFI22:
 483              		.cfi_def_cfa_offset 24
 484 0004 00AF     		add	r7, sp, #0
 485              	.LCFI23:
 486              		.cfi_def_cfa_register 7
 487 0006 F860     		str	r0, [r7, #12]
 488 0008 B960     		str	r1, [r7, #8]
 489 000a FA80     		strh	r2, [r7, #6]	@ movhi
 490 000c BB80     		strh	r3, [r7, #4]	@ movhi
 580:C:/StellarisWare/driverlib\pwm.c ****     //
 581:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 582:C:/StellarisWare/driverlib\pwm.c ****     //
 583:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 584:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 585:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(usRise < 4096);
 586:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(usFall < 4096);
 587:C:/StellarisWare/driverlib\pwm.c **** 
 588:C:/StellarisWare/driverlib\pwm.c ****     //
 589:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
 590:C:/StellarisWare/driverlib\pwm.c ****     //
 591:C:/StellarisWare/driverlib\pwm.c ****     ulGen = PWM_GEN_BADDR(ulBase, ulGen);
 491              		.loc 1 591 0
 492 000e BA68     		ldr	r2, [r7, #8]
 493 0010 FB68     		ldr	r3, [r7, #12]
 494 0012 D318     		adds	r3, r2, r3
 495 0014 BB60     		str	r3, [r7, #8]
 592:C:/StellarisWare/driverlib\pwm.c **** 
 593:C:/StellarisWare/driverlib\pwm.c ****     //
 594:C:/StellarisWare/driverlib\pwm.c ****     // Write the dead band delay values.
 595:C:/StellarisWare/driverlib\pwm.c ****     //
 596:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulGen + PWM_O_X_DBRISE) = usRise;
 496              		.loc 1 596 0
 497 0016 BB68     		ldr	r3, [r7, #8]
 498 0018 03F12C03 		add	r3, r3, #44
 499 001c FA88     		ldrh	r2, [r7, #6]
 500 001e 1A60     		str	r2, [r3, #0]
 597:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulGen + PWM_O_X_DBFALL) = usFall;
 501              		.loc 1 597 0
 502 0020 BB68     		ldr	r3, [r7, #8]
 503 0022 03F13003 		add	r3, r3, #48
 504 0026 BA88     		ldrh	r2, [r7, #4]
 505 0028 1A60     		str	r2, [r3, #0]
 598:C:/StellarisWare/driverlib\pwm.c **** 
 599:C:/StellarisWare/driverlib\pwm.c ****     //
 600:C:/StellarisWare/driverlib\pwm.c ****     // Enable the deadband functionality.
 601:C:/StellarisWare/driverlib\pwm.c ****     //
 602:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulGen + PWM_O_X_DBCTL) |= PWM_X_DBCTL_ENABLE;
 506              		.loc 1 602 0
 507 002a BB68     		ldr	r3, [r7, #8]
 508 002c 03F12803 		add	r3, r3, #40
 509 0030 BA68     		ldr	r2, [r7, #8]
 510 0032 02F12802 		add	r2, r2, #40
 511 0036 1268     		ldr	r2, [r2, #0]
 512 0038 42F00102 		orr	r2, r2, #1
 513 003c 1A60     		str	r2, [r3, #0]
 603:C:/StellarisWare/driverlib\pwm.c **** }
 514              		.loc 1 603 0
 515 003e 07F11407 		add	r7, r7, #20
 516 0042 BD46     		mov	sp, r7
 517 0044 80BC     		pop	{r7}
 518 0046 7047     		bx	lr
 519              		.cfi_endproc
 520              	.LFE7:
 522              		.section	.text.PWMDeadBandDisable,"ax",%progbits
 523              		.align	2
 524              		.global	PWMDeadBandDisable
 525              		.thumb
 526              		.thumb_func
 528              	PWMDeadBandDisable:
 529              	.LFB8:
 604:C:/StellarisWare/driverlib\pwm.c **** 
 605:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 606:C:/StellarisWare/driverlib\pwm.c **** //
 607:C:/StellarisWare/driverlib\pwm.c **** //! Disables the PWM dead band output.
 608:C:/StellarisWare/driverlib\pwm.c **** //!
 609:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 610:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to modify. This parameter must be one of
 611:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 612:C:/StellarisWare/driverlib\pwm.c **** //!
 613:C:/StellarisWare/driverlib\pwm.c **** //! This function disables the dead band mode for the specified PWM generator.
 614:C:/StellarisWare/driverlib\pwm.c **** //! Doing so decouples the \b OutA and \b OutB signals.
 615:C:/StellarisWare/driverlib\pwm.c **** //!
 616:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 617:C:/StellarisWare/driverlib\pwm.c **** //
 618:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 619:C:/StellarisWare/driverlib\pwm.c **** void
 620:C:/StellarisWare/driverlib\pwm.c **** PWMDeadBandDisable(unsigned long ulBase, unsigned long ulGen)
 621:C:/StellarisWare/driverlib\pwm.c **** {
 530              		.loc 1 621 0
 531              		.cfi_startproc
 532              		@ args = 0, pretend = 0, frame = 8
 533              		@ frame_needed = 1, uses_anonymous_args = 0
 534              		@ link register save eliminated.
 535 0000 80B4     		push	{r7}
 536              	.LCFI24:
 537              		.cfi_def_cfa_offset 4
 538              		.cfi_offset 7, -4
 539 0002 83B0     		sub	sp, sp, #12
 540              	.LCFI25:
 541              		.cfi_def_cfa_offset 16
 542 0004 00AF     		add	r7, sp, #0
 543              	.LCFI26:
 544              		.cfi_def_cfa_register 7
 545 0006 7860     		str	r0, [r7, #4]
 546 0008 3960     		str	r1, [r7, #0]
 622:C:/StellarisWare/driverlib\pwm.c ****     //
 623:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 624:C:/StellarisWare/driverlib\pwm.c ****     //
 625:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 626:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
 627:C:/StellarisWare/driverlib\pwm.c **** 
 628:C:/StellarisWare/driverlib\pwm.c ****     //
 629:C:/StellarisWare/driverlib\pwm.c ****     // Disable the deadband functionality.
 630:C:/StellarisWare/driverlib\pwm.c ****     //
 631:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_DBCTL) &=
 547              		.loc 1 631 0
 548 000a 7A68     		ldr	r2, [r7, #4]
 549 000c 3B68     		ldr	r3, [r7, #0]
 550 000e D318     		adds	r3, r2, r3
 551 0010 03F12803 		add	r3, r3, #40
 552 0014 7968     		ldr	r1, [r7, #4]
 553 0016 3A68     		ldr	r2, [r7, #0]
 554 0018 8A18     		adds	r2, r1, r2
 555 001a 02F12802 		add	r2, r2, #40
 556 001e 1268     		ldr	r2, [r2, #0]
 557 0020 22F00102 		bic	r2, r2, #1
 558 0024 1A60     		str	r2, [r3, #0]
 632:C:/StellarisWare/driverlib\pwm.c ****         ~(PWM_X_DBCTL_ENABLE);
 633:C:/StellarisWare/driverlib\pwm.c **** }
 559              		.loc 1 633 0
 560 0026 07F10C07 		add	r7, r7, #12
 561 002a BD46     		mov	sp, r7
 562 002c 80BC     		pop	{r7}
 563 002e 7047     		bx	lr
 564              		.cfi_endproc
 565              	.LFE8:
 567              		.section	.text.PWMSyncUpdate,"ax",%progbits
 568              		.align	2
 569              		.global	PWMSyncUpdate
 570              		.thumb
 571              		.thumb_func
 573              	PWMSyncUpdate:
 574              	.LFB9:
 634:C:/StellarisWare/driverlib\pwm.c **** 
 635:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 636:C:/StellarisWare/driverlib\pwm.c **** //
 637:C:/StellarisWare/driverlib\pwm.c **** //! Synchronizes all pending updates.
 638:C:/StellarisWare/driverlib\pwm.c **** //!
 639:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 640:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGenBits are the PWM generator blocks to be updated.  This
 641:C:/StellarisWare/driverlib\pwm.c **** //! parameter must be the logical OR of any of \b PWM_GEN_0_BIT,
 642:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_1_BIT, \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
 643:C:/StellarisWare/driverlib\pwm.c **** //!
 644:C:/StellarisWare/driverlib\pwm.c **** //! For the selected PWM generators, this function causes all queued updates to
 645:C:/StellarisWare/driverlib\pwm.c **** //! the period or pulse width to be applied the next time the corresponding
 646:C:/StellarisWare/driverlib\pwm.c **** //! counter becomes zero.
 647:C:/StellarisWare/driverlib\pwm.c **** //!
 648:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 649:C:/StellarisWare/driverlib\pwm.c **** //
 650:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 651:C:/StellarisWare/driverlib\pwm.c **** void
 652:C:/StellarisWare/driverlib\pwm.c **** PWMSyncUpdate(unsigned long ulBase, unsigned long ulGenBits)
 653:C:/StellarisWare/driverlib\pwm.c **** {
 575              		.loc 1 653 0
 576              		.cfi_startproc
 577              		@ args = 0, pretend = 0, frame = 8
 578              		@ frame_needed = 1, uses_anonymous_args = 0
 579              		@ link register save eliminated.
 580 0000 80B4     		push	{r7}
 581              	.LCFI27:
 582              		.cfi_def_cfa_offset 4
 583              		.cfi_offset 7, -4
 584 0002 83B0     		sub	sp, sp, #12
 585              	.LCFI28:
 586              		.cfi_def_cfa_offset 16
 587 0004 00AF     		add	r7, sp, #0
 588              	.LCFI29:
 589              		.cfi_def_cfa_register 7
 590 0006 7860     		str	r0, [r7, #4]
 591 0008 3960     		str	r1, [r7, #0]
 654:C:/StellarisWare/driverlib\pwm.c ****     //
 655:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 656:C:/StellarisWare/driverlib\pwm.c ****     //
 657:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 658:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulGenBits & ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
 659:C:/StellarisWare/driverlib\pwm.c ****                            PWM_GEN_3_BIT)));
 660:C:/StellarisWare/driverlib\pwm.c **** 
 661:C:/StellarisWare/driverlib\pwm.c ****     //
 662:C:/StellarisWare/driverlib\pwm.c ****     // Synchronize pending PWM register changes.
 663:C:/StellarisWare/driverlib\pwm.c ****     //
 664:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_CTL) = ulGenBits;
 592              		.loc 1 664 0
 593 000a 7B68     		ldr	r3, [r7, #4]
 594 000c 3A68     		ldr	r2, [r7, #0]
 595 000e 1A60     		str	r2, [r3, #0]
 665:C:/StellarisWare/driverlib\pwm.c **** }
 596              		.loc 1 665 0
 597 0010 07F10C07 		add	r7, r7, #12
 598 0014 BD46     		mov	sp, r7
 599 0016 80BC     		pop	{r7}
 600 0018 7047     		bx	lr
 601              		.cfi_endproc
 602              	.LFE9:
 604 001a 00BF     		.section	.text.PWMSyncTimeBase,"ax",%progbits
 605              		.align	2
 606              		.global	PWMSyncTimeBase
 607              		.thumb
 608              		.thumb_func
 610              	PWMSyncTimeBase:
 611              	.LFB10:
 666:C:/StellarisWare/driverlib\pwm.c **** 
 667:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 668:C:/StellarisWare/driverlib\pwm.c **** //
 669:C:/StellarisWare/driverlib\pwm.c **** //! Synchronizes the counters in one or multiple PWM generator blocks.
 670:C:/StellarisWare/driverlib\pwm.c **** //!
 671:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 672:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGenBits are the PWM generator blocks to be synchronized.  This
 673:C:/StellarisWare/driverlib\pwm.c **** //! parameter must be the logical OR of any of \b PWM_GEN_0_BIT,
 674:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_1_BIT, \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
 675:C:/StellarisWare/driverlib\pwm.c **** //!
 676:C:/StellarisWare/driverlib\pwm.c **** //! For the selected PWM module, this function synchronizes the time base
 677:C:/StellarisWare/driverlib\pwm.c **** //! of the generator blocks by causing the specified generator counters to be
 678:C:/StellarisWare/driverlib\pwm.c **** //! reset to zero.
 679:C:/StellarisWare/driverlib\pwm.c **** //!
 680:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 681:C:/StellarisWare/driverlib\pwm.c **** //
 682:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 683:C:/StellarisWare/driverlib\pwm.c **** void
 684:C:/StellarisWare/driverlib\pwm.c **** PWMSyncTimeBase(unsigned long ulBase, unsigned long ulGenBits)
 685:C:/StellarisWare/driverlib\pwm.c **** {
 612              		.loc 1 685 0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 8
 615              		@ frame_needed = 1, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 617 0000 80B4     		push	{r7}
 618              	.LCFI30:
 619              		.cfi_def_cfa_offset 4
 620              		.cfi_offset 7, -4
 621 0002 83B0     		sub	sp, sp, #12
 622              	.LCFI31:
 623              		.cfi_def_cfa_offset 16
 624 0004 00AF     		add	r7, sp, #0
 625              	.LCFI32:
 626              		.cfi_def_cfa_register 7
 627 0006 7860     		str	r0, [r7, #4]
 628 0008 3960     		str	r1, [r7, #0]
 686:C:/StellarisWare/driverlib\pwm.c ****     //
 687:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 688:C:/StellarisWare/driverlib\pwm.c ****     //
 689:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 690:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulGenBits & ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
 691:C:/StellarisWare/driverlib\pwm.c ****                            PWM_GEN_3_BIT)));
 692:C:/StellarisWare/driverlib\pwm.c **** 
 693:C:/StellarisWare/driverlib\pwm.c ****     //
 694:C:/StellarisWare/driverlib\pwm.c ****     // Synchronize the counters in the specified generators by writing to the
 695:C:/StellarisWare/driverlib\pwm.c ****     // module's synchronization register.
 696:C:/StellarisWare/driverlib\pwm.c ****     //
 697:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_SYNC) = ulGenBits;
 629              		.loc 1 697 0
 630 000a 7B68     		ldr	r3, [r7, #4]
 631 000c 03F10403 		add	r3, r3, #4
 632 0010 3A68     		ldr	r2, [r7, #0]
 633 0012 1A60     		str	r2, [r3, #0]
 698:C:/StellarisWare/driverlib\pwm.c **** }
 634              		.loc 1 698 0
 635 0014 07F10C07 		add	r7, r7, #12
 636 0018 BD46     		mov	sp, r7
 637 001a 80BC     		pop	{r7}
 638 001c 7047     		bx	lr
 639              		.cfi_endproc
 640              	.LFE10:
 642 001e 00BF     		.section	.text.PWMOutputState,"ax",%progbits
 643              		.align	2
 644              		.global	PWMOutputState
 645              		.thumb
 646              		.thumb_func
 648              	PWMOutputState:
 649              	.LFB11:
 699:C:/StellarisWare/driverlib\pwm.c **** 
 700:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 701:C:/StellarisWare/driverlib\pwm.c **** //
 702:C:/StellarisWare/driverlib\pwm.c **** //! Enables or disables PWM outputs.
 703:C:/StellarisWare/driverlib\pwm.c **** //!
 704:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 705:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOutBits are the PWM outputs to be modified.  This parameter
 706:C:/StellarisWare/driverlib\pwm.c **** //! must be the logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,
 707:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_2_BIT, \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT,
 708:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_6_BIT, or \b PWM_OUT_7_BIT.
 709:C:/StellarisWare/driverlib\pwm.c **** //! \param bEnable determines if the signal is enabled or disabled.
 710:C:/StellarisWare/driverlib\pwm.c **** //!
 711:C:/StellarisWare/driverlib\pwm.c **** //! This function enables or disables the selected PWM outputs.  The
 712:C:/StellarisWare/driverlib\pwm.c **** //! outputs are selected using the parameter \e ulPWMOutBits.  The parameter
 713:C:/StellarisWare/driverlib\pwm.c **** //! \e bEnable determines the state of the selected outputs.  If \e bEnable is
 714:C:/StellarisWare/driverlib\pwm.c **** //! \b true, then the selected PWM outputs are enabled, or placed in the active
 715:C:/StellarisWare/driverlib\pwm.c **** //! state.  If \e bEnable is \b false, then the selected outputs are disabled
 716:C:/StellarisWare/driverlib\pwm.c **** //! or placed in the inactive state.
 717:C:/StellarisWare/driverlib\pwm.c **** //!
 718:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 719:C:/StellarisWare/driverlib\pwm.c **** //
 720:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 721:C:/StellarisWare/driverlib\pwm.c **** void
 722:C:/StellarisWare/driverlib\pwm.c **** PWMOutputState(unsigned long ulBase, unsigned long ulPWMOutBits,
 723:C:/StellarisWare/driverlib\pwm.c ****                tBoolean bEnable)
 724:C:/StellarisWare/driverlib\pwm.c **** {
 650              		.loc 1 724 0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 16
 653              		@ frame_needed = 1, uses_anonymous_args = 0
 654              		@ link register save eliminated.
 655 0000 80B4     		push	{r7}
 656              	.LCFI33:
 657              		.cfi_def_cfa_offset 4
 658              		.cfi_offset 7, -4
 659 0002 85B0     		sub	sp, sp, #20
 660              	.LCFI34:
 661              		.cfi_def_cfa_offset 24
 662 0004 00AF     		add	r7, sp, #0
 663              	.LCFI35:
 664              		.cfi_def_cfa_register 7
 665 0006 F860     		str	r0, [r7, #12]
 666 0008 B960     		str	r1, [r7, #8]
 667 000a 1346     		mov	r3, r2
 668 000c FB71     		strb	r3, [r7, #7]
 725:C:/StellarisWare/driverlib\pwm.c ****     //
 726:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 727:C:/StellarisWare/driverlib\pwm.c ****     //
 728:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 729:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulPWMOutBits & ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
 730:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
 731:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
 732:C:/StellarisWare/driverlib\pwm.c **** 
 733:C:/StellarisWare/driverlib\pwm.c ****     //
 734:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's ENABLE output control register and set or clear the
 735:C:/StellarisWare/driverlib\pwm.c ****     // requested bits.
 736:C:/StellarisWare/driverlib\pwm.c ****     //
 737:C:/StellarisWare/driverlib\pwm.c ****     if(bEnable == true)
 669              		.loc 1 737 0
 670 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 671 0010 012B     		cmp	r3, #1
 672 0012 0AD1     		bne	.L25
 738:C:/StellarisWare/driverlib\pwm.c ****     {
 739:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_ENABLE) |= ulPWMOutBits;
 673              		.loc 1 739 0
 674 0014 FB68     		ldr	r3, [r7, #12]
 675 0016 03F10803 		add	r3, r3, #8
 676 001a FA68     		ldr	r2, [r7, #12]
 677 001c 02F10802 		add	r2, r2, #8
 678 0020 1168     		ldr	r1, [r2, #0]
 679 0022 BA68     		ldr	r2, [r7, #8]
 680 0024 0A43     		orrs	r2, r2, r1
 681 0026 1A60     		str	r2, [r3, #0]
 682 0028 0BE0     		b	.L24
 683              	.L25:
 740:C:/StellarisWare/driverlib\pwm.c ****     }
 741:C:/StellarisWare/driverlib\pwm.c ****     else
 742:C:/StellarisWare/driverlib\pwm.c ****     {
 743:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_ENABLE) &= ~(ulPWMOutBits);
 684              		.loc 1 743 0
 685 002a FB68     		ldr	r3, [r7, #12]
 686 002c 03F10803 		add	r3, r3, #8
 687 0030 FA68     		ldr	r2, [r7, #12]
 688 0032 02F10802 		add	r2, r2, #8
 689 0036 1168     		ldr	r1, [r2, #0]
 690 0038 BA68     		ldr	r2, [r7, #8]
 691 003a 6FEA0202 		mvn	r2, r2
 692 003e 0A40     		ands	r2, r2, r1
 693 0040 1A60     		str	r2, [r3, #0]
 694              	.L24:
 744:C:/StellarisWare/driverlib\pwm.c ****     }
 745:C:/StellarisWare/driverlib\pwm.c **** }
 695              		.loc 1 745 0
 696 0042 07F11407 		add	r7, r7, #20
 697 0046 BD46     		mov	sp, r7
 698 0048 80BC     		pop	{r7}
 699 004a 7047     		bx	lr
 700              		.cfi_endproc
 701              	.LFE11:
 703              		.section	.text.PWMOutputInvert,"ax",%progbits
 704              		.align	2
 705              		.global	PWMOutputInvert
 706              		.thumb
 707              		.thumb_func
 709              	PWMOutputInvert:
 710              	.LFB12:
 746:C:/StellarisWare/driverlib\pwm.c **** 
 747:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 748:C:/StellarisWare/driverlib\pwm.c **** //
 749:C:/StellarisWare/driverlib\pwm.c **** //! Selects the inversion mode for PWM outputs.
 750:C:/StellarisWare/driverlib\pwm.c **** //!
 751:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 752:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOutBits are the PWM outputs to be modified.  This parameter
 753:C:/StellarisWare/driverlib\pwm.c **** //! must be the logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,
 754:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_2_BIT, \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT,
 755:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_6_BIT, or \b PWM_OUT_7_BIT.
 756:C:/StellarisWare/driverlib\pwm.c **** //! \param bInvert determines if the signal is inverted or passed through.
 757:C:/StellarisWare/driverlib\pwm.c **** //!
 758:C:/StellarisWare/driverlib\pwm.c **** //! This function is used to select the inversion mode for the selected PWM
 759:C:/StellarisWare/driverlib\pwm.c **** //! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
 760:C:/StellarisWare/driverlib\pwm.c **** //! The parameter \e bInvert determines the inversion mode for the selected
 761:C:/StellarisWare/driverlib\pwm.c **** //! outputs.  If \e bInvert is \b true, this function causes the specified
 762:C:/StellarisWare/driverlib\pwm.c **** //! PWM output signals to be inverted or made active low.  If \e bInvert is
 763:C:/StellarisWare/driverlib\pwm.c **** //! \b false, the specified outputs are passed through as is or made active
 764:C:/StellarisWare/driverlib\pwm.c **** //! high.
 765:C:/StellarisWare/driverlib\pwm.c **** //!
 766:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 767:C:/StellarisWare/driverlib\pwm.c **** //
 768:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 769:C:/StellarisWare/driverlib\pwm.c **** void
 770:C:/StellarisWare/driverlib\pwm.c **** PWMOutputInvert(unsigned long ulBase, unsigned long ulPWMOutBits,
 771:C:/StellarisWare/driverlib\pwm.c ****                 tBoolean bInvert)
 772:C:/StellarisWare/driverlib\pwm.c **** {
 711              		.loc 1 772 0
 712              		.cfi_startproc
 713              		@ args = 0, pretend = 0, frame = 16
 714              		@ frame_needed = 1, uses_anonymous_args = 0
 715              		@ link register save eliminated.
 716 0000 80B4     		push	{r7}
 717              	.LCFI36:
 718              		.cfi_def_cfa_offset 4
 719              		.cfi_offset 7, -4
 720 0002 85B0     		sub	sp, sp, #20
 721              	.LCFI37:
 722              		.cfi_def_cfa_offset 24
 723 0004 00AF     		add	r7, sp, #0
 724              	.LCFI38:
 725              		.cfi_def_cfa_register 7
 726 0006 F860     		str	r0, [r7, #12]
 727 0008 B960     		str	r1, [r7, #8]
 728 000a 1346     		mov	r3, r2
 729 000c FB71     		strb	r3, [r7, #7]
 773:C:/StellarisWare/driverlib\pwm.c ****     //
 774:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 775:C:/StellarisWare/driverlib\pwm.c ****     //
 776:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 777:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulPWMOutBits & ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
 778:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
 779:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
 780:C:/StellarisWare/driverlib\pwm.c **** 
 781:C:/StellarisWare/driverlib\pwm.c ****     //
 782:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's INVERT output control register and set or clear the
 783:C:/StellarisWare/driverlib\pwm.c ****     // requested bits.
 784:C:/StellarisWare/driverlib\pwm.c ****     //
 785:C:/StellarisWare/driverlib\pwm.c ****     if(bInvert == true)
 730              		.loc 1 785 0
 731 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 732 0010 012B     		cmp	r3, #1
 733 0012 0AD1     		bne	.L28
 786:C:/StellarisWare/driverlib\pwm.c ****     {
 787:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_INVERT) |= ulPWMOutBits;
 734              		.loc 1 787 0
 735 0014 FB68     		ldr	r3, [r7, #12]
 736 0016 03F10C03 		add	r3, r3, #12
 737 001a FA68     		ldr	r2, [r7, #12]
 738 001c 02F10C02 		add	r2, r2, #12
 739 0020 1168     		ldr	r1, [r2, #0]
 740 0022 BA68     		ldr	r2, [r7, #8]
 741 0024 0A43     		orrs	r2, r2, r1
 742 0026 1A60     		str	r2, [r3, #0]
 743 0028 0BE0     		b	.L27
 744              	.L28:
 788:C:/StellarisWare/driverlib\pwm.c ****     }
 789:C:/StellarisWare/driverlib\pwm.c ****     else
 790:C:/StellarisWare/driverlib\pwm.c ****     {
 791:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_INVERT) &= ~(ulPWMOutBits);
 745              		.loc 1 791 0
 746 002a FB68     		ldr	r3, [r7, #12]
 747 002c 03F10C03 		add	r3, r3, #12
 748 0030 FA68     		ldr	r2, [r7, #12]
 749 0032 02F10C02 		add	r2, r2, #12
 750 0036 1168     		ldr	r1, [r2, #0]
 751 0038 BA68     		ldr	r2, [r7, #8]
 752 003a 6FEA0202 		mvn	r2, r2
 753 003e 0A40     		ands	r2, r2, r1
 754 0040 1A60     		str	r2, [r3, #0]
 755              	.L27:
 792:C:/StellarisWare/driverlib\pwm.c ****     }
 793:C:/StellarisWare/driverlib\pwm.c **** }
 756              		.loc 1 793 0
 757 0042 07F11407 		add	r7, r7, #20
 758 0046 BD46     		mov	sp, r7
 759 0048 80BC     		pop	{r7}
 760 004a 7047     		bx	lr
 761              		.cfi_endproc
 762              	.LFE12:
 764              		.section	.text.PWMOutputFaultLevel,"ax",%progbits
 765              		.align	2
 766              		.global	PWMOutputFaultLevel
 767              		.thumb
 768              		.thumb_func
 770              	PWMOutputFaultLevel:
 771              	.LFB13:
 794:C:/StellarisWare/driverlib\pwm.c **** 
 795:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 796:C:/StellarisWare/driverlib\pwm.c **** //
 797:C:/StellarisWare/driverlib\pwm.c **** //! Specifies the level of PWM outputs suppressed in response to a fault
 798:C:/StellarisWare/driverlib\pwm.c **** //! condition.
 799:C:/StellarisWare/driverlib\pwm.c **** //!
 800:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 801:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOutBits are the PWM outputs to be modified.  This parameter
 802:C:/StellarisWare/driverlib\pwm.c **** //! must be the logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,
 803:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_2_BIT, \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT,
 804:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_6_BIT, or \b PWM_OUT_7_BIT.
 805:C:/StellarisWare/driverlib\pwm.c **** //! \param bDriveHigh determines if the signal is driven high or low during an
 806:C:/StellarisWare/driverlib\pwm.c **** //! active fault condition.
 807:C:/StellarisWare/driverlib\pwm.c **** //!
 808:C:/StellarisWare/driverlib\pwm.c **** //! This function determines whether a PWM output pin that is suppressed in
 809:C:/StellarisWare/driverlib\pwm.c **** //! response to a fault condition is driven high or low.  The affected outputs
 810:C:/StellarisWare/driverlib\pwm.c **** //! are selected using the parameter \e ulPWMOutBits.  The parameter
 811:C:/StellarisWare/driverlib\pwm.c **** //! \e bDriveHigh determines the output level for the pins identified by
 812:C:/StellarisWare/driverlib\pwm.c **** //! \e ulPWMOutBits.  If \e bDriveHigh is \b true then the selected outputs are
 813:C:/StellarisWare/driverlib\pwm.c **** //! driven high when a fault is detected.  If it is \e false, the pins are
 814:C:/StellarisWare/driverlib\pwm.c **** //! driven low.
 815:C:/StellarisWare/driverlib\pwm.c **** //!
 816:C:/StellarisWare/driverlib\pwm.c **** //! In a fault condition, pins which have not been configured to be suppressed
 817:C:/StellarisWare/driverlib\pwm.c **** //! via a call to PWMOutputFault() are unaffected by this function.
 818:C:/StellarisWare/driverlib\pwm.c **** //!
 819:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is available only on devices which support extended
 820:C:/StellarisWare/driverlib\pwm.c **** //! PWM fault handling.
 821:C:/StellarisWare/driverlib\pwm.c **** //!
 822:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 823:C:/StellarisWare/driverlib\pwm.c **** //
 824:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 825:C:/StellarisWare/driverlib\pwm.c **** void
 826:C:/StellarisWare/driverlib\pwm.c **** PWMOutputFaultLevel(unsigned long ulBase, unsigned long ulPWMOutBits,
 827:C:/StellarisWare/driverlib\pwm.c ****                     tBoolean bDriveHigh)
 828:C:/StellarisWare/driverlib\pwm.c **** {
 772              		.loc 1 828 0
 773              		.cfi_startproc
 774              		@ args = 0, pretend = 0, frame = 16
 775              		@ frame_needed = 1, uses_anonymous_args = 0
 776              		@ link register save eliminated.
 777 0000 80B4     		push	{r7}
 778              	.LCFI39:
 779              		.cfi_def_cfa_offset 4
 780              		.cfi_offset 7, -4
 781 0002 85B0     		sub	sp, sp, #20
 782              	.LCFI40:
 783              		.cfi_def_cfa_offset 24
 784 0004 00AF     		add	r7, sp, #0
 785              	.LCFI41:
 786              		.cfi_def_cfa_register 7
 787 0006 F860     		str	r0, [r7, #12]
 788 0008 B960     		str	r1, [r7, #8]
 789 000a 1346     		mov	r3, r2
 790 000c FB71     		strb	r3, [r7, #7]
 829:C:/StellarisWare/driverlib\pwm.c ****     //
 830:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 831:C:/StellarisWare/driverlib\pwm.c ****     //
 832:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 833:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulPWMOutBits & ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
 834:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
 835:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
 836:C:/StellarisWare/driverlib\pwm.c **** 
 837:C:/StellarisWare/driverlib\pwm.c ****     //
 838:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's FAULT output control register and set or clear the
 839:C:/StellarisWare/driverlib\pwm.c ****     // requested bits.
 840:C:/StellarisWare/driverlib\pwm.c ****     //
 841:C:/StellarisWare/driverlib\pwm.c ****     if(bDriveHigh == true)
 791              		.loc 1 841 0
 792 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 793 0010 012B     		cmp	r3, #1
 794 0012 0AD1     		bne	.L31
 842:C:/StellarisWare/driverlib\pwm.c ****     {
 843:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_FAULTVAL) |= ulPWMOutBits;
 795              		.loc 1 843 0
 796 0014 FB68     		ldr	r3, [r7, #12]
 797 0016 03F12403 		add	r3, r3, #36
 798 001a FA68     		ldr	r2, [r7, #12]
 799 001c 02F12402 		add	r2, r2, #36
 800 0020 1168     		ldr	r1, [r2, #0]
 801 0022 BA68     		ldr	r2, [r7, #8]
 802 0024 0A43     		orrs	r2, r2, r1
 803 0026 1A60     		str	r2, [r3, #0]
 804 0028 0BE0     		b	.L30
 805              	.L31:
 844:C:/StellarisWare/driverlib\pwm.c ****     }
 845:C:/StellarisWare/driverlib\pwm.c ****     else
 846:C:/StellarisWare/driverlib\pwm.c ****     {
 847:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_FAULTVAL) &= ~(ulPWMOutBits);
 806              		.loc 1 847 0
 807 002a FB68     		ldr	r3, [r7, #12]
 808 002c 03F12403 		add	r3, r3, #36
 809 0030 FA68     		ldr	r2, [r7, #12]
 810 0032 02F12402 		add	r2, r2, #36
 811 0036 1168     		ldr	r1, [r2, #0]
 812 0038 BA68     		ldr	r2, [r7, #8]
 813 003a 6FEA0202 		mvn	r2, r2
 814 003e 0A40     		ands	r2, r2, r1
 815 0040 1A60     		str	r2, [r3, #0]
 816              	.L30:
 848:C:/StellarisWare/driverlib\pwm.c ****     }
 849:C:/StellarisWare/driverlib\pwm.c **** }
 817              		.loc 1 849 0
 818 0042 07F11407 		add	r7, r7, #20
 819 0046 BD46     		mov	sp, r7
 820 0048 80BC     		pop	{r7}
 821 004a 7047     		bx	lr
 822              		.cfi_endproc
 823              	.LFE13:
 825              		.section	.text.PWMOutputFault,"ax",%progbits
 826              		.align	2
 827              		.global	PWMOutputFault
 828              		.thumb
 829              		.thumb_func
 831              	PWMOutputFault:
 832              	.LFB14:
 850:C:/StellarisWare/driverlib\pwm.c **** 
 851:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 852:C:/StellarisWare/driverlib\pwm.c **** //
 853:C:/StellarisWare/driverlib\pwm.c **** //! Specifies the state of PWM outputs in response to a fault condition.
 854:C:/StellarisWare/driverlib\pwm.c **** //!
 855:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 856:C:/StellarisWare/driverlib\pwm.c **** //! \param ulPWMOutBits are the PWM outputs to be modified.  This parameter
 857:C:/StellarisWare/driverlib\pwm.c **** //! must be the  logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,
 858:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_2_BIT, \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT,
 859:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_OUT_6_BIT, or \b PWM_OUT_7_BIT.
 860:C:/StellarisWare/driverlib\pwm.c **** //! \param bFaultSuppress determines if the signal is suppressed or passed
 861:C:/StellarisWare/driverlib\pwm.c **** //! through during an active fault condition.
 862:C:/StellarisWare/driverlib\pwm.c **** //!
 863:C:/StellarisWare/driverlib\pwm.c **** //! This function sets the fault handling characteristics of the selected PWM
 864:C:/StellarisWare/driverlib\pwm.c **** //! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
 865:C:/StellarisWare/driverlib\pwm.c **** //! The parameter \e bFaultSuppress determines the fault handling
 866:C:/StellarisWare/driverlib\pwm.c **** //! characteristics for the selected outputs.  If \e bFaultSuppress is \b true,
 867:C:/StellarisWare/driverlib\pwm.c **** //! then the selected outputs are made inactive.  If \e bFaultSuppress is
 868:C:/StellarisWare/driverlib\pwm.c **** //! \b false, then the selected outputs are unaffected by the detected fault.
 869:C:/StellarisWare/driverlib\pwm.c **** //!
 870:C:/StellarisWare/driverlib\pwm.c **** //! On devices supporting extended PWM fault handling, the state the affected
 871:C:/StellarisWare/driverlib\pwm.c **** //! output pins are driven to can be configured with PWMOutputFaultLevel().  If
 872:C:/StellarisWare/driverlib\pwm.c **** //! not configured, or if the device does not support extended PWM fault
 873:C:/StellarisWare/driverlib\pwm.c **** //! handling, affected outputs are driven low on a fault condition.
 874:C:/StellarisWare/driverlib\pwm.c **** //!
 875:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
 876:C:/StellarisWare/driverlib\pwm.c **** //
 877:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 878:C:/StellarisWare/driverlib\pwm.c **** void
 879:C:/StellarisWare/driverlib\pwm.c **** PWMOutputFault(unsigned long ulBase, unsigned long ulPWMOutBits,
 880:C:/StellarisWare/driverlib\pwm.c ****                tBoolean bFaultSuppress)
 881:C:/StellarisWare/driverlib\pwm.c **** {
 833              		.loc 1 881 0
 834              		.cfi_startproc
 835              		@ args = 0, pretend = 0, frame = 16
 836              		@ frame_needed = 1, uses_anonymous_args = 0
 837              		@ link register save eliminated.
 838 0000 80B4     		push	{r7}
 839              	.LCFI42:
 840              		.cfi_def_cfa_offset 4
 841              		.cfi_offset 7, -4
 842 0002 85B0     		sub	sp, sp, #20
 843              	.LCFI43:
 844              		.cfi_def_cfa_offset 24
 845 0004 00AF     		add	r7, sp, #0
 846              	.LCFI44:
 847              		.cfi_def_cfa_register 7
 848 0006 F860     		str	r0, [r7, #12]
 849 0008 B960     		str	r1, [r7, #8]
 850 000a 1346     		mov	r3, r2
 851 000c FB71     		strb	r3, [r7, #7]
 882:C:/StellarisWare/driverlib\pwm.c ****     //
 883:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
 884:C:/StellarisWare/driverlib\pwm.c ****     //
 885:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
 886:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(!(ulPWMOutBits & ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
 887:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
 888:C:/StellarisWare/driverlib\pwm.c ****                               PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
 889:C:/StellarisWare/driverlib\pwm.c **** 
 890:C:/StellarisWare/driverlib\pwm.c ****     //
 891:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's FAULT output control register and set or clear the
 892:C:/StellarisWare/driverlib\pwm.c ****     // requested bits.
 893:C:/StellarisWare/driverlib\pwm.c ****     //
 894:C:/StellarisWare/driverlib\pwm.c ****     if(bFaultSuppress == true)
 852              		.loc 1 894 0
 853 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 854 0010 012B     		cmp	r3, #1
 855 0012 0AD1     		bne	.L34
 895:C:/StellarisWare/driverlib\pwm.c ****     {
 896:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_FAULT) |= ulPWMOutBits;
 856              		.loc 1 896 0
 857 0014 FB68     		ldr	r3, [r7, #12]
 858 0016 03F11003 		add	r3, r3, #16
 859 001a FA68     		ldr	r2, [r7, #12]
 860 001c 02F11002 		add	r2, r2, #16
 861 0020 1168     		ldr	r1, [r2, #0]
 862 0022 BA68     		ldr	r2, [r7, #8]
 863 0024 0A43     		orrs	r2, r2, r1
 864 0026 1A60     		str	r2, [r3, #0]
 865 0028 0BE0     		b	.L33
 866              	.L34:
 897:C:/StellarisWare/driverlib\pwm.c ****     }
 898:C:/StellarisWare/driverlib\pwm.c ****     else
 899:C:/StellarisWare/driverlib\pwm.c ****     {
 900:C:/StellarisWare/driverlib\pwm.c ****         HWREG(ulBase + PWM_O_FAULT) &= ~(ulPWMOutBits);
 867              		.loc 1 900 0
 868 002a FB68     		ldr	r3, [r7, #12]
 869 002c 03F11003 		add	r3, r3, #16
 870 0030 FA68     		ldr	r2, [r7, #12]
 871 0032 02F11002 		add	r2, r2, #16
 872 0036 1168     		ldr	r1, [r2, #0]
 873 0038 BA68     		ldr	r2, [r7, #8]
 874 003a 6FEA0202 		mvn	r2, r2
 875 003e 0A40     		ands	r2, r2, r1
 876 0040 1A60     		str	r2, [r3, #0]
 877              	.L33:
 901:C:/StellarisWare/driverlib\pwm.c ****     }
 902:C:/StellarisWare/driverlib\pwm.c **** }
 878              		.loc 1 902 0
 879 0042 07F11407 		add	r7, r7, #20
 880 0046 BD46     		mov	sp, r7
 881 0048 80BC     		pop	{r7}
 882 004a 7047     		bx	lr
 883              		.cfi_endproc
 884              	.LFE14:
 886              		.section	.text.PWMGenIntGet,"ax",%progbits
 887              		.align	2
 888              		.thumb
 889              		.thumb_func
 891              	PWMGenIntGet:
 892              	.LFB15:
 903:C:/StellarisWare/driverlib\pwm.c **** 
 904:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 905:C:/StellarisWare/driverlib\pwm.c **** //
 906:C:/StellarisWare/driverlib\pwm.c **** //! Gets the PWM generator interrupt number.
 907:C:/StellarisWare/driverlib\pwm.c **** //!
 908:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
 909:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator in question.  This parameter must be one
 910:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
 911:C:/StellarisWare/driverlib\pwm.c **** //!
 912:C:/StellarisWare/driverlib\pwm.c **** //! This function returns the interrupt number of the corresponding PWM
 913:C:/StellarisWare/driverlib\pwm.c **** //! generator.
 914:C:/StellarisWare/driverlib\pwm.c **** //!
 915:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the interrupt number.
 916:C:/StellarisWare/driverlib\pwm.c **** //
 917:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
 918:C:/StellarisWare/driverlib\pwm.c **** static unsigned long
 919:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntGet(unsigned long ulBase, unsigned long ulGen)
 920:C:/StellarisWare/driverlib\pwm.c **** {
 893              		.loc 1 920 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 8
 896              		@ frame_needed = 1, uses_anonymous_args = 0
 897              		@ link register save eliminated.
 898 0000 80B4     		push	{r7}
 899              	.LCFI45:
 900              		.cfi_def_cfa_offset 4
 901              		.cfi_offset 7, -4
 902 0002 83B0     		sub	sp, sp, #12
 903              	.LCFI46:
 904              		.cfi_def_cfa_offset 16
 905 0004 00AF     		add	r7, sp, #0
 906              	.LCFI47:
 907              		.cfi_def_cfa_register 7
 908 0006 7860     		str	r0, [r7, #4]
 909 0008 3960     		str	r1, [r7, #0]
 921:C:/StellarisWare/driverlib\pwm.c ****     //
 922:C:/StellarisWare/driverlib\pwm.c ****     // Determine the generator and PWM module in question.
 923:C:/StellarisWare/driverlib\pwm.c ****     //
 924:C:/StellarisWare/driverlib\pwm.c ****     switch(ulBase + ulGen)
 910              		.loc 1 924 0
 911 000a 7A68     		ldr	r2, [r7, #4]
 912 000c 3B68     		ldr	r3, [r7, #0]
 913 000e D318     		adds	r3, r2, r3
 914 0010 4FF40142 		mov	r2, #33024
 915 0014 C4F20202 		movt	r2, 16386
 916 0018 9342     		cmp	r3, r2
 917 001a 41D0     		beq	.L41
 918 001c 4FF40142 		mov	r2, #33024
 919 0020 C4F20202 		movt	r2, 16386
 920 0024 9342     		cmp	r3, r2
 921 0026 12D8     		bhi	.L46
 922 0028 48F28002 		movw	r2, #32896
 923 002c C4F20202 		movt	r2, 16386
 924 0030 9342     		cmp	r3, r2
 925 0032 2FD0     		beq	.L39
 926 0034 48F2C002 		movw	r2, #32960
 927 0038 C4F20202 		movt	r2, 16386
 928 003c 9342     		cmp	r3, r2
 929 003e 2CD0     		beq	.L40
 930 0040 48F24002 		movw	r2, #32832
 931 0044 C4F20202 		movt	r2, 16386
 932 0048 9342     		cmp	r3, r2
 933 004a 20D0     		beq	.L38
 934 004c 37E0     		b	.L37
 935              	.L46:
 936 004e 49F28002 		movw	r2, #36992
 937 0052 C4F20202 		movt	r2, 16386
 938 0056 9342     		cmp	r3, r2
 939 0058 28D0     		beq	.L43
 940 005a 49F28002 		movw	r2, #36992
 941 005e C4F20202 		movt	r2, 16386
 942 0062 9342     		cmp	r3, r2
 943 0064 06D8     		bhi	.L47
 944 0066 49F24002 		movw	r2, #36928
 945 006a C4F20202 		movt	r2, 16386
 946 006e 9342     		cmp	r3, r2
 947 0070 19D0     		beq	.L42
 948 0072 24E0     		b	.L37
 949              	.L47:
 950 0074 49F2C002 		movw	r2, #37056
 951 0078 C4F20202 		movt	r2, 16386
 952 007c 9342     		cmp	r3, r2
 953 007e 18D0     		beq	.L44
 954 0080 4FF41142 		mov	r2, #37120
 955 0084 C4F20202 		movt	r2, 16386
 956 0088 9342     		cmp	r3, r2
 957 008a 15D0     		beq	.L45
 958 008c 17E0     		b	.L37
 959              	.L38:
 925:C:/StellarisWare/driverlib\pwm.c ****     {
 926:C:/StellarisWare/driverlib\pwm.c ****         //
 927:C:/StellarisWare/driverlib\pwm.c ****         // The first PWM generator in the first PWM module.
 928:C:/StellarisWare/driverlib\pwm.c ****         //
 929:C:/StellarisWare/driverlib\pwm.c ****         case PWM0_BASE + PWM_GEN_0:
 930:C:/StellarisWare/driverlib\pwm.c ****         {
 931:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM0_0);
 960              		.loc 1 931 0
 961 008e 4FF01A03 		mov	r3, #26
 962 0092 16E0     		b	.L48
 963              	.L39:
 932:C:/StellarisWare/driverlib\pwm.c ****         }
 933:C:/StellarisWare/driverlib\pwm.c **** 
 934:C:/StellarisWare/driverlib\pwm.c ****         //
 935:C:/StellarisWare/driverlib\pwm.c ****         // The second PWM generator in the first PWM module.
 936:C:/StellarisWare/driverlib\pwm.c ****         //
 937:C:/StellarisWare/driverlib\pwm.c ****         case PWM0_BASE + PWM_GEN_1:
 938:C:/StellarisWare/driverlib\pwm.c ****         {
 939:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM0_1);
 964              		.loc 1 939 0
 965 0094 4FF01B03 		mov	r3, #27
 966 0098 13E0     		b	.L48
 967              	.L40:
 940:C:/StellarisWare/driverlib\pwm.c ****         }
 941:C:/StellarisWare/driverlib\pwm.c **** 
 942:C:/StellarisWare/driverlib\pwm.c ****         //
 943:C:/StellarisWare/driverlib\pwm.c ****         // The third PWM generator in the first PWM module.
 944:C:/StellarisWare/driverlib\pwm.c ****         //
 945:C:/StellarisWare/driverlib\pwm.c ****         case PWM0_BASE + PWM_GEN_2:
 946:C:/StellarisWare/driverlib\pwm.c ****         {
 947:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM0_2);
 968              		.loc 1 947 0
 969 009a 4FF01C03 		mov	r3, #28
 970 009e 10E0     		b	.L48
 971              	.L41:
 948:C:/StellarisWare/driverlib\pwm.c ****         }
 949:C:/StellarisWare/driverlib\pwm.c **** 
 950:C:/StellarisWare/driverlib\pwm.c ****         //
 951:C:/StellarisWare/driverlib\pwm.c ****         // The fourth PWM generator in the first PWM module.
 952:C:/StellarisWare/driverlib\pwm.c ****         //
 953:C:/StellarisWare/driverlib\pwm.c ****         case PWM0_BASE + PWM_GEN_3:
 954:C:/StellarisWare/driverlib\pwm.c ****         {
 955:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM0_3);
 972              		.loc 1 955 0
 973 00a0 4FF03D03 		mov	r3, #61
 974 00a4 0DE0     		b	.L48
 975              	.L42:
 956:C:/StellarisWare/driverlib\pwm.c ****         }
 957:C:/StellarisWare/driverlib\pwm.c **** 
 958:C:/StellarisWare/driverlib\pwm.c ****         //
 959:C:/StellarisWare/driverlib\pwm.c ****         // The first PWM generator in the second PWM module.
 960:C:/StellarisWare/driverlib\pwm.c ****         //
 961:C:/StellarisWare/driverlib\pwm.c ****         case PWM1_BASE + PWM_GEN_0:
 962:C:/StellarisWare/driverlib\pwm.c ****         {
 963:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM1_0);
 976              		.loc 1 963 0
 977 00a6 4FF09603 		mov	r3, #150
 978 00aa 0AE0     		b	.L48
 979              	.L43:
 964:C:/StellarisWare/driverlib\pwm.c ****         }
 965:C:/StellarisWare/driverlib\pwm.c **** 
 966:C:/StellarisWare/driverlib\pwm.c ****         //
 967:C:/StellarisWare/driverlib\pwm.c ****         // The first PWM generator in the second PWM module.
 968:C:/StellarisWare/driverlib\pwm.c ****         //
 969:C:/StellarisWare/driverlib\pwm.c ****         case PWM1_BASE + PWM_GEN_1:
 970:C:/StellarisWare/driverlib\pwm.c ****         {
 971:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM1_1);
 980              		.loc 1 971 0
 981 00ac 4FF09703 		mov	r3, #151
 982 00b0 07E0     		b	.L48
 983              	.L44:
 972:C:/StellarisWare/driverlib\pwm.c ****         }
 973:C:/StellarisWare/driverlib\pwm.c **** 
 974:C:/StellarisWare/driverlib\pwm.c ****         //
 975:C:/StellarisWare/driverlib\pwm.c ****         // The first PWM generator in the second PWM module.
 976:C:/StellarisWare/driverlib\pwm.c ****         //
 977:C:/StellarisWare/driverlib\pwm.c ****         case PWM1_BASE + PWM_GEN_2:
 978:C:/StellarisWare/driverlib\pwm.c ****         {
 979:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM1_2);
 984              		.loc 1 979 0
 985 00b2 4FF09803 		mov	r3, #152
 986 00b6 04E0     		b	.L48
 987              	.L45:
 980:C:/StellarisWare/driverlib\pwm.c ****         }
 981:C:/StellarisWare/driverlib\pwm.c **** 
 982:C:/StellarisWare/driverlib\pwm.c ****         //
 983:C:/StellarisWare/driverlib\pwm.c ****         // The first PWM generator in the second PWM module.
 984:C:/StellarisWare/driverlib\pwm.c ****         //
 985:C:/StellarisWare/driverlib\pwm.c ****         case PWM1_BASE + PWM_GEN_3:
 986:C:/StellarisWare/driverlib\pwm.c ****         {
 987:C:/StellarisWare/driverlib\pwm.c ****             return(INT_PWM1_3);
 988              		.loc 1 987 0
 989 00b8 4FF09903 		mov	r3, #153
 990 00bc 01E0     		b	.L48
 991              	.L37:
 988:C:/StellarisWare/driverlib\pwm.c ****         }
 989:C:/StellarisWare/driverlib\pwm.c **** 
 990:C:/StellarisWare/driverlib\pwm.c ****         //
 991:C:/StellarisWare/driverlib\pwm.c ****         // An unknown PWM module/generator was specified.
 992:C:/StellarisWare/driverlib\pwm.c ****         //
 993:C:/StellarisWare/driverlib\pwm.c ****         default:
 994:C:/StellarisWare/driverlib\pwm.c ****         {
 995:C:/StellarisWare/driverlib\pwm.c ****             return(0);
 992              		.loc 1 995 0
 993 00be 4FF00003 		mov	r3, #0
 994              	.L48:
 996:C:/StellarisWare/driverlib\pwm.c ****         }
 997:C:/StellarisWare/driverlib\pwm.c ****     }
 998:C:/StellarisWare/driverlib\pwm.c **** }
 995              		.loc 1 998 0
 996 00c2 1846     		mov	r0, r3
 997 00c4 07F10C07 		add	r7, r7, #12
 998 00c8 BD46     		mov	sp, r7
 999 00ca 80BC     		pop	{r7}
 1000 00cc 7047     		bx	lr
 1001              		.cfi_endproc
 1002              	.LFE15:
 1004 00ce 00BF     		.section	.text.PWMGenIntRegister,"ax",%progbits
 1005              		.align	2
 1006              		.global	PWMGenIntRegister
 1007              		.thumb
 1008              		.thumb_func
 1010              	PWMGenIntRegister:
 1011              	.LFB16:
 999:C:/StellarisWare/driverlib\pwm.c **** 
1000:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1001:C:/StellarisWare/driverlib\pwm.c **** //
1002:C:/StellarisWare/driverlib\pwm.c **** //! Registers an interrupt handler for the specified PWM generator block.
1003:C:/StellarisWare/driverlib\pwm.c **** //!
1004:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1005:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator in question.  This parameter must be one
1006:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
1007:C:/StellarisWare/driverlib\pwm.c **** //! \param pfnIntHandler is a pointer to the function to be called when the PWM
1008:C:/StellarisWare/driverlib\pwm.c **** //! generator interrupt occurs.
1009:C:/StellarisWare/driverlib\pwm.c **** //!
1010:C:/StellarisWare/driverlib\pwm.c **** //! This function ensures that the interrupt handler specified by
1011:C:/StellarisWare/driverlib\pwm.c **** //! \e pfnIntHandler is called when an interrupt is detected for the specified
1012:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator block.  This function also enables the corresponding
1013:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator interrupt in the interrupt controller; individual generator
1014:C:/StellarisWare/driverlib\pwm.c **** //! interrupts and interrupt sources must be enabled with PWMIntEnable() and
1015:C:/StellarisWare/driverlib\pwm.c **** //! PWMGenIntTrigEnable().
1016:C:/StellarisWare/driverlib\pwm.c **** //!
1017:C:/StellarisWare/driverlib\pwm.c **** //! \sa IntRegister() for important information about registering interrupt
1018:C:/StellarisWare/driverlib\pwm.c **** //! handlers.
1019:C:/StellarisWare/driverlib\pwm.c **** //!
1020:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1021:C:/StellarisWare/driverlib\pwm.c **** //
1022:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1023:C:/StellarisWare/driverlib\pwm.c **** void
1024:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntRegister(unsigned long ulBase, unsigned long ulGen,
1025:C:/StellarisWare/driverlib\pwm.c ****                   void (*pfnIntHandler)(void))
1026:C:/StellarisWare/driverlib\pwm.c **** {
 1012              		.loc 1 1026 0
 1013              		.cfi_startproc
 1014              		@ args = 0, pretend = 0, frame = 24
 1015              		@ frame_needed = 1, uses_anonymous_args = 0
 1016 0000 80B5     		push	{r7, lr}
 1017              	.LCFI48:
 1018              		.cfi_def_cfa_offset 8
 1019              		.cfi_offset 14, -4
 1020              		.cfi_offset 7, -8
 1021 0002 86B0     		sub	sp, sp, #24
 1022              	.LCFI49:
 1023              		.cfi_def_cfa_offset 32
 1024 0004 00AF     		add	r7, sp, #0
 1025              	.LCFI50:
 1026              		.cfi_def_cfa_register 7
 1027 0006 F860     		str	r0, [r7, #12]
 1028 0008 B960     		str	r1, [r7, #8]
 1029 000a 7A60     		str	r2, [r7, #4]
1027:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulInt;
1028:C:/StellarisWare/driverlib\pwm.c **** 
1029:C:/StellarisWare/driverlib\pwm.c ****     //
1030:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1031:C:/StellarisWare/driverlib\pwm.c ****     //
1032:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1033:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1034:C:/StellarisWare/driverlib\pwm.c **** 
1035:C:/StellarisWare/driverlib\pwm.c ****     //
1036:C:/StellarisWare/driverlib\pwm.c ****     // Get the interrupt number associated with the specified generator.
1037:C:/StellarisWare/driverlib\pwm.c ****     //
1038:C:/StellarisWare/driverlib\pwm.c ****     ulInt = PWMGenIntGet(ulBase, ulGen);
 1030              		.loc 1 1038 0
 1031 000c F868     		ldr	r0, [r7, #12]
 1032 000e B968     		ldr	r1, [r7, #8]
 1033 0010 FFF7FEFF 		bl	PWMGenIntGet
 1034 0014 7861     		str	r0, [r7, #20]
1039:C:/StellarisWare/driverlib\pwm.c **** 
1040:C:/StellarisWare/driverlib\pwm.c ****     //
1041:C:/StellarisWare/driverlib\pwm.c ****     // Register the interrupt handler.
1042:C:/StellarisWare/driverlib\pwm.c ****     //
1043:C:/StellarisWare/driverlib\pwm.c ****     IntRegister(ulInt, pfnIntHandler);
 1035              		.loc 1 1043 0
 1036 0016 7869     		ldr	r0, [r7, #20]
 1037 0018 7968     		ldr	r1, [r7, #4]
 1038 001a FFF7FEFF 		bl	IntRegister
1044:C:/StellarisWare/driverlib\pwm.c **** 
1045:C:/StellarisWare/driverlib\pwm.c ****     //
1046:C:/StellarisWare/driverlib\pwm.c ****     // Enable the PWMx interrupt.
1047:C:/StellarisWare/driverlib\pwm.c ****     //
1048:C:/StellarisWare/driverlib\pwm.c ****     IntEnable(ulInt);
 1039              		.loc 1 1048 0
 1040 001e 7869     		ldr	r0, [r7, #20]
 1041 0020 FFF7FEFF 		bl	IntEnable
1049:C:/StellarisWare/driverlib\pwm.c **** }
 1042              		.loc 1 1049 0
 1043 0024 07F11807 		add	r7, r7, #24
 1044 0028 BD46     		mov	sp, r7
 1045 002a 80BD     		pop	{r7, pc}
 1046              		.cfi_endproc
 1047              	.LFE16:
 1049              		.section	.text.PWMGenIntUnregister,"ax",%progbits
 1050              		.align	2
 1051              		.global	PWMGenIntUnregister
 1052              		.thumb
 1053              		.thumb_func
 1055              	PWMGenIntUnregister:
 1056              	.LFB17:
1050:C:/StellarisWare/driverlib\pwm.c **** 
1051:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1052:C:/StellarisWare/driverlib\pwm.c **** //
1053:C:/StellarisWare/driverlib\pwm.c **** //! Removes an interrupt handler for the specified PWM generator block.
1054:C:/StellarisWare/driverlib\pwm.c **** //!
1055:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1056:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator in question.  This parameter must be one
1057:C:/StellarisWare/driverlib\pwm.c **** //! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
1058:C:/StellarisWare/driverlib\pwm.c **** //!
1059:C:/StellarisWare/driverlib\pwm.c **** //! This function unregisters the interrupt handler for the specified
1060:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator block.  This function also disables the corresponding
1061:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator interrupt in the interrupt controller; individual generator
1062:C:/StellarisWare/driverlib\pwm.c **** //! interrupts and interrupt sources must be disabled with PWMIntDisable() and
1063:C:/StellarisWare/driverlib\pwm.c **** //! PWMGenIntTrigDisable().
1064:C:/StellarisWare/driverlib\pwm.c **** //!
1065:C:/StellarisWare/driverlib\pwm.c **** //! \sa IntRegister() for important information about registering interrupt
1066:C:/StellarisWare/driverlib\pwm.c **** //! handlers.
1067:C:/StellarisWare/driverlib\pwm.c **** //!
1068:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1069:C:/StellarisWare/driverlib\pwm.c **** //
1070:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1071:C:/StellarisWare/driverlib\pwm.c **** void
1072:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntUnregister(unsigned long ulBase, unsigned long ulGen)
1073:C:/StellarisWare/driverlib\pwm.c **** {
 1057              		.loc 1 1073 0
 1058              		.cfi_startproc
 1059              		@ args = 0, pretend = 0, frame = 16
 1060              		@ frame_needed = 1, uses_anonymous_args = 0
 1061 0000 80B5     		push	{r7, lr}
 1062              	.LCFI51:
 1063              		.cfi_def_cfa_offset 8
 1064              		.cfi_offset 14, -4
 1065              		.cfi_offset 7, -8
 1066 0002 84B0     		sub	sp, sp, #16
 1067              	.LCFI52:
 1068              		.cfi_def_cfa_offset 24
 1069 0004 00AF     		add	r7, sp, #0
 1070              	.LCFI53:
 1071              		.cfi_def_cfa_register 7
 1072 0006 7860     		str	r0, [r7, #4]
 1073 0008 3960     		str	r1, [r7, #0]
1074:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulInt;
1075:C:/StellarisWare/driverlib\pwm.c **** 
1076:C:/StellarisWare/driverlib\pwm.c ****     //
1077:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1078:C:/StellarisWare/driverlib\pwm.c ****     //
1079:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1080:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1081:C:/StellarisWare/driverlib\pwm.c **** 
1082:C:/StellarisWare/driverlib\pwm.c ****     //
1083:C:/StellarisWare/driverlib\pwm.c ****     // Get the interrupt number associated with the specified generator.
1084:C:/StellarisWare/driverlib\pwm.c ****     //
1085:C:/StellarisWare/driverlib\pwm.c ****     ulInt = PWMGenIntGet(ulBase, ulGen);
 1074              		.loc 1 1085 0
 1075 000a 7868     		ldr	r0, [r7, #4]
 1076 000c 3968     		ldr	r1, [r7, #0]
 1077 000e FFF7FEFF 		bl	PWMGenIntGet
 1078 0012 F860     		str	r0, [r7, #12]
1086:C:/StellarisWare/driverlib\pwm.c **** 
1087:C:/StellarisWare/driverlib\pwm.c ****     //
1088:C:/StellarisWare/driverlib\pwm.c ****     // Disable the PWMx interrupt.
1089:C:/StellarisWare/driverlib\pwm.c ****     //
1090:C:/StellarisWare/driverlib\pwm.c ****     IntDisable(ulInt);
 1079              		.loc 1 1090 0
 1080 0014 F868     		ldr	r0, [r7, #12]
 1081 0016 FFF7FEFF 		bl	IntDisable
1091:C:/StellarisWare/driverlib\pwm.c **** 
1092:C:/StellarisWare/driverlib\pwm.c ****     //
1093:C:/StellarisWare/driverlib\pwm.c ****     // Unregister the interrupt handler.
1094:C:/StellarisWare/driverlib\pwm.c ****     //
1095:C:/StellarisWare/driverlib\pwm.c ****     IntUnregister(ulInt);
 1082              		.loc 1 1095 0
 1083 001a F868     		ldr	r0, [r7, #12]
 1084 001c FFF7FEFF 		bl	IntUnregister
1096:C:/StellarisWare/driverlib\pwm.c **** }
 1085              		.loc 1 1096 0
 1086 0020 07F11007 		add	r7, r7, #16
 1087 0024 BD46     		mov	sp, r7
 1088 0026 80BD     		pop	{r7, pc}
 1089              		.cfi_endproc
 1090              	.LFE17:
 1092              		.section	.text.PWMFaultIntGet,"ax",%progbits
 1093              		.align	2
 1094              		.thumb
 1095              		.thumb_func
 1097              	PWMFaultIntGet:
 1098              	.LFB18:
1097:C:/StellarisWare/driverlib\pwm.c **** 
1098:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1099:C:/StellarisWare/driverlib\pwm.c **** //
1100:C:/StellarisWare/driverlib\pwm.c **** //! Gets the PWM fault interrupt number.
1101:C:/StellarisWare/driverlib\pwm.c **** //!
1102:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1103:C:/StellarisWare/driverlib\pwm.c **** //!
1104:C:/StellarisWare/driverlib\pwm.c **** //! This function returns the fault interrupt number of the corresponding
1105:C:/StellarisWare/driverlib\pwm.c **** //! PWM module.
1106:C:/StellarisWare/driverlib\pwm.c **** //!
1107:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the interrupt number.
1108:C:/StellarisWare/driverlib\pwm.c **** //
1109:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1110:C:/StellarisWare/driverlib\pwm.c **** static unsigned long
1111:C:/StellarisWare/driverlib\pwm.c **** PWMFaultIntGet(unsigned long ulBase)
1112:C:/StellarisWare/driverlib\pwm.c **** {
 1099              		.loc 1 1112 0
 1100              		.cfi_startproc
 1101              		@ args = 0, pretend = 0, frame = 8
 1102              		@ frame_needed = 1, uses_anonymous_args = 0
 1103              		@ link register save eliminated.
 1104 0000 80B4     		push	{r7}
 1105              	.LCFI54:
 1106              		.cfi_def_cfa_offset 4
 1107              		.cfi_offset 7, -4
 1108 0002 83B0     		sub	sp, sp, #12
 1109              	.LCFI55:
 1110              		.cfi_def_cfa_offset 16
 1111 0004 00AF     		add	r7, sp, #0
 1112              	.LCFI56:
 1113              		.cfi_def_cfa_register 7
 1114 0006 7860     		str	r0, [r7, #4]
1113:C:/StellarisWare/driverlib\pwm.c ****     //
1114:C:/StellarisWare/driverlib\pwm.c ****     // Return the fault interrupt number.
1115:C:/StellarisWare/driverlib\pwm.c ****     //
1116:C:/StellarisWare/driverlib\pwm.c ****     return((ulBase == PWM0_BASE) ? INT_PWM0_FAULT : INT_PWM1_FAULT);
 1115              		.loc 1 1116 0
 1116 0008 7A68     		ldr	r2, [r7, #4]
 1117 000a 4FF40043 		mov	r3, #32768
 1118 000e C4F20203 		movt	r3, 16386
 1119 0012 9A42     		cmp	r2, r3
 1120 0014 02D1     		bne	.L52
 1121              		.loc 1 1116 0 is_stmt 0 discriminator 1
 1122 0016 4FF01903 		mov	r3, #25
 1123 001a 01E0     		b	.L53
 1124              	.L52:
 1125              		.loc 1 1116 0 discriminator 2
 1126 001c 4FF09A03 		mov	r3, #154
 1127              	.L53:
1117:C:/StellarisWare/driverlib\pwm.c **** }
 1128              		.loc 1 1117 0 is_stmt 1 discriminator 3
 1129 0020 1846     		mov	r0, r3
 1130 0022 07F10C07 		add	r7, r7, #12
 1131 0026 BD46     		mov	sp, r7
 1132 0028 80BC     		pop	{r7}
 1133 002a 7047     		bx	lr
 1134              		.cfi_endproc
 1135              	.LFE18:
 1137              		.section	.text.PWMFaultIntRegister,"ax",%progbits
 1138              		.align	2
 1139              		.global	PWMFaultIntRegister
 1140              		.thumb
 1141              		.thumb_func
 1143              	PWMFaultIntRegister:
 1144              	.LFB19:
1118:C:/StellarisWare/driverlib\pwm.c **** 
1119:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1120:C:/StellarisWare/driverlib\pwm.c **** //
1121:C:/StellarisWare/driverlib\pwm.c **** //! Registers an interrupt handler for a fault condition detected in a PWM
1122:C:/StellarisWare/driverlib\pwm.c **** //! module.
1123:C:/StellarisWare/driverlib\pwm.c **** //!
1124:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1125:C:/StellarisWare/driverlib\pwm.c **** //! \param pfnIntHandler is a pointer to the function to be called when the PWM
1126:C:/StellarisWare/driverlib\pwm.c **** //! fault interrupt occurs.
1127:C:/StellarisWare/driverlib\pwm.c **** //!
1128:C:/StellarisWare/driverlib\pwm.c **** //! This function ensures that the interrupt handler specified by
1129:C:/StellarisWare/driverlib\pwm.c **** //! \e pfnIntHandler is called when a fault interrupt is detected for the
1130:C:/StellarisWare/driverlib\pwm.c **** //! selected PWM module.  This function also enables the PWM fault
1131:C:/StellarisWare/driverlib\pwm.c **** //! interrupt in the NVIC; the PWM fault interrupt must also be enabled at the
1132:C:/StellarisWare/driverlib\pwm.c **** //! module level using PWMIntEnable().
1133:C:/StellarisWare/driverlib\pwm.c **** //!
1134:C:/StellarisWare/driverlib\pwm.c **** //! \sa IntRegister() for important information about registering interrupt
1135:C:/StellarisWare/driverlib\pwm.c **** //! handlers.
1136:C:/StellarisWare/driverlib\pwm.c **** //!
1137:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1138:C:/StellarisWare/driverlib\pwm.c **** //
1139:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1140:C:/StellarisWare/driverlib\pwm.c **** void
1141:C:/StellarisWare/driverlib\pwm.c **** PWMFaultIntRegister(unsigned long ulBase, void (*pfnIntHandler)(void))
1142:C:/StellarisWare/driverlib\pwm.c **** {
 1145              		.loc 1 1142 0
 1146              		.cfi_startproc
 1147              		@ args = 0, pretend = 0, frame = 16
 1148              		@ frame_needed = 1, uses_anonymous_args = 0
 1149 0000 80B5     		push	{r7, lr}
 1150              	.LCFI57:
 1151              		.cfi_def_cfa_offset 8
 1152              		.cfi_offset 14, -4
 1153              		.cfi_offset 7, -8
 1154 0002 84B0     		sub	sp, sp, #16
 1155              	.LCFI58:
 1156              		.cfi_def_cfa_offset 24
 1157 0004 00AF     		add	r7, sp, #0
 1158              	.LCFI59:
 1159              		.cfi_def_cfa_register 7
 1160 0006 7860     		str	r0, [r7, #4]
 1161 0008 3960     		str	r1, [r7, #0]
1143:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulInt;
1144:C:/StellarisWare/driverlib\pwm.c **** 
1145:C:/StellarisWare/driverlib\pwm.c ****     //
1146:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1147:C:/StellarisWare/driverlib\pwm.c ****     //
1148:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1149:C:/StellarisWare/driverlib\pwm.c **** 
1150:C:/StellarisWare/driverlib\pwm.c ****     //
1151:C:/StellarisWare/driverlib\pwm.c ****     // Get the interrupt number associated with the specified module.
1152:C:/StellarisWare/driverlib\pwm.c ****     //
1153:C:/StellarisWare/driverlib\pwm.c ****     ulInt = PWMFaultIntGet(ulBase);
 1162              		.loc 1 1153 0
 1163 000a 7868     		ldr	r0, [r7, #4]
 1164 000c FFF7FEFF 		bl	PWMFaultIntGet
 1165 0010 F860     		str	r0, [r7, #12]
1154:C:/StellarisWare/driverlib\pwm.c **** 
1155:C:/StellarisWare/driverlib\pwm.c ****     //
1156:C:/StellarisWare/driverlib\pwm.c ****     // Register the interrupt handler, returning an error if one occurs.
1157:C:/StellarisWare/driverlib\pwm.c ****     //
1158:C:/StellarisWare/driverlib\pwm.c ****     IntRegister(ulInt, pfnIntHandler);
 1166              		.loc 1 1158 0
 1167 0012 F868     		ldr	r0, [r7, #12]
 1168 0014 3968     		ldr	r1, [r7, #0]
 1169 0016 FFF7FEFF 		bl	IntRegister
1159:C:/StellarisWare/driverlib\pwm.c **** 
1160:C:/StellarisWare/driverlib\pwm.c ****     //
1161:C:/StellarisWare/driverlib\pwm.c ****     // Enable the PWM fault interrupt.
1162:C:/StellarisWare/driverlib\pwm.c ****     //
1163:C:/StellarisWare/driverlib\pwm.c ****     IntEnable(ulInt);
 1170              		.loc 1 1163 0
 1171 001a F868     		ldr	r0, [r7, #12]
 1172 001c FFF7FEFF 		bl	IntEnable
1164:C:/StellarisWare/driverlib\pwm.c **** }
 1173              		.loc 1 1164 0
 1174 0020 07F11007 		add	r7, r7, #16
 1175 0024 BD46     		mov	sp, r7
 1176 0026 80BD     		pop	{r7, pc}
 1177              		.cfi_endproc
 1178              	.LFE19:
 1180              		.section	.text.PWMFaultIntUnregister,"ax",%progbits
 1181              		.align	2
 1182              		.global	PWMFaultIntUnregister
 1183              		.thumb
 1184              		.thumb_func
 1186              	PWMFaultIntUnregister:
 1187              	.LFB20:
1165:C:/StellarisWare/driverlib\pwm.c **** 
1166:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1167:C:/StellarisWare/driverlib\pwm.c **** //
1168:C:/StellarisWare/driverlib\pwm.c **** //! Removes the PWM fault condition interrupt handler.
1169:C:/StellarisWare/driverlib\pwm.c **** //!
1170:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1171:C:/StellarisWare/driverlib\pwm.c **** //!
1172:C:/StellarisWare/driverlib\pwm.c **** //! This function removes the interrupt handler for a PWM fault interrupt
1173:C:/StellarisWare/driverlib\pwm.c **** //! from the selected PWM module.  This function also disables the PWM
1174:C:/StellarisWare/driverlib\pwm.c **** //! fault interrupt in the NVIC; the PWM fault interrupt must also be disabled
1175:C:/StellarisWare/driverlib\pwm.c **** //! at the module level using PWMIntDisable().
1176:C:/StellarisWare/driverlib\pwm.c **** //!
1177:C:/StellarisWare/driverlib\pwm.c **** //! \sa IntRegister() for important information about registering interrupt
1178:C:/StellarisWare/driverlib\pwm.c **** //! handlers.
1179:C:/StellarisWare/driverlib\pwm.c **** //!
1180:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1181:C:/StellarisWare/driverlib\pwm.c **** //
1182:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1183:C:/StellarisWare/driverlib\pwm.c **** void
1184:C:/StellarisWare/driverlib\pwm.c **** PWMFaultIntUnregister(unsigned long ulBase)
1185:C:/StellarisWare/driverlib\pwm.c **** {
 1188              		.loc 1 1185 0
 1189              		.cfi_startproc
 1190              		@ args = 0, pretend = 0, frame = 16
 1191              		@ frame_needed = 1, uses_anonymous_args = 0
 1192 0000 80B5     		push	{r7, lr}
 1193              	.LCFI60:
 1194              		.cfi_def_cfa_offset 8
 1195              		.cfi_offset 14, -4
 1196              		.cfi_offset 7, -8
 1197 0002 84B0     		sub	sp, sp, #16
 1198              	.LCFI61:
 1199              		.cfi_def_cfa_offset 24
 1200 0004 00AF     		add	r7, sp, #0
 1201              	.LCFI62:
 1202              		.cfi_def_cfa_register 7
 1203 0006 7860     		str	r0, [r7, #4]
1186:C:/StellarisWare/driverlib\pwm.c ****     unsigned long ulInt;
1187:C:/StellarisWare/driverlib\pwm.c **** 
1188:C:/StellarisWare/driverlib\pwm.c ****     //
1189:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1190:C:/StellarisWare/driverlib\pwm.c ****     //
1191:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1192:C:/StellarisWare/driverlib\pwm.c **** 
1193:C:/StellarisWare/driverlib\pwm.c ****     //
1194:C:/StellarisWare/driverlib\pwm.c ****     // Get the interrupt number associated with the specified module.
1195:C:/StellarisWare/driverlib\pwm.c ****     //
1196:C:/StellarisWare/driverlib\pwm.c ****     ulInt = PWMFaultIntGet(ulBase);
 1204              		.loc 1 1196 0
 1205 0008 7868     		ldr	r0, [r7, #4]
 1206 000a FFF7FEFF 		bl	PWMFaultIntGet
 1207 000e F860     		str	r0, [r7, #12]
1197:C:/StellarisWare/driverlib\pwm.c **** 
1198:C:/StellarisWare/driverlib\pwm.c ****     //
1199:C:/StellarisWare/driverlib\pwm.c ****     // Disable the PWM fault interrupt.
1200:C:/StellarisWare/driverlib\pwm.c ****     //
1201:C:/StellarisWare/driverlib\pwm.c ****     IntDisable(ulInt);
 1208              		.loc 1 1201 0
 1209 0010 F868     		ldr	r0, [r7, #12]
 1210 0012 FFF7FEFF 		bl	IntDisable
1202:C:/StellarisWare/driverlib\pwm.c **** 
1203:C:/StellarisWare/driverlib\pwm.c ****     //
1204:C:/StellarisWare/driverlib\pwm.c ****     // Unregister the interrupt handler, returning an error if one occurs.
1205:C:/StellarisWare/driverlib\pwm.c ****     //
1206:C:/StellarisWare/driverlib\pwm.c ****     IntUnregister(ulInt);
 1211              		.loc 1 1206 0
 1212 0016 F868     		ldr	r0, [r7, #12]
 1213 0018 FFF7FEFF 		bl	IntUnregister
1207:C:/StellarisWare/driverlib\pwm.c **** }
 1214              		.loc 1 1207 0
 1215 001c 07F11007 		add	r7, r7, #16
 1216 0020 BD46     		mov	sp, r7
 1217 0022 80BD     		pop	{r7, pc}
 1218              		.cfi_endproc
 1219              	.LFE20:
 1221              		.section	.text.PWMGenIntTrigEnable,"ax",%progbits
 1222              		.align	2
 1223              		.global	PWMGenIntTrigEnable
 1224              		.thumb
 1225              		.thumb_func
 1227              	PWMGenIntTrigEnable:
 1228              	.LFB21:
1208:C:/StellarisWare/driverlib\pwm.c **** 
1209:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1210:C:/StellarisWare/driverlib\pwm.c **** //
1211:C:/StellarisWare/driverlib\pwm.c **** //! Enables interrupts and triggers for the specified PWM generator block.
1212:C:/StellarisWare/driverlib\pwm.c **** //!
1213:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1214:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to have interrupts and triggers enabled.
1215:C:/StellarisWare/driverlib\pwm.c **** //! This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
1216:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_3.
1217:C:/StellarisWare/driverlib\pwm.c **** //! \param ulIntTrig specifies the interrupts and triggers to be enabled.
1218:C:/StellarisWare/driverlib\pwm.c **** //!
1219:C:/StellarisWare/driverlib\pwm.c **** //! This function unmasks the specified interrupt(s) and trigger(s) by setting
1220:C:/StellarisWare/driverlib\pwm.c **** //! the specified bits of the interrupt/trigger enable register for the
1221:C:/StellarisWare/driverlib\pwm.c **** //! specified PWM generator.  The \e ulIntTrig parameter is the logical OR of
1222:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
1223:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
1224:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
1225:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
1226:C:/StellarisWare/driverlib\pwm.c **** //!
1227:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1228:C:/StellarisWare/driverlib\pwm.c **** //
1229:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1230:C:/StellarisWare/driverlib\pwm.c **** void
1231:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntTrigEnable(unsigned long ulBase, unsigned long ulGen,
1232:C:/StellarisWare/driverlib\pwm.c ****                     unsigned long ulIntTrig)
1233:C:/StellarisWare/driverlib\pwm.c **** {
 1229              		.loc 1 1233 0
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 16
 1232              		@ frame_needed = 1, uses_anonymous_args = 0
 1233              		@ link register save eliminated.
 1234 0000 80B4     		push	{r7}
 1235              	.LCFI63:
 1236              		.cfi_def_cfa_offset 4
 1237              		.cfi_offset 7, -4
 1238 0002 85B0     		sub	sp, sp, #20
 1239              	.LCFI64:
 1240              		.cfi_def_cfa_offset 24
 1241 0004 00AF     		add	r7, sp, #0
 1242              	.LCFI65:
 1243              		.cfi_def_cfa_register 7
 1244 0006 F860     		str	r0, [r7, #12]
 1245 0008 B960     		str	r1, [r7, #8]
 1246 000a 7A60     		str	r2, [r7, #4]
1234:C:/StellarisWare/driverlib\pwm.c ****     //
1235:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1236:C:/StellarisWare/driverlib\pwm.c ****     //
1237:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1238:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1239:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulIntTrig & ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
1240:C:/StellarisWare/driverlib\pwm.c ****                           PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
1241:C:/StellarisWare/driverlib\pwm.c ****                           PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
1242:C:/StellarisWare/driverlib\pwm.c ****                           PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
1243:C:/StellarisWare/driverlib\pwm.c ****                           PWM_TR_CNT_BD)) == 0);
1244:C:/StellarisWare/driverlib\pwm.c **** 
1245:C:/StellarisWare/driverlib\pwm.c ****     //
1246:C:/StellarisWare/driverlib\pwm.c ****     // Enable the specified interrupts/triggers.
1247:C:/StellarisWare/driverlib\pwm.c ****     //
1248:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) |= ulIntTrig;
 1247              		.loc 1 1248 0
 1248 000c FA68     		ldr	r2, [r7, #12]
 1249 000e BB68     		ldr	r3, [r7, #8]
 1250 0010 D318     		adds	r3, r2, r3
 1251 0012 03F10403 		add	r3, r3, #4
 1252 0016 F968     		ldr	r1, [r7, #12]
 1253 0018 BA68     		ldr	r2, [r7, #8]
 1254 001a 8A18     		adds	r2, r1, r2
 1255 001c 02F10402 		add	r2, r2, #4
 1256 0020 1168     		ldr	r1, [r2, #0]
 1257 0022 7A68     		ldr	r2, [r7, #4]
 1258 0024 0A43     		orrs	r2, r2, r1
 1259 0026 1A60     		str	r2, [r3, #0]
1249:C:/StellarisWare/driverlib\pwm.c **** }
 1260              		.loc 1 1249 0
 1261 0028 07F11407 		add	r7, r7, #20
 1262 002c BD46     		mov	sp, r7
 1263 002e 80BC     		pop	{r7}
 1264 0030 7047     		bx	lr
 1265              		.cfi_endproc
 1266              	.LFE21:
 1268 0032 00BF     		.section	.text.PWMGenIntTrigDisable,"ax",%progbits
 1269              		.align	2
 1270              		.global	PWMGenIntTrigDisable
 1271              		.thumb
 1272              		.thumb_func
 1274              	PWMGenIntTrigDisable:
 1275              	.LFB22:
1250:C:/StellarisWare/driverlib\pwm.c **** 
1251:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1252:C:/StellarisWare/driverlib\pwm.c **** //
1253:C:/StellarisWare/driverlib\pwm.c **** //! Disables interrupts for the specified PWM generator block.
1254:C:/StellarisWare/driverlib\pwm.c **** //!
1255:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1256:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to have interrupts and triggers disabled.
1257:C:/StellarisWare/driverlib\pwm.c **** //! This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
1258:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_3.
1259:C:/StellarisWare/driverlib\pwm.c **** //! \param ulIntTrig specifies the interrupts and triggers to be disabled.
1260:C:/StellarisWare/driverlib\pwm.c **** //!
1261:C:/StellarisWare/driverlib\pwm.c **** //! This function masks the specified interrupt(s) and trigger(s) by clearing
1262:C:/StellarisWare/driverlib\pwm.c **** //! the specified bits of the interrupt/trigger enable register for the
1263:C:/StellarisWare/driverlib\pwm.c **** //! specified PWM generator.  The \e ulIntTrig parameter is the logical OR of
1264:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
1265:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
1266:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
1267:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
1268:C:/StellarisWare/driverlib\pwm.c **** //!
1269:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1270:C:/StellarisWare/driverlib\pwm.c **** //
1271:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1272:C:/StellarisWare/driverlib\pwm.c **** void
1273:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntTrigDisable(unsigned long ulBase, unsigned long ulGen,
1274:C:/StellarisWare/driverlib\pwm.c ****                      unsigned long ulIntTrig)
1275:C:/StellarisWare/driverlib\pwm.c **** {
 1276              		.loc 1 1275 0
 1277              		.cfi_startproc
 1278              		@ args = 0, pretend = 0, frame = 16
 1279              		@ frame_needed = 1, uses_anonymous_args = 0
 1280              		@ link register save eliminated.
 1281 0000 80B4     		push	{r7}
 1282              	.LCFI66:
 1283              		.cfi_def_cfa_offset 4
 1284              		.cfi_offset 7, -4
 1285 0002 85B0     		sub	sp, sp, #20
 1286              	.LCFI67:
 1287              		.cfi_def_cfa_offset 24
 1288 0004 00AF     		add	r7, sp, #0
 1289              	.LCFI68:
 1290              		.cfi_def_cfa_register 7
 1291 0006 F860     		str	r0, [r7, #12]
 1292 0008 B960     		str	r1, [r7, #8]
 1293 000a 7A60     		str	r2, [r7, #4]
1276:C:/StellarisWare/driverlib\pwm.c ****     //
1277:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1278:C:/StellarisWare/driverlib\pwm.c ****     //
1279:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1280:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1281:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulIntTrig & ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
1282:C:/StellarisWare/driverlib\pwm.c ****                           PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
1283:C:/StellarisWare/driverlib\pwm.c ****                           PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
1284:C:/StellarisWare/driverlib\pwm.c ****                           PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
1285:C:/StellarisWare/driverlib\pwm.c ****                           PWM_TR_CNT_BD)) == 0);
1286:C:/StellarisWare/driverlib\pwm.c **** 
1287:C:/StellarisWare/driverlib\pwm.c ****     //
1288:C:/StellarisWare/driverlib\pwm.c ****     // Disable the specified interrupts/triggers.
1289:C:/StellarisWare/driverlib\pwm.c ****     //
1290:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) &= ~(ulIntTrig);
 1294              		.loc 1 1290 0
 1295 000c FA68     		ldr	r2, [r7, #12]
 1296 000e BB68     		ldr	r3, [r7, #8]
 1297 0010 D318     		adds	r3, r2, r3
 1298 0012 03F10403 		add	r3, r3, #4
 1299 0016 F968     		ldr	r1, [r7, #12]
 1300 0018 BA68     		ldr	r2, [r7, #8]
 1301 001a 8A18     		adds	r2, r1, r2
 1302 001c 02F10402 		add	r2, r2, #4
 1303 0020 1168     		ldr	r1, [r2, #0]
 1304 0022 7A68     		ldr	r2, [r7, #4]
 1305 0024 6FEA0202 		mvn	r2, r2
 1306 0028 0A40     		ands	r2, r2, r1
 1307 002a 1A60     		str	r2, [r3, #0]
1291:C:/StellarisWare/driverlib\pwm.c **** }
 1308              		.loc 1 1291 0
 1309 002c 07F11407 		add	r7, r7, #20
 1310 0030 BD46     		mov	sp, r7
 1311 0032 80BC     		pop	{r7}
 1312 0034 7047     		bx	lr
 1313              		.cfi_endproc
 1314              	.LFE22:
 1316              		.section	.text.PWMGenIntStatus,"ax",%progbits
 1317              		.align	2
 1318              		.global	PWMGenIntStatus
 1319              		.thumb
 1320              		.thumb_func
 1322              	PWMGenIntStatus:
 1323              	.LFB23:
1292:C:/StellarisWare/driverlib\pwm.c **** 
1293:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1294:C:/StellarisWare/driverlib\pwm.c **** //
1295:C:/StellarisWare/driverlib\pwm.c **** //! Gets interrupt status for the specified PWM generator block.
1296:C:/StellarisWare/driverlib\pwm.c **** //!
1297:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1298:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to query.  This parameter must be one of
1299:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_0,  \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
1300:C:/StellarisWare/driverlib\pwm.c **** //! \param bMasked specifies whether masked or raw interrupt status is
1301:C:/StellarisWare/driverlib\pwm.c **** //! returned.
1302:C:/StellarisWare/driverlib\pwm.c **** //!
1303:C:/StellarisWare/driverlib\pwm.c **** //! If \e bMasked is set as \b true, then the masked interrupt status is
1304:C:/StellarisWare/driverlib\pwm.c **** //! returned; otherwise, the raw interrupt status is returned.
1305:C:/StellarisWare/driverlib\pwm.c **** //!
1306:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the contents of the interrupt status register or the
1307:C:/StellarisWare/driverlib\pwm.c **** //! contents of the raw interrupt status register for the specified
1308:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator.
1309:C:/StellarisWare/driverlib\pwm.c **** //
1310:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1311:C:/StellarisWare/driverlib\pwm.c **** unsigned long
1312:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntStatus(unsigned long ulBase, unsigned long ulGen, tBoolean bMasked)
1313:C:/StellarisWare/driverlib\pwm.c **** {
 1324              		.loc 1 1313 0
 1325              		.cfi_startproc
 1326              		@ args = 0, pretend = 0, frame = 16
 1327              		@ frame_needed = 1, uses_anonymous_args = 0
 1328              		@ link register save eliminated.
 1329 0000 80B4     		push	{r7}
 1330              	.LCFI69:
 1331              		.cfi_def_cfa_offset 4
 1332              		.cfi_offset 7, -4
 1333 0002 85B0     		sub	sp, sp, #20
 1334              	.LCFI70:
 1335              		.cfi_def_cfa_offset 24
 1336 0004 00AF     		add	r7, sp, #0
 1337              	.LCFI71:
 1338              		.cfi_def_cfa_register 7
 1339 0006 F860     		str	r0, [r7, #12]
 1340 0008 B960     		str	r1, [r7, #8]
 1341 000a 1346     		mov	r3, r2
 1342 000c FB71     		strb	r3, [r7, #7]
1314:C:/StellarisWare/driverlib\pwm.c ****     //
1315:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1316:C:/StellarisWare/driverlib\pwm.c ****     //
1317:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1318:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1319:C:/StellarisWare/driverlib\pwm.c **** 
1320:C:/StellarisWare/driverlib\pwm.c ****     //
1321:C:/StellarisWare/driverlib\pwm.c ****     // Compute the generator's base address.
1322:C:/StellarisWare/driverlib\pwm.c ****     //
1323:C:/StellarisWare/driverlib\pwm.c ****     ulGen = PWM_GEN_BADDR(ulBase, ulGen);
 1343              		.loc 1 1323 0
 1344 000e BA68     		ldr	r2, [r7, #8]
 1345 0010 FB68     		ldr	r3, [r7, #12]
 1346 0012 D318     		adds	r3, r2, r3
 1347 0014 BB60     		str	r3, [r7, #8]
1324:C:/StellarisWare/driverlib\pwm.c **** 
1325:C:/StellarisWare/driverlib\pwm.c ****     //
1326:C:/StellarisWare/driverlib\pwm.c ****     // Read and return the specified generator's raw or enabled interrupt
1327:C:/StellarisWare/driverlib\pwm.c ****     // status.
1328:C:/StellarisWare/driverlib\pwm.c ****     //
1329:C:/StellarisWare/driverlib\pwm.c ****     if(bMasked == true)
 1348              		.loc 1 1329 0
 1349 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1350 0018 012B     		cmp	r3, #1
 1351 001a 04D1     		bne	.L59
1330:C:/StellarisWare/driverlib\pwm.c ****     {
1331:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulGen + PWM_O_X_ISC));
 1352              		.loc 1 1331 0
 1353 001c BB68     		ldr	r3, [r7, #8]
 1354 001e 03F10C03 		add	r3, r3, #12
 1355 0022 1B68     		ldr	r3, [r3, #0]
 1356 0024 03E0     		b	.L60
 1357              	.L59:
1332:C:/StellarisWare/driverlib\pwm.c ****     }
1333:C:/StellarisWare/driverlib\pwm.c ****     else
1334:C:/StellarisWare/driverlib\pwm.c ****     {
1335:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulGen + PWM_O_X_RIS));
 1358              		.loc 1 1335 0
 1359 0026 BB68     		ldr	r3, [r7, #8]
 1360 0028 03F10803 		add	r3, r3, #8
 1361 002c 1B68     		ldr	r3, [r3, #0]
 1362              	.L60:
1336:C:/StellarisWare/driverlib\pwm.c ****     }
1337:C:/StellarisWare/driverlib\pwm.c **** }
 1363              		.loc 1 1337 0
 1364 002e 1846     		mov	r0, r3
 1365 0030 07F11407 		add	r7, r7, #20
 1366 0034 BD46     		mov	sp, r7
 1367 0036 80BC     		pop	{r7}
 1368 0038 7047     		bx	lr
 1369              		.cfi_endproc
 1370              	.LFE23:
 1372 003a 00BF     		.section	.text.PWMGenIntClear,"ax",%progbits
 1373              		.align	2
 1374              		.global	PWMGenIntClear
 1375              		.thumb
 1376              		.thumb_func
 1378              	PWMGenIntClear:
 1379              	.LFB24:
1338:C:/StellarisWare/driverlib\pwm.c **** 
1339:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1340:C:/StellarisWare/driverlib\pwm.c **** //
1341:C:/StellarisWare/driverlib\pwm.c **** //! Clears the specified interrupt(s) for the specified PWM generator block.
1342:C:/StellarisWare/driverlib\pwm.c **** //!
1343:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1344:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator to query.  This parameter must be one of
1345:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
1346:C:/StellarisWare/driverlib\pwm.c **** //! \param ulInts specifies the interrupts to be cleared.
1347:C:/StellarisWare/driverlib\pwm.c **** //!
1348:C:/StellarisWare/driverlib\pwm.c **** //! This funciton clears the specified interrupt(s) by writing a 1 to the
1349:C:/StellarisWare/driverlib\pwm.c **** //! specified bits of the interrupt status register for the specified PWM
1350:C:/StellarisWare/driverlib\pwm.c **** //! generator.  The \e ulInts parameter is the logical OR of
1351:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
1352:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, or \b PWM_INT_CNT_BD.
1353:C:/StellarisWare/driverlib\pwm.c **** //!
1354:C:/StellarisWare/driverlib\pwm.c **** //! \note Because there is a write buffer in the Cortex-M processor, it may
1355:C:/StellarisWare/driverlib\pwm.c **** //! take several clock cycles before the interrupt source is actually cleared.
1356:C:/StellarisWare/driverlib\pwm.c **** //! Therefore, it is recommended that the interrupt source be cleared early in
1357:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt handler (as opposed to the very last action) to avoid
1358:C:/StellarisWare/driverlib\pwm.c **** //! returning from the interrupt handler before the interrupt source is
1359:C:/StellarisWare/driverlib\pwm.c **** //! actually cleared.  Failure to do so may result in the interrupt handler
1360:C:/StellarisWare/driverlib\pwm.c **** //! being immediately reentered (because the interrupt controller still sees
1361:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt source asserted).
1362:C:/StellarisWare/driverlib\pwm.c **** //!
1363:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1364:C:/StellarisWare/driverlib\pwm.c **** //
1365:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1366:C:/StellarisWare/driverlib\pwm.c **** void
1367:C:/StellarisWare/driverlib\pwm.c **** PWMGenIntClear(unsigned long ulBase, unsigned long ulGen, unsigned long ulInts)
1368:C:/StellarisWare/driverlib\pwm.c **** {
 1380              		.loc 1 1368 0
 1381              		.cfi_startproc
 1382              		@ args = 0, pretend = 0, frame = 16
 1383              		@ frame_needed = 1, uses_anonymous_args = 0
 1384              		@ link register save eliminated.
 1385 0000 80B4     		push	{r7}
 1386              	.LCFI72:
 1387              		.cfi_def_cfa_offset 4
 1388              		.cfi_offset 7, -4
 1389 0002 85B0     		sub	sp, sp, #20
 1390              	.LCFI73:
 1391              		.cfi_def_cfa_offset 24
 1392 0004 00AF     		add	r7, sp, #0
 1393              	.LCFI74:
 1394              		.cfi_def_cfa_register 7
 1395 0006 F860     		str	r0, [r7, #12]
 1396 0008 B960     		str	r1, [r7, #8]
 1397 000a 7A60     		str	r2, [r7, #4]
1369:C:/StellarisWare/driverlib\pwm.c ****     //
1370:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1371:C:/StellarisWare/driverlib\pwm.c ****     //
1372:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1373:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1374:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulInts & ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD | PWM_INT_CNT_AU |
1375:C:/StellarisWare/driverlib\pwm.c ****                        PWM_INT_CNT_AD | PWM_INT_CNT_BU | PWM_INT_CNT_BD)) ==
1376:C:/StellarisWare/driverlib\pwm.c ****            0);
1377:C:/StellarisWare/driverlib\pwm.c **** 
1378:C:/StellarisWare/driverlib\pwm.c ****     //
1379:C:/StellarisWare/driverlib\pwm.c ****     // Clear the requested interrupts by writing ones to the specified bit
1380:C:/StellarisWare/driverlib\pwm.c ****     // of the module's interrupt enable register.
1381:C:/StellarisWare/driverlib\pwm.c ****     //
1382:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_ISC) = ulInts;
 1398              		.loc 1 1382 0
 1399 000c FA68     		ldr	r2, [r7, #12]
 1400 000e BB68     		ldr	r3, [r7, #8]
 1401 0010 D318     		adds	r3, r2, r3
 1402 0012 03F10C03 		add	r3, r3, #12
 1403 0016 7A68     		ldr	r2, [r7, #4]
 1404 0018 1A60     		str	r2, [r3, #0]
1383:C:/StellarisWare/driverlib\pwm.c **** }
 1405              		.loc 1 1383 0
 1406 001a 07F11407 		add	r7, r7, #20
 1407 001e BD46     		mov	sp, r7
 1408 0020 80BC     		pop	{r7}
 1409 0022 7047     		bx	lr
 1410              		.cfi_endproc
 1411              	.LFE24:
 1413              		.section	.text.PWMIntEnable,"ax",%progbits
 1414              		.align	2
 1415              		.global	PWMIntEnable
 1416              		.thumb
 1417              		.thumb_func
 1419              	PWMIntEnable:
 1420              	.LFB25:
1384:C:/StellarisWare/driverlib\pwm.c **** 
1385:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1386:C:/StellarisWare/driverlib\pwm.c **** //
1387:C:/StellarisWare/driverlib\pwm.c **** //! Enables generator and fault interrupts for a PWM module.
1388:C:/StellarisWare/driverlib\pwm.c **** //!
1389:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1390:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGenFault contains the interrupts to be enabled.  This parameter
1391:C:/StellarisWare/driverlib\pwm.c **** //! must be a logical OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1,
1392:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_GEN_2, \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1,
1393:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.
1394:C:/StellarisWare/driverlib\pwm.c **** //!
1395:C:/StellarisWare/driverlib\pwm.c **** //! This function unmasks the specified interrupt(s) by setting the specified
1396:C:/StellarisWare/driverlib\pwm.c **** //! bits of the interrupt enable register for the selected PWM module.
1397:C:/StellarisWare/driverlib\pwm.c **** //!
1398:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1399:C:/StellarisWare/driverlib\pwm.c **** //
1400:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1401:C:/StellarisWare/driverlib\pwm.c **** void
1402:C:/StellarisWare/driverlib\pwm.c **** PWMIntEnable(unsigned long ulBase, unsigned long ulGenFault)
1403:C:/StellarisWare/driverlib\pwm.c **** {
 1421              		.loc 1 1403 0
 1422              		.cfi_startproc
 1423              		@ args = 0, pretend = 0, frame = 8
 1424              		@ frame_needed = 1, uses_anonymous_args = 0
 1425              		@ link register save eliminated.
 1426 0000 80B4     		push	{r7}
 1427              	.LCFI75:
 1428              		.cfi_def_cfa_offset 4
 1429              		.cfi_offset 7, -4
 1430 0002 83B0     		sub	sp, sp, #12
 1431              	.LCFI76:
 1432              		.cfi_def_cfa_offset 16
 1433 0004 00AF     		add	r7, sp, #0
 1434              	.LCFI77:
 1435              		.cfi_def_cfa_register 7
 1436 0006 7860     		str	r0, [r7, #4]
 1437 0008 3960     		str	r1, [r7, #0]
1404:C:/StellarisWare/driverlib\pwm.c ****     //
1405:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1406:C:/StellarisWare/driverlib\pwm.c ****     //
1407:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1408:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGenFault & ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
1409:C:/StellarisWare/driverlib\pwm.c ****                            PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
1410:C:/StellarisWare/driverlib\pwm.c ****                            PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
1411:C:/StellarisWare/driverlib\pwm.c **** 
1412:C:/StellarisWare/driverlib\pwm.c ****     //
1413:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's interrupt enable register and enable interrupts
1414:C:/StellarisWare/driverlib\pwm.c ****     // for the specified PWM generators.
1415:C:/StellarisWare/driverlib\pwm.c ****     //
1416:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_INTEN) |= ulGenFault;
 1438              		.loc 1 1416 0
 1439 000a 7B68     		ldr	r3, [r7, #4]
 1440 000c 03F11403 		add	r3, r3, #20
 1441 0010 7A68     		ldr	r2, [r7, #4]
 1442 0012 02F11402 		add	r2, r2, #20
 1443 0016 1168     		ldr	r1, [r2, #0]
 1444 0018 3A68     		ldr	r2, [r7, #0]
 1445 001a 0A43     		orrs	r2, r2, r1
 1446 001c 1A60     		str	r2, [r3, #0]
1417:C:/StellarisWare/driverlib\pwm.c **** }
 1447              		.loc 1 1417 0
 1448 001e 07F10C07 		add	r7, r7, #12
 1449 0022 BD46     		mov	sp, r7
 1450 0024 80BC     		pop	{r7}
 1451 0026 7047     		bx	lr
 1452              		.cfi_endproc
 1453              	.LFE25:
 1455              		.section	.text.PWMIntDisable,"ax",%progbits
 1456              		.align	2
 1457              		.global	PWMIntDisable
 1458              		.thumb
 1459              		.thumb_func
 1461              	PWMIntDisable:
 1462              	.LFB26:
1418:C:/StellarisWare/driverlib\pwm.c **** 
1419:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1420:C:/StellarisWare/driverlib\pwm.c **** //
1421:C:/StellarisWare/driverlib\pwm.c **** //! Disables generator and fault interrupts for a PWM module.
1422:C:/StellarisWare/driverlib\pwm.c **** //!
1423:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1424:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGenFault contains the interrupts to be disabled.  This parameter
1425:C:/StellarisWare/driverlib\pwm.c **** //! must be a logical OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1,
1426:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_GEN_2, \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1,
1427:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.
1428:C:/StellarisWare/driverlib\pwm.c **** //!
1429:C:/StellarisWare/driverlib\pwm.c **** //! This function masks the specified interrupt(s) by clearing the specified
1430:C:/StellarisWare/driverlib\pwm.c **** //! bits of the interrupt enable register for the selected PWM module.
1431:C:/StellarisWare/driverlib\pwm.c **** //!
1432:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1433:C:/StellarisWare/driverlib\pwm.c **** //
1434:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1435:C:/StellarisWare/driverlib\pwm.c **** void
1436:C:/StellarisWare/driverlib\pwm.c **** PWMIntDisable(unsigned long ulBase, unsigned long ulGenFault)
1437:C:/StellarisWare/driverlib\pwm.c **** {
 1463              		.loc 1 1437 0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 8
 1466              		@ frame_needed = 1, uses_anonymous_args = 0
 1467              		@ link register save eliminated.
 1468 0000 80B4     		push	{r7}
 1469              	.LCFI78:
 1470              		.cfi_def_cfa_offset 4
 1471              		.cfi_offset 7, -4
 1472 0002 83B0     		sub	sp, sp, #12
 1473              	.LCFI79:
 1474              		.cfi_def_cfa_offset 16
 1475 0004 00AF     		add	r7, sp, #0
 1476              	.LCFI80:
 1477              		.cfi_def_cfa_register 7
 1478 0006 7860     		str	r0, [r7, #4]
 1479 0008 3960     		str	r1, [r7, #0]
1438:C:/StellarisWare/driverlib\pwm.c ****     //
1439:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1440:C:/StellarisWare/driverlib\pwm.c ****     //
1441:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1442:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGenFault & ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
1443:C:/StellarisWare/driverlib\pwm.c ****                            PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
1444:C:/StellarisWare/driverlib\pwm.c ****                            PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
1445:C:/StellarisWare/driverlib\pwm.c **** 
1446:C:/StellarisWare/driverlib\pwm.c ****     //
1447:C:/StellarisWare/driverlib\pwm.c ****     // Read the module's interrupt enable register and disable interrupts
1448:C:/StellarisWare/driverlib\pwm.c ****     // for the specified PWM generators.
1449:C:/StellarisWare/driverlib\pwm.c ****     //
1450:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_INTEN) &= ~(ulGenFault);
 1480              		.loc 1 1450 0
 1481 000a 7B68     		ldr	r3, [r7, #4]
 1482 000c 03F11403 		add	r3, r3, #20
 1483 0010 7A68     		ldr	r2, [r7, #4]
 1484 0012 02F11402 		add	r2, r2, #20
 1485 0016 1168     		ldr	r1, [r2, #0]
 1486 0018 3A68     		ldr	r2, [r7, #0]
 1487 001a 6FEA0202 		mvn	r2, r2
 1488 001e 0A40     		ands	r2, r2, r1
 1489 0020 1A60     		str	r2, [r3, #0]
1451:C:/StellarisWare/driverlib\pwm.c **** }
 1490              		.loc 1 1451 0
 1491 0022 07F10C07 		add	r7, r7, #12
 1492 0026 BD46     		mov	sp, r7
 1493 0028 80BC     		pop	{r7}
 1494 002a 7047     		bx	lr
 1495              		.cfi_endproc
 1496              	.LFE26:
 1498              		.section	.text.PWMFaultIntClear,"ax",%progbits
 1499              		.align	2
 1500              		.global	PWMFaultIntClear
 1501              		.thumb
 1502              		.thumb_func
 1504              	PWMFaultIntClear:
 1505              	.LFB27:
1452:C:/StellarisWare/driverlib\pwm.c **** 
1453:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1454:C:/StellarisWare/driverlib\pwm.c **** //
1455:C:/StellarisWare/driverlib\pwm.c **** //! Clears the fault interrupt for a PWM module.
1456:C:/StellarisWare/driverlib\pwm.c **** //!
1457:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1458:C:/StellarisWare/driverlib\pwm.c **** //!
1459:C:/StellarisWare/driverlib\pwm.c **** //! This function clears the fault interrupt by writing to the appropriate bit
1460:C:/StellarisWare/driverlib\pwm.c **** //! of the interrupt status register for the selected PWM module.
1461:C:/StellarisWare/driverlib\pwm.c **** //!
1462:C:/StellarisWare/driverlib\pwm.c **** //! This function clears only the FAULT0 interrupt and is retained for
1463:C:/StellarisWare/driverlib\pwm.c **** //! backwards compatibility.  It is recommended that PWMFaultIntClearExt() be
1464:C:/StellarisWare/driverlib\pwm.c **** //! used instead because it supports all fault interrupts supported on devices
1465:C:/StellarisWare/driverlib\pwm.c **** //! with and without extended PWM fault handling support.
1466:C:/StellarisWare/driverlib\pwm.c **** //!
1467:C:/StellarisWare/driverlib\pwm.c **** //! \note Because there is a write buffer in the Cortex-M processor, it may
1468:C:/StellarisWare/driverlib\pwm.c **** //! take several clock cycles before the interrupt source is actually cleared.
1469:C:/StellarisWare/driverlib\pwm.c **** //! Therefore, it is recommended that the interrupt source be cleared early in
1470:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt handler (as opposed to the very last action) to avoid
1471:C:/StellarisWare/driverlib\pwm.c **** //! returning from the interrupt handler before the interrupt source is
1472:C:/StellarisWare/driverlib\pwm.c **** //! actually cleared.  Failure to do so may result in the interrupt handler
1473:C:/StellarisWare/driverlib\pwm.c **** //! being immediately reentered (because the interrupt controller still sees
1474:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt source asserted).
1475:C:/StellarisWare/driverlib\pwm.c **** //!
1476:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1477:C:/StellarisWare/driverlib\pwm.c **** //
1478:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1479:C:/StellarisWare/driverlib\pwm.c **** void
1480:C:/StellarisWare/driverlib\pwm.c **** PWMFaultIntClear(unsigned long ulBase)
1481:C:/StellarisWare/driverlib\pwm.c **** {
 1506              		.loc 1 1481 0
 1507              		.cfi_startproc
 1508              		@ args = 0, pretend = 0, frame = 8
 1509              		@ frame_needed = 1, uses_anonymous_args = 0
 1510              		@ link register save eliminated.
 1511 0000 80B4     		push	{r7}
 1512              	.LCFI81:
 1513              		.cfi_def_cfa_offset 4
 1514              		.cfi_offset 7, -4
 1515 0002 83B0     		sub	sp, sp, #12
 1516              	.LCFI82:
 1517              		.cfi_def_cfa_offset 16
 1518 0004 00AF     		add	r7, sp, #0
 1519              	.LCFI83:
 1520              		.cfi_def_cfa_register 7
 1521 0006 7860     		str	r0, [r7, #4]
1482:C:/StellarisWare/driverlib\pwm.c ****     //
1483:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1484:C:/StellarisWare/driverlib\pwm.c ****     //
1485:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1486:C:/StellarisWare/driverlib\pwm.c **** 
1487:C:/StellarisWare/driverlib\pwm.c ****     //
1488:C:/StellarisWare/driverlib\pwm.c ****     // Write the only writeable bit in the module's interrupt register.
1489:C:/StellarisWare/driverlib\pwm.c ****     //
1490:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_ISC) = PWM_ISC_INTFAULT0;
 1522              		.loc 1 1490 0
 1523 0008 7B68     		ldr	r3, [r7, #4]
 1524 000a 03F11C03 		add	r3, r3, #28
 1525 000e 4FF48032 		mov	r2, #65536
 1526 0012 1A60     		str	r2, [r3, #0]
1491:C:/StellarisWare/driverlib\pwm.c **** }
 1527              		.loc 1 1491 0
 1528 0014 07F10C07 		add	r7, r7, #12
 1529 0018 BD46     		mov	sp, r7
 1530 001a 80BC     		pop	{r7}
 1531 001c 7047     		bx	lr
 1532              		.cfi_endproc
 1533              	.LFE27:
 1535 001e 00BF     		.section	.text.PWMIntStatus,"ax",%progbits
 1536              		.align	2
 1537              		.global	PWMIntStatus
 1538              		.thumb
 1539              		.thumb_func
 1541              	PWMIntStatus:
 1542              	.LFB28:
1492:C:/StellarisWare/driverlib\pwm.c **** 
1493:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1494:C:/StellarisWare/driverlib\pwm.c **** //
1495:C:/StellarisWare/driverlib\pwm.c **** //! Gets the interrupt status for a PWM module.
1496:C:/StellarisWare/driverlib\pwm.c **** //!
1497:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1498:C:/StellarisWare/driverlib\pwm.c **** //! \param bMasked specifies whether masked or raw interrupt status is
1499:C:/StellarisWare/driverlib\pwm.c **** //! returned.
1500:C:/StellarisWare/driverlib\pwm.c **** //!
1501:C:/StellarisWare/driverlib\pwm.c **** //! If \e bMasked is set as \b true, then the masked interrupt status is
1502:C:/StellarisWare/driverlib\pwm.c **** //! returned; otherwise, the raw interrupt status is returned.
1503:C:/StellarisWare/driverlib\pwm.c **** //!
1504:C:/StellarisWare/driverlib\pwm.c **** //! \return The current interrupt status, enumerated as a bit field of
1505:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2, \b PWM_INT_GEN_3,
1506:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, and
1507:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_FAULT3.
1508:C:/StellarisWare/driverlib\pwm.c **** //!
1509:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1510:C:/StellarisWare/driverlib\pwm.c **** unsigned long
1511:C:/StellarisWare/driverlib\pwm.c **** PWMIntStatus(unsigned long ulBase, tBoolean bMasked)
1512:C:/StellarisWare/driverlib\pwm.c **** {
 1543              		.loc 1 1512 0
 1544              		.cfi_startproc
 1545              		@ args = 0, pretend = 0, frame = 8
 1546              		@ frame_needed = 1, uses_anonymous_args = 0
 1547              		@ link register save eliminated.
 1548 0000 80B4     		push	{r7}
 1549              	.LCFI84:
 1550              		.cfi_def_cfa_offset 4
 1551              		.cfi_offset 7, -4
 1552 0002 83B0     		sub	sp, sp, #12
 1553              	.LCFI85:
 1554              		.cfi_def_cfa_offset 16
 1555 0004 00AF     		add	r7, sp, #0
 1556              	.LCFI86:
 1557              		.cfi_def_cfa_register 7
 1558 0006 7860     		str	r0, [r7, #4]
 1559 0008 0B46     		mov	r3, r1
 1560 000a FB70     		strb	r3, [r7, #3]
1513:C:/StellarisWare/driverlib\pwm.c ****     //
1514:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1515:C:/StellarisWare/driverlib\pwm.c ****     //
1516:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1517:C:/StellarisWare/driverlib\pwm.c **** 
1518:C:/StellarisWare/driverlib\pwm.c ****     //
1519:C:/StellarisWare/driverlib\pwm.c ****     // Read and return either the module's raw or enabled interrupt status.
1520:C:/StellarisWare/driverlib\pwm.c ****     //
1521:C:/StellarisWare/driverlib\pwm.c ****     if(bMasked == true)
 1561              		.loc 1 1521 0
 1562 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1563 000e 012B     		cmp	r3, #1
 1564 0010 04D1     		bne	.L66
1522:C:/StellarisWare/driverlib\pwm.c ****     {
1523:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulBase + PWM_O_ISC));
 1565              		.loc 1 1523 0
 1566 0012 7B68     		ldr	r3, [r7, #4]
 1567 0014 03F11C03 		add	r3, r3, #28
 1568 0018 1B68     		ldr	r3, [r3, #0]
 1569 001a 03E0     		b	.L67
 1570              	.L66:
1524:C:/StellarisWare/driverlib\pwm.c ****     }
1525:C:/StellarisWare/driverlib\pwm.c ****     else
1526:C:/StellarisWare/driverlib\pwm.c ****     {
1527:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(ulBase + PWM_O_RIS));
 1571              		.loc 1 1527 0
 1572 001c 7B68     		ldr	r3, [r7, #4]
 1573 001e 03F11803 		add	r3, r3, #24
 1574 0022 1B68     		ldr	r3, [r3, #0]
 1575              	.L67:
1528:C:/StellarisWare/driverlib\pwm.c ****     }
1529:C:/StellarisWare/driverlib\pwm.c **** }
 1576              		.loc 1 1529 0
 1577 0024 1846     		mov	r0, r3
 1578 0026 07F10C07 		add	r7, r7, #12
 1579 002a BD46     		mov	sp, r7
 1580 002c 80BC     		pop	{r7}
 1581 002e 7047     		bx	lr
 1582              		.cfi_endproc
 1583              	.LFE28:
 1585              		.section	.text.PWMFaultIntClearExt,"ax",%progbits
 1586              		.align	2
 1587              		.global	PWMFaultIntClearExt
 1588              		.thumb
 1589              		.thumb_func
 1591              	PWMFaultIntClearExt:
 1592              	.LFB29:
1530:C:/StellarisWare/driverlib\pwm.c **** 
1531:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1532:C:/StellarisWare/driverlib\pwm.c **** //
1533:C:/StellarisWare/driverlib\pwm.c **** //! Clears the fault interrupt for a PWM module.
1534:C:/StellarisWare/driverlib\pwm.c **** //!
1535:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1536:C:/StellarisWare/driverlib\pwm.c **** //! \param ulFaultInts specifies the fault interrupts to clear.
1537:C:/StellarisWare/driverlib\pwm.c **** //!
1538:C:/StellarisWare/driverlib\pwm.c **** //! This function clears one or more fault interrupts by writing to the
1539:C:/StellarisWare/driverlib\pwm.c **** //!  appropriate bit of the PWM interrupt status register.  The parameter
1540:C:/StellarisWare/driverlib\pwm.c **** //! \e ulFaultInts must be the logical OR of any of \b PWM_INT_FAULT0,
1541:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.
1542:C:/StellarisWare/driverlib\pwm.c **** //!
1543:C:/StellarisWare/driverlib\pwm.c **** //! When running on a device supporting extended PWM fault handling, the fault
1544:C:/StellarisWare/driverlib\pwm.c **** //! interrupts are derived by performing a logical OR of each of the configured
1545:C:/StellarisWare/driverlib\pwm.c **** //! fault trigger signals for a given generator.  Therefore, these interrupts
1546:C:/StellarisWare/driverlib\pwm.c **** //! are not directly related to the four possible FAULTn inputs to the device
1547:C:/StellarisWare/driverlib\pwm.c **** //! but indicate that a fault has been signaled to one of the four possible PWM
1548:C:/StellarisWare/driverlib\pwm.c **** //! generators.  On a device without extended PWM fault handling, the interrupt
1549:C:/StellarisWare/driverlib\pwm.c **** //! is directly related to the state of the single FAULT pin.
1550:C:/StellarisWare/driverlib\pwm.c **** //!
1551:C:/StellarisWare/driverlib\pwm.c **** //! \note Because there is a write buffer in the Cortex-M processor, it may
1552:C:/StellarisWare/driverlib\pwm.c **** //! take several clock cycles before the interrupt source is actually cleared.
1553:C:/StellarisWare/driverlib\pwm.c **** //! Therefore, it is recommended that the interrupt source be cleared early in
1554:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt handler (as opposed to the very last action) to avoid
1555:C:/StellarisWare/driverlib\pwm.c **** //! returning from the interrupt handler before the interrupt source is
1556:C:/StellarisWare/driverlib\pwm.c **** //! actually cleared.  Failure to do so may result in the interrupt handler
1557:C:/StellarisWare/driverlib\pwm.c **** //! being immediately reentered (because the interrupt controller still sees
1558:C:/StellarisWare/driverlib\pwm.c **** //! the interrupt source asserted).
1559:C:/StellarisWare/driverlib\pwm.c **** //!
1560:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1561:C:/StellarisWare/driverlib\pwm.c **** //
1562:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1563:C:/StellarisWare/driverlib\pwm.c **** void
1564:C:/StellarisWare/driverlib\pwm.c **** PWMFaultIntClearExt(unsigned long ulBase, unsigned long ulFaultInts)
1565:C:/StellarisWare/driverlib\pwm.c **** {
 1593              		.loc 1 1565 0
 1594              		.cfi_startproc
 1595              		@ args = 0, pretend = 0, frame = 8
 1596              		@ frame_needed = 1, uses_anonymous_args = 0
 1597              		@ link register save eliminated.
 1598 0000 80B4     		push	{r7}
 1599              	.LCFI87:
 1600              		.cfi_def_cfa_offset 4
 1601              		.cfi_offset 7, -4
 1602 0002 83B0     		sub	sp, sp, #12
 1603              	.LCFI88:
 1604              		.cfi_def_cfa_offset 16
 1605 0004 00AF     		add	r7, sp, #0
 1606              	.LCFI89:
 1607              		.cfi_def_cfa_register 7
 1608 0006 7860     		str	r0, [r7, #4]
 1609 0008 3960     		str	r1, [r7, #0]
1566:C:/StellarisWare/driverlib\pwm.c ****     //
1567:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1568:C:/StellarisWare/driverlib\pwm.c ****     //
1569:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1570:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulFaultInts & ~(PWM_INT_FAULT0 | PWM_INT_FAULT1 |
1571:C:/StellarisWare/driverlib\pwm.c ****                             PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
1572:C:/StellarisWare/driverlib\pwm.c **** 
1573:C:/StellarisWare/driverlib\pwm.c ****     //
1574:C:/StellarisWare/driverlib\pwm.c ****     // Clear the supplied fault bits.
1575:C:/StellarisWare/driverlib\pwm.c ****     //
1576:C:/StellarisWare/driverlib\pwm.c ****     HWREG(ulBase + PWM_O_ISC) = ulFaultInts;
 1610              		.loc 1 1576 0
 1611 000a 7B68     		ldr	r3, [r7, #4]
 1612 000c 03F11C03 		add	r3, r3, #28
 1613 0010 3A68     		ldr	r2, [r7, #0]
 1614 0012 1A60     		str	r2, [r3, #0]
1577:C:/StellarisWare/driverlib\pwm.c **** }
 1615              		.loc 1 1577 0
 1616 0014 07F10C07 		add	r7, r7, #12
 1617 0018 BD46     		mov	sp, r7
 1618 001a 80BC     		pop	{r7}
 1619 001c 7047     		bx	lr
 1620              		.cfi_endproc
 1621              	.LFE29:
 1623 001e 00BF     		.section	.text.PWMGenFaultConfigure,"ax",%progbits
 1624              		.align	2
 1625              		.global	PWMGenFaultConfigure
 1626              		.thumb
 1627              		.thumb_func
 1629              	PWMGenFaultConfigure:
 1630              	.LFB30:
1578:C:/StellarisWare/driverlib\pwm.c **** 
1579:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1580:C:/StellarisWare/driverlib\pwm.c **** //
1581:C:/StellarisWare/driverlib\pwm.c **** //! Configures the minimum fault period and fault pin senses for a given
1582:C:/StellarisWare/driverlib\pwm.c **** //! PWM generator.
1583:C:/StellarisWare/driverlib\pwm.c **** //!
1584:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1585:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator for which fault configuration is being
1586:C:/StellarisWare/driverlib\pwm.c **** //! set. This function must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2,
1587:C:/StellarisWare/driverlib\pwm.c **** //! or \b PWM_GEN_3.
1588:C:/StellarisWare/driverlib\pwm.c **** //! \param ulMinFaultPeriod is the minimum fault active period expressed in
1589:C:/StellarisWare/driverlib\pwm.c **** //! PWM clock cycles.
1590:C:/StellarisWare/driverlib\pwm.c **** //! \param ulFaultSenses indicates which sense of each FAULT input should be
1591:C:/StellarisWare/driverlib\pwm.c **** //! considered the ``asserted'' state.  Valid values are logical OR
1592:C:/StellarisWare/driverlib\pwm.c **** //! combinations of \b PWM_FAULTn_SENSE_HIGH and \b PWM_FAULTn_SENSE_LOW.
1593:C:/StellarisWare/driverlib\pwm.c **** //!
1594:C:/StellarisWare/driverlib\pwm.c **** //! This function configures the minimum fault period for a given generator
1595:C:/StellarisWare/driverlib\pwm.c **** //! along with the sense of each of the 4 possible fault inputs.  The minimum
1596:C:/StellarisWare/driverlib\pwm.c **** //! fault period is expressed in PWM clock cycles and takes effect only if
1597:C:/StellarisWare/driverlib\pwm.c **** //! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_PER set in the
1598:C:/StellarisWare/driverlib\pwm.c **** //! \e ulConfig parameter.  When a fault input is asserted, the minimum fault
1599:C:/StellarisWare/driverlib\pwm.c **** //! period timer ensures that it remains asserted for at least the number of
1600:C:/StellarisWare/driverlib\pwm.c **** //! clock cycles specified.
1601:C:/StellarisWare/driverlib\pwm.c **** //!
1602:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is only available on devices supporting extended PWM
1603:C:/StellarisWare/driverlib\pwm.c **** //! fault handling.
1604:C:/StellarisWare/driverlib\pwm.c **** //!
1605:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1606:C:/StellarisWare/driverlib\pwm.c **** //
1607:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1608:C:/StellarisWare/driverlib\pwm.c **** void
1609:C:/StellarisWare/driverlib\pwm.c **** PWMGenFaultConfigure(unsigned long ulBase, unsigned long ulGen,
1610:C:/StellarisWare/driverlib\pwm.c ****                      unsigned long ulMinFaultPeriod,
1611:C:/StellarisWare/driverlib\pwm.c ****                      unsigned long ulFaultSenses)
1612:C:/StellarisWare/driverlib\pwm.c **** {
 1631              		.loc 1 1612 0
 1632              		.cfi_startproc
 1633              		@ args = 0, pretend = 0, frame = 16
 1634              		@ frame_needed = 1, uses_anonymous_args = 0
 1635              		@ link register save eliminated.
 1636 0000 80B4     		push	{r7}
 1637              	.LCFI90:
 1638              		.cfi_def_cfa_offset 4
 1639              		.cfi_offset 7, -4
 1640 0002 85B0     		sub	sp, sp, #20
 1641              	.LCFI91:
 1642              		.cfi_def_cfa_offset 24
 1643 0004 00AF     		add	r7, sp, #0
 1644              	.LCFI92:
 1645              		.cfi_def_cfa_register 7
 1646 0006 F860     		str	r0, [r7, #12]
 1647 0008 B960     		str	r1, [r7, #8]
 1648 000a 7A60     		str	r2, [r7, #4]
 1649 000c 3B60     		str	r3, [r7, #0]
1613:C:/StellarisWare/driverlib\pwm.c ****     //
1614:C:/StellarisWare/driverlib\pwm.c ****     // Check the arguments.
1615:C:/StellarisWare/driverlib\pwm.c ****     //
1616:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1617:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1618:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(ulMinFaultPeriod < PWM_X_MINFLTPER_M);
1619:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulFaultSenses & ~(PWM_FAULT0_SENSE_HIGH | PWM_FAULT0_SENSE_LOW |
1620:C:/StellarisWare/driverlib\pwm.c ****                               PWM_FAULT1_SENSE_HIGH | PWM_FAULT1_SENSE_LOW |
1621:C:/StellarisWare/driverlib\pwm.c ****                               PWM_FAULT2_SENSE_HIGH | PWM_FAULT2_SENSE_LOW |
1622:C:/StellarisWare/driverlib\pwm.c ****                               PWM_FAULT3_SENSE_HIGH | PWM_FAULT3_SENSE_LOW)) ==
1623:C:/StellarisWare/driverlib\pwm.c ****            0);
1624:C:/StellarisWare/driverlib\pwm.c **** 
1625:C:/StellarisWare/driverlib\pwm.c ****     //
1626:C:/StellarisWare/driverlib\pwm.c ****     // Write the minimum fault period.
1627:C:/StellarisWare/driverlib\pwm.c ****     //
1628:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_MINFLTPER) = ulMinFaultPeriod;
 1650              		.loc 1 1628 0
 1651 000e FA68     		ldr	r2, [r7, #12]
 1652 0010 BB68     		ldr	r3, [r7, #8]
 1653 0012 D318     		adds	r3, r2, r3
 1654 0014 03F13C03 		add	r3, r3, #60
 1655 0018 7A68     		ldr	r2, [r7, #4]
 1656 001a 1A60     		str	r2, [r3, #0]
1629:C:/StellarisWare/driverlib\pwm.c **** 
1630:C:/StellarisWare/driverlib\pwm.c ****     //
1631:C:/StellarisWare/driverlib\pwm.c ****     // Write the fault senses.
1632:C:/StellarisWare/driverlib\pwm.c ****     //
1633:C:/StellarisWare/driverlib\pwm.c ****     HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSEN) = ulFaultSenses;
 1657              		.loc 1 1633 0
 1658 001c BB68     		ldr	r3, [r7, #8]
 1659 001e 03F10043 		add	r3, r3, #-2147483648
 1660 0022 A3F14003 		sub	r3, r3, #64
 1661 0026 4FEA4302 		lsl	r2, r3, #1
 1662 002a FB68     		ldr	r3, [r7, #12]
 1663 002c D318     		adds	r3, r2, r3
 1664 002e 03F50063 		add	r3, r3, #2048
 1665 0032 3A68     		ldr	r2, [r7, #0]
 1666 0034 1A60     		str	r2, [r3, #0]
1634:C:/StellarisWare/driverlib\pwm.c **** }
 1667              		.loc 1 1634 0
 1668 0036 07F11407 		add	r7, r7, #20
 1669 003a BD46     		mov	sp, r7
 1670 003c 80BC     		pop	{r7}
 1671 003e 7047     		bx	lr
 1672              		.cfi_endproc
 1673              	.LFE30:
 1675              		.section	.text.PWMGenFaultTriggerSet,"ax",%progbits
 1676              		.align	2
 1677              		.global	PWMGenFaultTriggerSet
 1678              		.thumb
 1679              		.thumb_func
 1681              	PWMGenFaultTriggerSet:
 1682              	.LFB31:
1635:C:/StellarisWare/driverlib\pwm.c **** 
1636:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1637:C:/StellarisWare/driverlib\pwm.c **** //
1638:C:/StellarisWare/driverlib\pwm.c **** //! Configures the set of fault triggers for a given PWM generator.
1639:C:/StellarisWare/driverlib\pwm.c **** //!
1640:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1641:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator for which fault triggers are being set.
1642:C:/StellarisWare/driverlib\pwm.c **** //! This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
1643:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_3.
1644:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGroup indicates the subset of possible faults that are to be
1645:C:/StellarisWare/driverlib\pwm.c **** //! configured.  This parameter must be \b PWM_FAULT_GROUP_0 or
1646:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_GROUP_1.
1647:C:/StellarisWare/driverlib\pwm.c **** //! \param ulFaultTriggers defines the set of inputs that are to contribute
1648:C:/StellarisWare/driverlib\pwm.c **** //! towards generation of the fault signal to the given PWM generator.  For
1649:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_GROUP_0, this is the logical OR of \b PWM_FAULT_FAULT0,
1650:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or \b PWM_FAULT_FAULT3.  For
1651:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_GROUP_1, this is the logical OR of \b PWM_FAULT_DCMP0,
1652:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP1, \b PWM_FAULT_DCMP2, \b PWM_FAULT_DCMP3,
1653:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP4, \b PWM_FAULT_DCMP5, \b PWM_FAULT_DCMP6, or
1654:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP7.
1655:C:/StellarisWare/driverlib\pwm.c **** //!
1656:C:/StellarisWare/driverlib\pwm.c **** //! This function allows selection of the set of fault inputs that is combined
1657:C:/StellarisWare/driverlib\pwm.c **** //! to generate a fault condition to a given PWM generator.  By default, all
1658:C:/StellarisWare/driverlib\pwm.c **** //! generators use only FAULT0 (for backwards compatibility) but if
1659:C:/StellarisWare/driverlib\pwm.c **** //! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_SRC in the
1660:C:/StellarisWare/driverlib\pwm.c **** //! \e ulConfig parameter, extended fault handling is enabled and this function
1661:C:/StellarisWare/driverlib\pwm.c **** //! must be called to configure the fault triggers.
1662:C:/StellarisWare/driverlib\pwm.c **** //!
1663:C:/StellarisWare/driverlib\pwm.c **** //! The fault signal to the PWM generator is generated by ORing together each
1664:C:/StellarisWare/driverlib\pwm.c **** //! of the signals specified in the \e ulFaultTriggers parameter after having
1665:C:/StellarisWare/driverlib\pwm.c **** //! adjusted the sense of each FAULTn input based on the configuration
1666:C:/StellarisWare/driverlib\pwm.c **** //! previously set using a call to PWMGenFaultConfigure().
1667:C:/StellarisWare/driverlib\pwm.c **** //!
1668:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is only available on devices supporting extended PWM
1669:C:/StellarisWare/driverlib\pwm.c **** //! fault handling.
1670:C:/StellarisWare/driverlib\pwm.c **** //!
1671:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1672:C:/StellarisWare/driverlib\pwm.c **** //
1673:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1674:C:/StellarisWare/driverlib\pwm.c **** void
1675:C:/StellarisWare/driverlib\pwm.c **** PWMGenFaultTriggerSet(unsigned long ulBase, unsigned long ulGen,
1676:C:/StellarisWare/driverlib\pwm.c ****                       unsigned long ulGroup, unsigned long ulFaultTriggers)
1677:C:/StellarisWare/driverlib\pwm.c **** {
 1683              		.loc 1 1677 0
 1684              		.cfi_startproc
 1685              		@ args = 0, pretend = 0, frame = 16
 1686              		@ frame_needed = 1, uses_anonymous_args = 0
 1687              		@ link register save eliminated.
 1688 0000 80B4     		push	{r7}
 1689              	.LCFI93:
 1690              		.cfi_def_cfa_offset 4
 1691              		.cfi_offset 7, -4
 1692 0002 85B0     		sub	sp, sp, #20
 1693              	.LCFI94:
 1694              		.cfi_def_cfa_offset 24
 1695 0004 00AF     		add	r7, sp, #0
 1696              	.LCFI95:
 1697              		.cfi_def_cfa_register 7
 1698 0006 F860     		str	r0, [r7, #12]
 1699 0008 B960     		str	r1, [r7, #8]
 1700 000a 7A60     		str	r2, [r7, #4]
 1701 000c 3B60     		str	r3, [r7, #0]
1678:C:/StellarisWare/driverlib\pwm.c ****     //
1679:C:/StellarisWare/driverlib\pwm.c ****     // Check for valid parameters.
1680:C:/StellarisWare/driverlib\pwm.c ****     //
1681:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1682:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1683:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
1684:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) &&
1685:C:/StellarisWare/driverlib\pwm.c ****            ((ulFaultTriggers & ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
1686:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0));
1687:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_1) &&
1688:C:/StellarisWare/driverlib\pwm.c ****            ((ulFaultTriggers & ~(PWM_FAULT_DCMP0 | PWM_FAULT_DCMP1 |
1689:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP2 | PWM_FAULT_DCMP3 |
1690:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP4 | PWM_FAULT_DCMP5 |
1691:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP6 | PWM_FAULT_DCMP7)) == 0));
1692:C:/StellarisWare/driverlib\pwm.c **** 
1693:C:/StellarisWare/driverlib\pwm.c ****     //
1694:C:/StellarisWare/driverlib\pwm.c ****     // Write the fault triggers to the appropriate register.
1695:C:/StellarisWare/driverlib\pwm.c ****     //
1696:C:/StellarisWare/driverlib\pwm.c ****     if(ulGroup == PWM_FAULT_GROUP_0)
 1702              		.loc 1 1696 0
 1703 000e 7B68     		ldr	r3, [r7, #4]
 1704 0010 002B     		cmp	r3, #0
 1705 0012 07D1     		bne	.L71
1697:C:/StellarisWare/driverlib\pwm.c ****     {
1698:C:/StellarisWare/driverlib\pwm.c ****         HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0) =
 1706              		.loc 1 1698 0
 1707 0014 FA68     		ldr	r2, [r7, #12]
 1708 0016 BB68     		ldr	r3, [r7, #8]
 1709 0018 D318     		adds	r3, r2, r3
 1710 001a 03F13403 		add	r3, r3, #52
 1711 001e 3A68     		ldr	r2, [r7, #0]
 1712 0020 1A60     		str	r2, [r3, #0]
 1713 0022 06E0     		b	.L70
 1714              	.L71:
1699:C:/StellarisWare/driverlib\pwm.c ****             ulFaultTriggers;
1700:C:/StellarisWare/driverlib\pwm.c ****     }
1701:C:/StellarisWare/driverlib\pwm.c ****     else
1702:C:/StellarisWare/driverlib\pwm.c ****     {
1703:C:/StellarisWare/driverlib\pwm.c ****         HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC1) =
 1715              		.loc 1 1703 0
 1716 0024 FA68     		ldr	r2, [r7, #12]
 1717 0026 BB68     		ldr	r3, [r7, #8]
 1718 0028 D318     		adds	r3, r2, r3
 1719 002a 03F13803 		add	r3, r3, #56
 1720 002e 3A68     		ldr	r2, [r7, #0]
 1721 0030 1A60     		str	r2, [r3, #0]
 1722              	.L70:
1704:C:/StellarisWare/driverlib\pwm.c ****             ulFaultTriggers;
1705:C:/StellarisWare/driverlib\pwm.c ****     }
1706:C:/StellarisWare/driverlib\pwm.c **** }
 1723              		.loc 1 1706 0
 1724 0032 07F11407 		add	r7, r7, #20
 1725 0036 BD46     		mov	sp, r7
 1726 0038 80BC     		pop	{r7}
 1727 003a 7047     		bx	lr
 1728              		.cfi_endproc
 1729              	.LFE31:
 1731              		.section	.text.PWMGenFaultTriggerGet,"ax",%progbits
 1732              		.align	2
 1733              		.global	PWMGenFaultTriggerGet
 1734              		.thumb
 1735              		.thumb_func
 1737              	PWMGenFaultTriggerGet:
 1738              	.LFB32:
1707:C:/StellarisWare/driverlib\pwm.c **** 
1708:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1709:C:/StellarisWare/driverlib\pwm.c **** //
1710:C:/StellarisWare/driverlib\pwm.c **** //! Returns the set of fault triggers currently configured for a given PWM
1711:C:/StellarisWare/driverlib\pwm.c **** //! generator.
1712:C:/StellarisWare/driverlib\pwm.c **** //!
1713:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1714:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator for which fault triggers are being
1715:C:/StellarisWare/driverlib\pwm.c **** //! queried. This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,
1716:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_2, or \b PWM_GEN_3.
1717:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGroup indicates the subset of faults that are being queried.  This
1718:C:/StellarisWare/driverlib\pwm.c **** //! parameter must be \b PWM_FAULT_GROUP_0 or \b PWM_FAULT_GROUP_1.
1719:C:/StellarisWare/driverlib\pwm.c **** //!
1720:C:/StellarisWare/driverlib\pwm.c **** //! This function allows an application to query the current set of inputs that
1721:C:/StellarisWare/driverlib\pwm.c **** //! contribute to the generation of a fault condition to a given PWM generator.
1722:C:/StellarisWare/driverlib\pwm.c **** //!
1723:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is only available on devices supporting extended PWM
1724:C:/StellarisWare/driverlib\pwm.c **** //! fault handling.
1725:C:/StellarisWare/driverlib\pwm.c **** //!
1726:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the current fault triggers configured for the fault group
1727:C:/StellarisWare/driverlib\pwm.c **** //! provided.  For \b PWM_FAULT_GROUP_0, the returned value is a logical OR of
1728:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
1729:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_FAULT3.  For \b PWM_FAULT_GROUP_1, the return value is the
1730:C:/StellarisWare/driverlib\pwm.c **** //! logical OR of \b PWM_FAULT_DCMP0, \b PWM_FAULT_DCMP1,
1731:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP2, \b PWM_FAULT_DCMP3, \b PWM_FAULT_DCMP4,
1732:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP5, \b PWM_FAULT_DCMP6, or \b PWM_FAULT_DCMP7.
1733:C:/StellarisWare/driverlib\pwm.c **** //
1734:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1735:C:/StellarisWare/driverlib\pwm.c **** unsigned long
1736:C:/StellarisWare/driverlib\pwm.c **** PWMGenFaultTriggerGet(unsigned long ulBase, unsigned long ulGen,
1737:C:/StellarisWare/driverlib\pwm.c ****                       unsigned long ulGroup)
1738:C:/StellarisWare/driverlib\pwm.c **** {
 1739              		.loc 1 1738 0
 1740              		.cfi_startproc
 1741              		@ args = 0, pretend = 0, frame = 16
 1742              		@ frame_needed = 1, uses_anonymous_args = 0
 1743              		@ link register save eliminated.
 1744 0000 80B4     		push	{r7}
 1745              	.LCFI96:
 1746              		.cfi_def_cfa_offset 4
 1747              		.cfi_offset 7, -4
 1748 0002 85B0     		sub	sp, sp, #20
 1749              	.LCFI97:
 1750              		.cfi_def_cfa_offset 24
 1751 0004 00AF     		add	r7, sp, #0
 1752              	.LCFI98:
 1753              		.cfi_def_cfa_register 7
 1754 0006 F860     		str	r0, [r7, #12]
 1755 0008 B960     		str	r1, [r7, #8]
 1756 000a 7A60     		str	r2, [r7, #4]
1739:C:/StellarisWare/driverlib\pwm.c ****     //
1740:C:/StellarisWare/driverlib\pwm.c ****     // Check for valid parameters.
1741:C:/StellarisWare/driverlib\pwm.c ****     //
1742:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1743:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1744:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
1745:C:/StellarisWare/driverlib\pwm.c **** 
1746:C:/StellarisWare/driverlib\pwm.c ****     //
1747:C:/StellarisWare/driverlib\pwm.c ****     // Return the current fault triggers.
1748:C:/StellarisWare/driverlib\pwm.c ****     //
1749:C:/StellarisWare/driverlib\pwm.c ****     if(ulGroup == PWM_FAULT_GROUP_0)
 1757              		.loc 1 1749 0
 1758 000c 7B68     		ldr	r3, [r7, #4]
 1759 000e 002B     		cmp	r3, #0
 1760 0010 06D1     		bne	.L74
1750:C:/StellarisWare/driverlib\pwm.c ****     {
1751:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0));
 1761              		.loc 1 1751 0
 1762 0012 FA68     		ldr	r2, [r7, #12]
 1763 0014 BB68     		ldr	r3, [r7, #8]
 1764 0016 D318     		adds	r3, r2, r3
 1765 0018 03F13403 		add	r3, r3, #52
 1766 001c 1B68     		ldr	r3, [r3, #0]
 1767 001e 05E0     		b	.L75
 1768              	.L74:
1752:C:/StellarisWare/driverlib\pwm.c ****     }
1753:C:/StellarisWare/driverlib\pwm.c ****     else
1754:C:/StellarisWare/driverlib\pwm.c ****     {
1755:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC1));
 1769              		.loc 1 1755 0
 1770 0020 FA68     		ldr	r2, [r7, #12]
 1771 0022 BB68     		ldr	r3, [r7, #8]
 1772 0024 D318     		adds	r3, r2, r3
 1773 0026 03F13803 		add	r3, r3, #56
 1774 002a 1B68     		ldr	r3, [r3, #0]
 1775              	.L75:
1756:C:/StellarisWare/driverlib\pwm.c ****     }
1757:C:/StellarisWare/driverlib\pwm.c **** }
 1776              		.loc 1 1757 0
 1777 002c 1846     		mov	r0, r3
 1778 002e 07F11407 		add	r7, r7, #20
 1779 0032 BD46     		mov	sp, r7
 1780 0034 80BC     		pop	{r7}
 1781 0036 7047     		bx	lr
 1782              		.cfi_endproc
 1783              	.LFE32:
 1785              		.section	.text.PWMGenFaultStatus,"ax",%progbits
 1786              		.align	2
 1787              		.global	PWMGenFaultStatus
 1788              		.thumb
 1789              		.thumb_func
 1791              	PWMGenFaultStatus:
 1792              	.LFB33:
1758:C:/StellarisWare/driverlib\pwm.c **** 
1759:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1760:C:/StellarisWare/driverlib\pwm.c **** //
1761:C:/StellarisWare/driverlib\pwm.c **** //! Returns the current state of the fault triggers for a given PWM generator.
1762:C:/StellarisWare/driverlib\pwm.c **** //!
1763:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1764:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator for which fault trigger states are being
1765:C:/StellarisWare/driverlib\pwm.c **** //! queried.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,
1766:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_2, or \b PWM_GEN_3.
1767:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGroup indicates the subset of faults that are being queried.  This
1768:C:/StellarisWare/driverlib\pwm.c **** //! parameter must be \b PWM_FAULT_GROUP_0 or \b PWM_FAULT_GROUP_1.
1769:C:/StellarisWare/driverlib\pwm.c **** //!
1770:C:/StellarisWare/driverlib\pwm.c **** //! This function allows an application to query the current state of each of
1771:C:/StellarisWare/driverlib\pwm.c **** //! the fault trigger inputs to a given PWM generator.  The current state of
1772:C:/StellarisWare/driverlib\pwm.c **** //! each fault trigger input is returned unless PWMGenConfigure() has
1773:C:/StellarisWare/driverlib\pwm.c **** //! previously been called with flag \b PWM_GEN_MODE_FAULT_LATCHED in the
1774:C:/StellarisWare/driverlib\pwm.c **** //! \e ulConfig parameter, in which case the returned status is the latched
1775:C:/StellarisWare/driverlib\pwm.c **** //! fault trigger status.
1776:C:/StellarisWare/driverlib\pwm.c **** //!
1777:C:/StellarisWare/driverlib\pwm.c **** //! If latched faults are configured, the application must call
1778:C:/StellarisWare/driverlib\pwm.c **** //! PWMGenFaultClear() to clear each trigger.
1779:C:/StellarisWare/driverlib\pwm.c **** //!
1780:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is only available on devices supporting extended PWM
1781:C:/StellarisWare/driverlib\pwm.c **** //! fault handling.
1782:C:/StellarisWare/driverlib\pwm.c **** //!
1783:C:/StellarisWare/driverlib\pwm.c **** //! \return Returns the current state of the fault triggers for the given PWM
1784:C:/StellarisWare/driverlib\pwm.c **** //! generator.  A set bit indicates that the associated trigger is active.
1785:C:/StellarisWare/driverlib\pwm.c **** //! For \b PWM_FAULT_GROUP_0, the returned value is a logical OR of
1786:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
1787:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_FAULT3.  For \b PWM_FAULT_GROUP_1, the return value is the
1788:C:/StellarisWare/driverlib\pwm.c **** //! logical OR of \b PWM_FAULT_DCMP0, \b PWM_FAULT_DCMP1,
1789:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP2, \b PWM_FAULT_DCMP3, \b PWM_FAULT_DCMP4,
1790:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_FAULT_DCMP5, \b PWM_FAULT_DCMP6, or \b PWM_FAULT_DCMP7.
1791:C:/StellarisWare/driverlib\pwm.c **** //
1792:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1793:C:/StellarisWare/driverlib\pwm.c **** unsigned long
1794:C:/StellarisWare/driverlib\pwm.c **** PWMGenFaultStatus(unsigned long ulBase, unsigned long ulGen,
1795:C:/StellarisWare/driverlib\pwm.c ****                   unsigned long ulGroup)
1796:C:/StellarisWare/driverlib\pwm.c **** {
 1793              		.loc 1 1796 0
 1794              		.cfi_startproc
 1795              		@ args = 0, pretend = 0, frame = 16
 1796              		@ frame_needed = 1, uses_anonymous_args = 0
 1797              		@ link register save eliminated.
 1798 0000 80B4     		push	{r7}
 1799              	.LCFI99:
 1800              		.cfi_def_cfa_offset 4
 1801              		.cfi_offset 7, -4
 1802 0002 85B0     		sub	sp, sp, #20
 1803              	.LCFI100:
 1804              		.cfi_def_cfa_offset 24
 1805 0004 00AF     		add	r7, sp, #0
 1806              	.LCFI101:
 1807              		.cfi_def_cfa_register 7
 1808 0006 F860     		str	r0, [r7, #12]
 1809 0008 B960     		str	r1, [r7, #8]
 1810 000a 7A60     		str	r2, [r7, #4]
1797:C:/StellarisWare/driverlib\pwm.c ****     //
1798:C:/StellarisWare/driverlib\pwm.c ****     // Check for valid parameters.
1799:C:/StellarisWare/driverlib\pwm.c ****     //
1800:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1801:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1802:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
1803:C:/StellarisWare/driverlib\pwm.c **** 
1804:C:/StellarisWare/driverlib\pwm.c ****     //
1805:C:/StellarisWare/driverlib\pwm.c ****     // Return the current fault status.
1806:C:/StellarisWare/driverlib\pwm.c ****     //
1807:C:/StellarisWare/driverlib\pwm.c ****     if(ulGroup == PWM_FAULT_GROUP_0)
 1811              		.loc 1 1807 0
 1812 000c 7B68     		ldr	r3, [r7, #4]
 1813 000e 002B     		cmp	r3, #0
 1814 0010 0ED1     		bne	.L77
1808:C:/StellarisWare/driverlib\pwm.c ****     {
1809:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0));
 1815              		.loc 1 1809 0
 1816 0012 BB68     		ldr	r3, [r7, #8]
 1817 0014 03F10043 		add	r3, r3, #-2147483648
 1818 0018 A3F14003 		sub	r3, r3, #64
 1819 001c 4FEA4302 		lsl	r2, r3, #1
 1820 0020 FB68     		ldr	r3, [r7, #12]
 1821 0022 D318     		adds	r3, r2, r3
 1822 0024 03F50063 		add	r3, r3, #2048
 1823 0028 03F10403 		add	r3, r3, #4
 1824 002c 1B68     		ldr	r3, [r3, #0]
 1825 002e 0DE0     		b	.L78
 1826              	.L77:
1810:C:/StellarisWare/driverlib\pwm.c ****     }
1811:C:/StellarisWare/driverlib\pwm.c ****     else
1812:C:/StellarisWare/driverlib\pwm.c ****     {
1813:C:/StellarisWare/driverlib\pwm.c ****         return(HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT1));
 1827              		.loc 1 1813 0
 1828 0030 BB68     		ldr	r3, [r7, #8]
 1829 0032 03F10043 		add	r3, r3, #-2147483648
 1830 0036 A3F14003 		sub	r3, r3, #64
 1831 003a 4FEA4302 		lsl	r2, r3, #1
 1832 003e FB68     		ldr	r3, [r7, #12]
 1833 0040 D318     		adds	r3, r2, r3
 1834 0042 03F50063 		add	r3, r3, #2048
 1835 0046 03F10803 		add	r3, r3, #8
 1836 004a 1B68     		ldr	r3, [r3, #0]
 1837              	.L78:
1814:C:/StellarisWare/driverlib\pwm.c ****     }
1815:C:/StellarisWare/driverlib\pwm.c **** }
 1838              		.loc 1 1815 0
 1839 004c 1846     		mov	r0, r3
 1840 004e 07F11407 		add	r7, r7, #20
 1841 0052 BD46     		mov	sp, r7
 1842 0054 80BC     		pop	{r7}
 1843 0056 7047     		bx	lr
 1844              		.cfi_endproc
 1845              	.LFE33:
 1847              		.section	.text.PWMGenFaultClear,"ax",%progbits
 1848              		.align	2
 1849              		.global	PWMGenFaultClear
 1850              		.thumb
 1851              		.thumb_func
 1853              	PWMGenFaultClear:
 1854              	.LFB34:
1816:C:/StellarisWare/driverlib\pwm.c **** 
1817:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1818:C:/StellarisWare/driverlib\pwm.c **** //
1819:C:/StellarisWare/driverlib\pwm.c **** //! Clears one or more latched fault triggers for a given PWM generator.
1820:C:/StellarisWare/driverlib\pwm.c **** //!
1821:C:/StellarisWare/driverlib\pwm.c **** //! \param ulBase is the base address of the PWM module.
1822:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGen is the PWM generator for which fault trigger states are being
1823:C:/StellarisWare/driverlib\pwm.c **** //! queried.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,
1824:C:/StellarisWare/driverlib\pwm.c **** //! \b PWM_GEN_2, or \b PWM_GEN_3.
1825:C:/StellarisWare/driverlib\pwm.c **** //! \param ulGroup indicates the subset of faults that are being queried.
1826:C:/StellarisWare/driverlib\pwm.c **** //! This parameter must be \b PWM_FAULT_GROUP_0 or \b PWM_FAULT_GROUP_1.
1827:C:/StellarisWare/driverlib\pwm.c **** //! \param ulFaultTriggers is the set of fault triggers which are to be
1828:C:/StellarisWare/driverlib\pwm.c **** //! cleared.
1829:C:/StellarisWare/driverlib\pwm.c **** //!
1830:C:/StellarisWare/driverlib\pwm.c **** //! This function allows an application to clear the fault triggers for a
1831:C:/StellarisWare/driverlib\pwm.c **** //! given PWM generator.  This function is only required if PWMGenConfigure()
1832:C:/StellarisWare/driverlib\pwm.c **** //! has previously been called with flag \b PWM_GEN_MODE_FAULT_LATCHED in
1833:C:/StellarisWare/driverlib\pwm.c **** //! parameter \e ulConfig.
1834:C:/StellarisWare/driverlib\pwm.c **** //!
1835:C:/StellarisWare/driverlib\pwm.c **** //! \note This function is only available on devices supporting extended PWM
1836:C:/StellarisWare/driverlib\pwm.c **** //! fault handling.
1837:C:/StellarisWare/driverlib\pwm.c **** //!
1838:C:/StellarisWare/driverlib\pwm.c **** //! \return None.
1839:C:/StellarisWare/driverlib\pwm.c **** //
1840:C:/StellarisWare/driverlib\pwm.c **** //*****************************************************************************
1841:C:/StellarisWare/driverlib\pwm.c **** void
1842:C:/StellarisWare/driverlib\pwm.c **** PWMGenFaultClear(unsigned long ulBase, unsigned long ulGen,
1843:C:/StellarisWare/driverlib\pwm.c ****                  unsigned long ulGroup, unsigned long ulFaultTriggers)
1844:C:/StellarisWare/driverlib\pwm.c **** {
 1855              		.loc 1 1844 0
 1856              		.cfi_startproc
 1857              		@ args = 0, pretend = 0, frame = 16
 1858              		@ frame_needed = 1, uses_anonymous_args = 0
 1859              		@ link register save eliminated.
 1860 0000 80B4     		push	{r7}
 1861              	.LCFI102:
 1862              		.cfi_def_cfa_offset 4
 1863              		.cfi_offset 7, -4
 1864 0002 85B0     		sub	sp, sp, #20
 1865              	.LCFI103:
 1866              		.cfi_def_cfa_offset 24
 1867 0004 00AF     		add	r7, sp, #0
 1868              	.LCFI104:
 1869              		.cfi_def_cfa_register 7
 1870 0006 F860     		str	r0, [r7, #12]
 1871 0008 B960     		str	r1, [r7, #8]
 1872 000a 7A60     		str	r2, [r7, #4]
 1873 000c 3B60     		str	r3, [r7, #0]
1845:C:/StellarisWare/driverlib\pwm.c ****     //
1846:C:/StellarisWare/driverlib\pwm.c ****     // Check for valid parameters.
1847:C:/StellarisWare/driverlib\pwm.c ****     //
1848:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulBase == PWM0_BASE) || (ulBase == PWM1_BASE));
1849:C:/StellarisWare/driverlib\pwm.c ****     ASSERT(PWMGenValid(ulGen));
1850:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
1851:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_0) &&
1852:C:/StellarisWare/driverlib\pwm.c ****            ((ulFaultTriggers & ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
1853:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0));
1854:C:/StellarisWare/driverlib\pwm.c ****     ASSERT((ulGroup == PWM_FAULT_GROUP_1) &&
1855:C:/StellarisWare/driverlib\pwm.c ****            ((ulFaultTriggers & ~(PWM_FAULT_DCMP0 | PWM_FAULT_DCMP1 |
1856:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP2 | PWM_FAULT_DCMP3 |
1857:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP4 | PWM_FAULT_DCMP5 |
1858:C:/StellarisWare/driverlib\pwm.c ****                                  PWM_FAULT_DCMP6 | PWM_FAULT_DCMP7)) == 0));
1859:C:/StellarisWare/driverlib\pwm.c **** 
1860:C:/StellarisWare/driverlib\pwm.c ****     //
1861:C:/StellarisWare/driverlib\pwm.c ****     // Clear the given faults.
1862:C:/StellarisWare/driverlib\pwm.c ****     //
1863:C:/StellarisWare/driverlib\pwm.c ****     if(ulGroup == PWM_FAULT_GROUP_0)
 1874              		.loc 1 1863 0
 1875 000e 7B68     		ldr	r3, [r7, #4]
 1876 0010 002B     		cmp	r3, #0
 1877 0012 0FD1     		bne	.L80
1864:C:/StellarisWare/driverlib\pwm.c ****     {
1865:C:/StellarisWare/driverlib\pwm.c ****         HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0) =
 1878              		.loc 1 1865 0
 1879 0014 BB68     		ldr	r3, [r7, #8]
 1880 0016 03F10043 		add	r3, r3, #-2147483648
 1881 001a A3F14003 		sub	r3, r3, #64
 1882 001e 4FEA4302 		lsl	r2, r3, #1
 1883 0022 FB68     		ldr	r3, [r7, #12]
 1884 0024 D318     		adds	r3, r2, r3
 1885 0026 03F50063 		add	r3, r3, #2048
 1886 002a 03F10403 		add	r3, r3, #4
 1887 002e 3A68     		ldr	r2, [r7, #0]
 1888 0030 1A60     		str	r2, [r3, #0]
 1889 0032 0EE0     		b	.L79
 1890              	.L80:
1866:C:/StellarisWare/driverlib\pwm.c ****             ulFaultTriggers;
1867:C:/StellarisWare/driverlib\pwm.c ****     }
1868:C:/StellarisWare/driverlib\pwm.c ****     else
1869:C:/StellarisWare/driverlib\pwm.c ****     {
1870:C:/StellarisWare/driverlib\pwm.c ****         HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT1) =
 1891              		.loc 1 1870 0
 1892 0034 BB68     		ldr	r3, [r7, #8]
 1893 0036 03F10043 		add	r3, r3, #-2147483648
 1894 003a A3F14003 		sub	r3, r3, #64
 1895 003e 4FEA4302 		lsl	r2, r3, #1
 1896 0042 FB68     		ldr	r3, [r7, #12]
 1897 0044 D318     		adds	r3, r2, r3
 1898 0046 03F50063 		add	r3, r3, #2048
 1899 004a 03F10803 		add	r3, r3, #8
 1900 004e 3A68     		ldr	r2, [r7, #0]
 1901 0050 1A60     		str	r2, [r3, #0]
 1902              	.L79:
1871:C:/StellarisWare/driverlib\pwm.c ****             ulFaultTriggers;
1872:C:/StellarisWare/driverlib\pwm.c ****     }
1873:C:/StellarisWare/driverlib\pwm.c **** }
 1903              		.loc 1 1873 0
 1904 0052 07F11407 		add	r7, r7, #20
 1905 0056 BD46     		mov	sp, r7
 1906 0058 80BC     		pop	{r7}
 1907 005a 7047     		bx	lr
 1908              		.cfi_endproc
 1909              	.LFE34:
 1911              		.text
 1912              	.Letext0:
 1913              		.file 2 "C:\\StellarisWare/inc/hw_types.h"
DEFINED SYMBOLS
                            *ABS*:00000000 pwm.c
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:19     .text.PWMGenConfigure:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:24     .text.PWMGenConfigure:00000000 PWMGenConfigure
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:99     .text.PWMGenPeriodSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:104    .text.PWMGenPeriodSet:00000000 PWMGenPeriodSet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:159    .text.PWMGenPeriodGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:164    .text.PWMGenPeriodGet:00000000 PWMGenPeriodGet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:217    .text.PWMGenEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:222    .text.PWMGenEnable:00000000 PWMGenEnable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:260    .text.PWMGenDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:265    .text.PWMGenDisable:00000000 PWMGenDisable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:303    .text.PWMPulseWidthSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:308    .text.PWMPulseWidthSet:00000000 PWMPulseWidthSet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:383    .text.PWMPulseWidthGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:388    .text.PWMPulseWidthGet:00000000 PWMPulseWidthGet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:465    .text.PWMDeadBandEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:470    .text.PWMDeadBandEnable:00000000 PWMDeadBandEnable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:523    .text.PWMDeadBandDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:528    .text.PWMDeadBandDisable:00000000 PWMDeadBandDisable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:568    .text.PWMSyncUpdate:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:573    .text.PWMSyncUpdate:00000000 PWMSyncUpdate
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:605    .text.PWMSyncTimeBase:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:610    .text.PWMSyncTimeBase:00000000 PWMSyncTimeBase
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:643    .text.PWMOutputState:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:648    .text.PWMOutputState:00000000 PWMOutputState
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:704    .text.PWMOutputInvert:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:709    .text.PWMOutputInvert:00000000 PWMOutputInvert
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:765    .text.PWMOutputFaultLevel:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:770    .text.PWMOutputFaultLevel:00000000 PWMOutputFaultLevel
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:826    .text.PWMOutputFault:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:831    .text.PWMOutputFault:00000000 PWMOutputFault
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:887    .text.PWMGenIntGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:891    .text.PWMGenIntGet:00000000 PWMGenIntGet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1005   .text.PWMGenIntRegister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1010   .text.PWMGenIntRegister:00000000 PWMGenIntRegister
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1050   .text.PWMGenIntUnregister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1055   .text.PWMGenIntUnregister:00000000 PWMGenIntUnregister
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1093   .text.PWMFaultIntGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1097   .text.PWMFaultIntGet:00000000 PWMFaultIntGet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1138   .text.PWMFaultIntRegister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1143   .text.PWMFaultIntRegister:00000000 PWMFaultIntRegister
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1181   .text.PWMFaultIntUnregister:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1186   .text.PWMFaultIntUnregister:00000000 PWMFaultIntUnregister
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1222   .text.PWMGenIntTrigEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1227   .text.PWMGenIntTrigEnable:00000000 PWMGenIntTrigEnable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1269   .text.PWMGenIntTrigDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1274   .text.PWMGenIntTrigDisable:00000000 PWMGenIntTrigDisable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1317   .text.PWMGenIntStatus:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1322   .text.PWMGenIntStatus:00000000 PWMGenIntStatus
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1373   .text.PWMGenIntClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1378   .text.PWMGenIntClear:00000000 PWMGenIntClear
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1414   .text.PWMIntEnable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1419   .text.PWMIntEnable:00000000 PWMIntEnable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1456   .text.PWMIntDisable:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1461   .text.PWMIntDisable:00000000 PWMIntDisable
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1499   .text.PWMFaultIntClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1504   .text.PWMFaultIntClear:00000000 PWMFaultIntClear
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1536   .text.PWMIntStatus:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1541   .text.PWMIntStatus:00000000 PWMIntStatus
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1586   .text.PWMFaultIntClearExt:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1591   .text.PWMFaultIntClearExt:00000000 PWMFaultIntClearExt
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1624   .text.PWMGenFaultConfigure:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1629   .text.PWMGenFaultConfigure:00000000 PWMGenFaultConfigure
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1676   .text.PWMGenFaultTriggerSet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1681   .text.PWMGenFaultTriggerSet:00000000 PWMGenFaultTriggerSet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1732   .text.PWMGenFaultTriggerGet:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1737   .text.PWMGenFaultTriggerGet:00000000 PWMGenFaultTriggerGet
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1786   .text.PWMGenFaultStatus:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1791   .text.PWMGenFaultStatus:00000000 PWMGenFaultStatus
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1848   .text.PWMGenFaultClear:00000000 $t
C:\Users\Sarthak\AppData\Local\Temp\ccw62aZm.s:1853   .text.PWMGenFaultClear:00000000 PWMGenFaultClear
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
IntRegister
IntEnable
IntDisable
IntUnregister
